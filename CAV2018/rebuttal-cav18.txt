(R1) The use of normal forms.

The need for normal forms arises from the fact that the FWL effects
apply directly to the coefficients of the controller, thus the
equations supplied to the solver must be presented in a domain where
these are unaltered (i.e. Reachable and Observable Canonical Form).

(R1) Concerns about Theorem 3.

By looking at the radius of the eigenvalues we consider the envelope
of the signal, thus including overshoots.  Having shown this for
diagonalizable matrices, we explain how the effect of the overshoot
caused by geometric multiplicities (the case you expose) is
compensated by finding the point at which the envelope becomes
strictly convergent(\underline{k}), and the iteration after this where
the envelope is within the target specification (settling time).

(R2) Why is the CEGIS approach different from the one in Aabate's
CAV'17 paper?

As you have correctly pointed out, one of the main contributions of
this paper is the optimization function, which, while being indeed
performed after the counterexample has been found, it does however
participate in an iterative process which contains two distinct
refinement loops (leading back from stage 4 to stages 1 or 3 in figure
2), so it is not simply post-processing but at the core of our CEGIS
loop.

The second main contribution compared to CAV'17 is the fact that the
current submission deals with continuous time models, which CAV'17
does not. This introduces the refinement of the sampling time that
corresponds to stage 7 in Fig 2.

(R2) What are the timings when trying to solve the current problem
with the techniques in Aabate's CAV'17?

The standard CEGIS in our experimental results actually denotes the
abstraction-based CEGIS implementation from CAV'17 -- sorry for being
unclear about this.

(R2) How much harder is to synthesize a controller+observer, compared
to just a controller?

The introduction of the observer doubles the order of the model.  With
respect to experimental results, some of the minimum times obtained
when using the CAV'17 implementation (referred to as standard CEGIS in
Section 8) for the controller+observer vs the controller case are:
helicopter -- 57.2s vs 1.37s, inv_pendulum -- 277s vs 0.56s, pendulum
-- 0.8s vs 0.6s. In general, median times are much worse. We are happy
to include these results for the full set of benchmarks.

(R2) How does the optimization step compare to Raman et al. "Reactive
synthesis from signal temporal logic specifications", HSCC'15?

The main difference with Raman et al. is that we are working on
different domains, namely they work with LTL models (LTL is not a
typo), while we consider PID-like controllers -- we have explained the
disadvantages of LTL models vs direct linear control in Section 1,
paragraph 2. However, given that the objective of their optimization
function is similar to ours, it might be indeed useful to extrapolate
their objective functions into their equivalent in our domain -- thank
you for the suggestion.

(R3) Why use a SAT solver and not a numerical solver given that you are discovering matrices and that you have an optimization criterion? What solver was used for the optimization step?

We use a SAT solver because we need to fit matrices to FWL effects
which are better processed using SAT.  The optimization is done using
our own algorithm described in Section 7, under "Refine abstraction
and optimize".

(R3) How are constraints generated in Abstract step used by the
SYNTHESIZE phase to reduce the size of the solution space?

We incorporate the constraints in the solver by adding them to the formula.
