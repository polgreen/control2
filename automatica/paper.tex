% autosam.tex
% Annotated sample file for the preparation of LaTeX files
% for the final versions of papers submitted to or accepted for 
% publication in AUTOMATICA.

% See also the Information for Authors.

% Make sure that the zip file that you send contains all the 
% files, including the files for the figures and the bib file.

% Output produced with the elsart style file does not imitate the
% AUTOMATICA style. The style file is generic for all Elsevier
% journals and the output is laid out for easy copy editing. The
% final document is produced from the source file in the
% AUTOMATICA style at Elsevier.

% You may use the style file autart.cls to obtain a two-column 
% document (see below) that more or less imitates the printed 
% Automatica style. This may helpful to improve the formatting 
% of the equations, tables and figures, and also serves to check 
% whether the paper satisfies the length requirements.

% Please note: Authors must not create their own macros.

% For further information regarding the preparation of LaTeX files 
% for Elsevier, please refer to the "Full Instructions to Authors" 
% from Elsevier's anonymous ftp server on ftp.elsevier.nl in the
% directory pub/styles, or from the internet (CTAN sites) on
% ftp.shsu.edu, ftp.dante.de and ftp.tex.ac.uk in the directory
% tex-archive/macros/latex/contrib/supported/elsevier.


%\documentclass{elsart}               % The use of LaTeX2e is preferred.

\documentclass[twocolumn]{autart}    % Enable this line and disable the 
                                     % preceding line to obtain a two-column 
                                     % document whose style resembles the
                                     % printed Automatica style.

\usepackage{graphicx}
\usepackage{color}
\usepackage{amssymb}
\usepackage{amsmath}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{framed}
\usepackage{listings}
\usepackage{algorithm,algpseudocode}
\usepackage{epstopdf}
\usepackage{cite}
\usepackage{pifont}
\usepackage{inconsolata}
\usepackage{todonotes}
\usetikzlibrary{positioning, automata, shapes.arrows, calc, shapes, arrows}
\usetikzlibrary{patterns}

\tikzset{
    %Define style for boxes
    box/.style={
           rectangle,
           rounded corners,
           draw=black, very thick,
           fill=yellow!20,
           text width=10em,
           minimum height=2em,
           text centered},
 % 
  futurebox/.style={
           rectangle,
           rounded corners,
           draw=black, very thick,
           fill=blue!10,
           text width=10em,
           minimum height=2em,
           text centered},
 % 
  longfuturebox/.style={
           rectangle,
           rounded corners,
           draw=black, very thick,
           fill=purple!20,
           text width=10em,
           minimum height=2em,
           text centered},
%
    % Define arrow style
    arrow/.style={
           ->,
           thick,
           shorten <=2pt,
           shorten >=2pt,}
}

\usepackage{url}

%\newcommand{\tool}{{\sf DSSynth}\xspace}
\newcommand{\addtodo}[1]{\textcolor{red}{[#1]}}
\newcommand{\mat}[1]{{#1}}
\renewcommand{\vec}[1]{{#1}}
\newcommand{\comment}[1]{}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{proof}{Proof}

\renewcommand{\note}[1]{\textcolor{red}{[#1]}}

\begin{document}
\newcommand\tool{{\sf DSSynth}}
\begin{frontmatter}

%\runtitle{Insert a suggested running title}  % Running title for regular 
                                              % papers but only if the title  
                                              % is over 5 words. Running title 
                                              % is not shown in output.

%\thanksref{footnoteinfo}

\title{Safe and Robust Formal Synthesis of Digital Controllers\\
for Continuous Plants}
% Title, preferably not more
% than 10 words.

%\thanks[footnoteinfo]{This paper was not presented at any IFAC 
%meeting. Corresponding author M.~T.~Cicero. Tel. +XXXIX-VI-mmmxxi. 
%Fax +XXXIX-VI-mmmxxv.}

\author[oxford]{Alessandro Abate}\ead{alessandro.abate@cs.ox.ac.uk},
\author[manaus]{Iury Bessa}\ead{iurybessa@ufam.edu.br},
\author[oxford]{Dario Cattaruzza}\ead{dario.cattaruzza@cs.ox.ac.uk},
\author[oxford,manaus]{Lucas Cordeiro}\ead{lucas.cordeiro@cs.ox.ac.uk},
\author[cambridge]{Cristina David}\ead{cd652@cam.ac.uk},
\author[oxford]{Pascal Kessel}\ead{pascal.kesseli@stx.ox.ac.uk},
\author[oxford]{Daniel Kroening}\ead{kroening@cs.ox.ac.uk},
\author[oxford]{Elizabeth Polgreen}\ead{elizabeth.polgreen@linacre.ox.ac.uk}

\address[oxford]{University of Oxford, UK}
\address[cambridge]{University of Cambridge, UK}
\address[manaus]{Federal University of Amazonas, Brazil} 
          
\begin{keyword}                           % Five to ten keywords,  
Digital control synthesis; Safety requirements; A/D converters; Quantization errors; Sampling.               % chosen from the IFAC 
\end{keyword}                             % keyword list or with the 
                                          % help of the Automatica 
                                          % keyword wizard

%\keywords{
%State-space dynamical models of physical systems; 
%digital controllers; 
%analogue-to-digital converters; 
%time sampling; 
%quantization; 
%fixed-point arithmetic; 
%CEGIS; 
%safety requirements. 
%}


\begin{abstract}                          % Abstract of not more than 200 words.
%\textcolor{red}{Cristina: Can you please write an initial version of the abstract.}
We present a sound and automated approach to synthesizing safe,
digital controllers for physical plants represented as linear,
time-invariant models. Models are defined as differential equations
with inputs, evolving over a continuous state space. The synthesis
accounts for errors caused by the digitization effects introduced by
the controller. Our approach uses counterexample-guided inductive
synthesis (CEGIS): an inductive generalisation phase produces a
possible solution that is known to stabilize the system but that may
not be safe for all initial conditions. Safety is then verified either
via BMC or abstract acceleration; if the verification step fails, a
counterexample is provided to the inductive generalisation and the
process iterates until a safe controller is obtained.  We demonstrate
the practical value of this approach by automatically synthesizing
safe controllers for physical plant models from the digital control
literature.
\end{abstract}

\end{frontmatter}

\section{Introduction}

Modern implementations of embedded control systems have proliferated
with the availability of low-cost devices that can perform highly
non-trivial control tasks, with significant impact in numerous
application areas such as life sciences, environmental control and
robotics~\cite{astrom1997computer, Franklin15}.  Correct synthesis of
control software for such platforms is non-trivial, even in cases with
restricted dynamics.

In this paper, we examine the case of Linear Time Invariant (LTI)
models, for which the synthesis of controllers is well understood.
However, the use of digital control architectures adds new challenges
caused by artifacts specific to digital control, such as the effects
of finite-precision arithmetic, time discretization and quantization
noise introduced by A/D and D/A conversion.
%
Given an LTI model, we develop an automatic technique for generating
correct by construction digital controllers that addresses all these
challenges. Specifically, we synthesize stable and safe,
software-implemented embedded controllers.  Due to the complexity of
such closed-loop systems, we focus on linear models with known
configurations, and perform parametric synthesis of controllers.
%meeting a number of properties that define their desired behavior.

%% While research on digital control is well developed~\cite{astrom1997computer},
%% automated and sound control synthesis is challenging, particularly when the
%% synthesis objective goes beyond classical stability.  There are recent methods
%% for verifying reachability properties of a given controller~\cite{FLD+11}.
%% However, these methods have not been generalized to control synthesis.  
%% Note that a synthesis algorithm that guarantees stability does not
%% ensure safety: the system might transitively visit an unsafe state resulting
%% in unrecoverable failure. %% Programming expertise is a key
%% barrier to broad adoption of correct digital controllers, and requires
%% considerable knowledge outside of the expertise of many control engineers.

%% Beyond classical a-posteriori validation in digital control, there has been
%% plenty of previous work aiming at \emph{verifying} a given designed
%% controller, which however broadly lack automation.  Recent work has studied
%% the stability of digital controllers considering implementation aspects,
%% i.e., fixed-point arithmetic and the word length~\cite{Bessa16}.  They
%% exploit advances in bit-accurate verification of C programs to obtain a
%% verifier for software-implemented digital control.


%% we leverage a very recent step-change in the automation and
%% scalability of \emph{program synthesis}.  %% Program synthesis engines use a
%% %% specification as the starting point, and subsequently generate a sequence of
%% %% candidate programs from a given template.  The candidate programs are
%% %% iteratively refined to eventually satisfy the specification.
%% Program
%% synthesizers implementing Counter-Example Guided Inductive Synthesis
%% (CEGIS)~\cite{DBLP:conf/asplos/Solar-LezamaTBSS06} are now able to generate
%% programs for highly non-trivial specifications with a very high degree of
%% automation.  Modern synthesis engines combine automated testing, genetic
%% algorithms, and SMT-based automated
%% reasoning~\cite{DBLP:journals/corr/AlurFSS16a, DBLP:conf/lpar/DavidKL15}.

%% By combining state-of-the-art synthesis engines we present a tool that
%% automatically generates digital controllers for a given continuous plant
%% model that are correct by construction.  This approach delivers a high
%% degree of automation, promises to reduce the cost and time of development of
%% digital control dramatically, and requires considerably less expertise than
%% a-posteriori verification.  Specifically, we synthesize stable,
%% software-implemented embedded controllers along with a model of a physical
%% plant.  Due to the complexity of such closed-loop systems, in this work we
%% focus on linear models with known configurations, and perform parametric
%% synthesis of stabilizing digital controllers with a number of properties that
%% define their desired behaviour.

Our work addresses challenging aspects of the control synthesis
problem.  We perform digital control synthesis over a hybrid model,
where the plant exhibits continuous behavior whereas the controller
operates in discrete time and over a quantized domain.  In particular,
our model evaluates the effects of the quantizers (A/D and D/A
converters) and of time discretization, as well as representation
errors introduced by modeling %% artifacts such as an
%% observer~\cite{astrom1997computer}
in a finite precision domain, while reasoning about high level
properties such as stability, robustness, and safety, which define the
behaviour of the system.  Notably, safety requirements are
frequently overlooked in conventional feedback control synthesis, but
play an important role in systems engineering.

%% Using state of the art verifiers, we evaluate these models against
%% automatically synthesised controllers using CEGIS-based synsthesis that
%% incorporate the above mentioned artifacts in different models of
%% Single-Input/Single-Output (SISO) systems.
In this paper we present two novel approaches for the synthesis of
digital controllers, both of which make use of CounterExample-Guided
Inductive Synthesis (CEGIS)~\cite{jha-icse10,
  DBLP:conf/asplos/Solar-LezamaTBSS06}, a technique
that became very popular in the recent years.  CEGIS denotes an
iterative process, where each iteration performs inductive
generalisation based on counterexamples provided by a verification
oracle. Essentially, the inductive generalisation uses information
about a limited number of inputs to make claims about all the possible
inputs in the form of candidate solutions. Our two instantiations of
CEGIS are described next.

%% offer three modes of
%% operation that address different aspects of the problem.
%% {\em The first  approach} uses a transfer-function based analysis that
%% solves the problem of robust stability for closed loop systems for a
%% collection of unstable plants.  Inthis case, there is no safety
%% specification since we are working in the frequency domain.
{\em The first approach} uses a na\"ive technique that starts by devising a
digital controller that stabilizes the system while remaining safe for a
pre-selected time horizon and a single initial state; then, it verifies
unbounded safety by unfolding the dynamics of the system, considering the
full hyper-cube of initial states, and checking a {\em completeness
threshold}~\cite{DBLP:conf/vmcai/KroeningS03}, i.e., the number of
iterations required to sufficiently unwind the closed-loop state-space
system such that the boundaries are not violated for any larger number of
iterations.  As~it requires unfolding up to the completeness threshold, this
approach is computationally expensive.

Instead of unfolding the dynamics, {\em the second approach}
employs {\em abstract acceleration}~\cite{cattaruzza2015unbounded} to
evaluate all possible progressions of the system simultaneously. 
Additionally, this approach uses {\em abstraction refinement},
enabling us to always start with a very simple description regardless of the
dynamics complexity, and only expand to more complex models
when a solution cannot be found.

We provide experimental results showing that both our approaches are able to
efficiently synthesize safe controllers for a set of intricate physical
plant models taken from the digital control literature.
\addtodo{add more here once we have the experimental results ready}

%% \addtodo{CD: the novelty compared to CAV'17 needs to be clarified}
This paper represents an extension of \cite{DBLP:conf/cav/AbateBCCDKKP17}
and makes the following contributions, where the fourth and the fifth denote
extensions over \cite{DBLP:conf/cav/AbateBCCDKKP17}.
%
\begin{enumerate}

  % Additions from CAV:
  % continuous time
  % floating point 
\item We automatically generate {\em correct-by-construction} digital
  controllers using an inductive synthesis approach.  Our application of program
  synthesis is non-trivial and addresses challenges specific to control
  systems, such as quantizers and FWL.  %% In particular, we
  %% have found that a two-stage verification engine that continuously refines
  %% the precision of the fixed-point representation of the plant yields a
  %% speed-up of two orders of magnitude over a conventional one-stage
  %% verification engine.
%
  %\item  We compute
  The computed state-feedback controllers 
  guarantee a given safety property alongside stability and safety
  specifications. Existing methods for controller synthesis rely on transfer
  function representations, which are inadequate to prove safety requirements.
%
\item We provide two novel algorithms: the first, na\"ive one, relies on
  an unfolding of the dynamics up to a completeness threshold, while the
  second one is abstraction-based and leverages abstraction refinement and
  acceleration to improve scalability while retaining soundness.  %% A third
  %% algorithm evaluates systems using transfer functions where no state-space
  %% description is given.
  Both approaches provide sound synthesis of
  feedback controllers and consider the various sources of imprecision in
  the implementation of the control algorithm and in the modeling of the
  plant.
%
\item We develop a model for different sources of quantization error and
  their effect on reachability properties.  We give bounds that ensure the
  safety of our controllers in a hybrid continuous-digital domain.

\item While \cite{DBLP:conf/cav/AbateBCCDKKP17} is restricted to systems
  modeled in discrete time, in the current paper we present a model for
  soundly evaluating reachability in a combined continuous-discrete time/space.
\item A further limitation of the work in \cite{DBLP:conf/cav/AbateBCCDKKP17}
  is its restriction to fixed-point arithmetic, meaning that fixed-point numbers
  were employed for the representation of both the plant and the controller, as well as for
  the operations performed by each of them.
  Conversely, in the current paper we also make use of floating-point arithmetic
  and compare the two approaches. Additionally, we enhance the implementation with an SMT backend, allowing us to also use reals in order to represent the states of the plant.
\end{enumerate}
  
%-------------------------------
\section{Related Work}
\label{sec:relw}
%-------------------------------

\textbf{CEGIS -} Program synthesis is the problem of computing
correct-by-design programs from high-level specifications. Algorithms
for this problem have made substantial progress in recent years, in
particular CEGIS, which is a recent approach to inductive synthesis
borrowing ideas from Counter-Example Guided Abstraction Refinement
(CEGAR)~\cite{DBLP:conf/cav/ClarkeGJLV00} and
superoptimisation~\cite{DBLP:conf/iclp/BrainCVF06,
  DBLP:conf/asplos/Massalin87}.  This approach uses an iterative
process where each iteration performs inductive generalisation based
on counterexamples provided by a verification oracle.  In the absence
of complete specifications, oracles are queried to distinguish between
non-equivalent
programs~\cite{jha-icse10,DBLP:conf/fmcad/AlurBJMRSSSTU13}.

%% for instance~\cite{itzhaky2010simple} 
%% to inductively synthesize invariants for the generation of desired programs.

Program synthesizers are an ideal fit for the synthesis of digital controllers, since
the semantics of programs capture the effects of finite-precision arithmetic
precisely.  In~\cite{DBLP:conf/cdc/RavanbakhshS15}, the authors use CEGIS
for the synthesis of switching controllers for stabilizing continuous-time
plants with polynomial dynamics.  The work extends to affine systems, but is
limited by the capacity of the state-of-the-art SMT solvers for solving
linear arithmetic.  Since this approach uses switching models instead of
linear dynamics for the digital controller, it avoids problems related to
finite precision arithmetic, but potentially suffers from state-space
explosion.  Moreover, in \cite{DBLP:conf/emsoft/RavanbakhshS16} the same
authors use a CEGIS-based approach for synthesizing continuous-time
switching controllers that guarantee \emph{reach-while-stay} properties of
closed-loop systems, i.e., properties that specify a set of goal states and
safe states (constrained reachability).  This solution is based on
synthesizing control Lyapunov functions for switched systems that yield
switching controllers with a guaranteed minimum dwell time in each mode. 
However, both approaches are unsuitable for the kind of control we seek to
synthesize.

The work in~\cite{hscc-paper} synthesizes stabilizing controllers for
continuous plants given as transfer functions by exploiting bit-accurate
verification of software-implemented digital controllers~\cite{Bessa16}. 
While this work also uses CEGIS, the approach is restricted to digital
controllers for stable closed-loop systems given as transfer function
models: this results in a static check on their coefficients.  By contrast,
in the current paper we consider a state-space representation of the
physical system, which requires ensuring the specification over actual
traces of the model, alongside the numerical soundness required by the
effects of discretisation and finite-precision errors.  A state-space model
has known advantages over the transfer function
representation~\cite{Franklin15}: it naturally generalizes to multivariate
systems (i.e., with multiple inputs and outputs); and it allows synthesis of
control systems with guarantees on the internal dynamics, e.g., to
synthesize controllers that make the closed-loop system \emph{safe}.  Our
work focuses on the \emph{safety} of internal states, which is usually
overlooked in the literature.  Moreover, our work integrates an
abstraction/refinement (CEGAR) step inside the main CEGIS loop.

The tool Pessoa~\cite{mazo2010pessoa} synthesizes correct-by-design embedded
control software in a Matlab toolbox.  It is based on the abstraction of a
physical system to an equivalent finite-state machine and on the computation
of reachability properties thereon.  Based on this safety specification,
\mbox{Pessoa} can synthesize embedded controller software for a range of
properties.  The embedded controller software can be more complicated than
the state-feedback control we synthesize, and the properties available cover
more detail.  However, relying on state-space discretization \mbox{Pessoa}
is likely to incur in scalability limitations.  Along this research line,
\cite{Anta2010,liu16} studies the synthesis of digital controllers for
continuous dynamics, and \cite{zamani2014} extends the approach to the
recent setup of Network Control Systems.

\textbf{Discretization Effects -}
The classical approach to control synthesis has often disregarded
digitalization effects, whereas more recently modern techniques have focused
on different aspects of discretization, including delayed
response~\cite{Duggirala2015} and finite word length (FWL) semantics, with
the goal either to verify~\cite{daes20161} or to optimize~\cite{oudjida2014design} given implementations.

There are two different problems that arise from FWL semantics.  The first
is the error in the dynamics caused by the inability to represent the exact
state of the physical system, while the second relates to rounding and
saturation errors during computation.  In~\cite{fialho1994stability}, a
stability measure based on the error of the digital dynamics ensures that
the deviation introduced by FWL does not make the digital system unstable. 
A~more recent approach~\cite{DBLP:journals/automatica/WuLCC09} uses
$\mu$-calculus to directly model the digital controller so that the selected
parameters are stable by design.  The analyses
in~\cite{DBLP:conf/hybrid/RouxJG15, DBLP:conf/hybrid/WangGRJF16} rely on an
invariant computation on the discrete system dynamics using Semi-Definite
Programming (SDP).  While the former uses bounded-input and bounded-output
(BIBO) properties to determine stability, the latter uses Lyapunov-based
quadratic invariants.  In both cases, the SDP solver uses floating-point
arithmetic and soundness is checked by bounding the error.  An alternative
is~\cite{park2016scalable}, where the verification of given control code is
performed against a known model by extracting an LTI model of the code by
symbolic execution: to account for rounding errors, an upper bound is
introduced in the verification phase.  The work in
\cite{picasso2003stabilization} introduces invariant sets as a mechanism to
bound the quantization error effect on stabilization as an invariant set
that always converges toward the controllable set.  Similarly,
\cite{liberzon2003hybrid} evaluates the quantization error dynamics and
bounds its trajectory to a known region over a finite time period.  This
technique works for both linear and non-linear systems.

%\note{Add note explaining relationship of this work with previously published papers. }

%-------------------------------
\section{Preliminaries}
%\label{sec:preliminaries}
\label{sec:model}
%-------------------------------

%-------------------------------
%\subsection{State-space representations of LTI models}
%\label{sec:model}
%-------------------------------

%% A dynamical system is a system in which a function describes the progression
%% of a state over time.  In a continuous domain with linear dynamics, it is
%% described by a first order Ordinary Differential Equation (ODE).
%% \begin{equation}
%% \dot{x}(t)=\mat{A}\vec{x}(t)+\mat{B}\vec{u}(t)% +\vec{w}(t)
%% \label{eq:dynamical}
%% \end{equation}

%-------------------------------
\subsection{State-space representation of physical systems}
\label{sec:model}
%-------------------------------

We consider models of physical plants expressed as ordinary differential
equations, which we assume to be controllable~\cite{Astrom08}: 
%
\begin{align}
\label{eq:ode1}
\dot{x}(t) = \mat{A}\vec{x}(t)+ \mat{B} \vec{u}(t), 
\end{align}
%
where 
$\vec{x} \in \mathbb{R}^p$,  
$\vec{u} \in \mathbb{R}^q$, 
$\mat{A} \in \mathbb{R}^{p \times p}$, 
$\mat{B} \in \mathbb{R}^{p \times q}$,
and $t \in \mathbb R_0^+$ denotes continuous time. 
%$\mat{A}$ and $\mat{B}$ are matrices that fully characterize the dynamics of the continuous plant,
We denote with $x(0)$ the initial state of the model.

Equation~\eqref{eq:ode1} is soundly discretized in time~\cite{middleton1990digital,van1978computing} at constant time intervals,
of duration $T_s$ (the sample time), 
into the difference equation
%
\begin{align}
\label{eq:plant}
\vec{x}_{k+1} =& \mat{A}_d \vec{x}_k+ \mat{B}_d \vec{u}_k, 
\end{align} 
where 
$\mat{A}_d=e^{\mat{A}T_s}$ and 
$\mat{B}_d = \int_{t = 0}^{T_s} e^{\mat{A} t} dt\ \mat{B}$, 
and where $k \in \mathbb N$ is a discrete counter and $\vec{x}_{0}=\vec{x}(0)$ denotes the initial state.  

Models \eqref{eq:ode1} and \eqref{eq:plant} depend on external non-determinism in the form of input signals $u (t)$ and  $u_k$, respectively. 
Feedback architectures can be employed to manipulate the properties and behaviors of the plant.   
We are interested in the synthesis of digital feedback control algorithms, 
as practically implemented on Field-Programmable Gate Arrays or Digital Signal Processors. 
Later, we will address the issue of variable quantization, 
introduced by ADC/DAC conversion blocks of Figure \ref{fig:digitalsystem}, 
as classically studied in \cite{astrom1997computer}. 

We consider state feedback control architectures, 
where $u_k$ (notice we work with the discretized signal) is $u_k = r_{k} - K x_k$. 
Here $K \in \mathbb{R}^{m \times n}$ is a state-feedback gain matrix, 
and $r_{k}$ is a reference signal (again digital). 
We will assume $r_k=0$, thus 
$\vec{x}_{k+1}=(\mat{A}_d-\mat{B}_d\mat{K})\vec{x}_k$. 

%-------------------------------
\subsection{\textcolor{red}{[Elizabeth: please add the specifics of the errors due to discretisation/quantisation, with reference to Fig. \ref{fig:digitalsystem}] and to what has been discussed in the Introductory section.}}
%\label{sec:}
%-------------------------------




\begin{figure*}[htb]
\centering

\tikzset{add/.style n args={4}{
    minimum width=6mm,
    path picture={
        \draw[circle] 
            (path picture bounding box.south east) -- (path picture bounding box.north west)
            (path picture bounding box.south west) -- (path picture bounding box.north east);
        \node[draw=none] at ($(path picture bounding box.south)+(0,0.13)$)     {\small #1};
        \node[draw=none] at ($(path picture bounding box.west)+(0.13,0)$)      {\small #2};
        \node[draw=none] at ($(path picture bounding box.north)+(0,-0.13)$)    {\small #3};
        \node[draw=none] at ($(path picture bounding box.east)+(-0.13,0)$)     {\small #4};
        }
    }
 }

\resizebox{1.0\textwidth}{!}{
 \begin{tikzpicture}[scale=0.6,-,>=stealth',shorten >=.2pt,auto,
     semithick, initial text=, ampersand replacement=\&,]

  \matrix[nodes={draw, fill=none, shape=rectangle, minimum height=.2cm, minimum width=.2cm, align=center}, row sep=.6cm, column sep=.6cm] {
    \node[draw=none] (r) {$r_k$};
    
   \& \node[circle,add={-}{+}{}{}] (circle) {};
   \node[draw=none] (ez) at ([xshift=1cm,yshift=.15cm]circle)  {$u_k$};
   \node[rectangle,draw,minimum width=1cm,minimum height=1cm] (Kd) at ([xshift=0,yshift=-1.5cm]circle)  {\sc $\mat{K}$};
   \coordinate (kdsouth) at ([yshift=-2cm]Kd);
      
   
   \& complexnode/.pic={ 
      \node[rectangle,dashed,draw,minimum width=3cm,minimum height=1.6cm,label=\textbf{DAC}] (dac) {};
     \node[circle,add={+}{+}{}{},fill=gray!20] (q2) at ([xshift=-.65cm]dac.center) {};
     \node[draw=none] (q2t)  at ([yshift=.55cm]q2) {{\sc Q2}};
     \node[draw=none] (v2)  at ([yshift=-1.5cm]q2) {$\nu_2$};
     \node[fill=gray!20] (zoh) at ([xshift=.65cm]dac.center) {\sc ZOH};
   }   

   \& complexnode/.pic={ 
      \node[rectangle,dashed,draw,minimum width=8cm,minimum height=3.5cm,label=\textbf{Plant}] (plant)  at ([yshift=-.5cm]dac.center) {};
      \node[rectangle,draw,minimum width=1cm,minimum height=1cm] (B) at ([xshift=-2.5cm,yshift=.5cm]plant.center)  {\sc $\mat{B}$};
      \node[draw=none] (u) at ([xshift=-1cm,yshift=.15cm]B)  {$u(t)$};
      \node[circle,add={+}{+}{}{}] (p1) at ([xshift=-1.3cm,yshift=.5cm]plant.center) {};
      \node[draw=none] (xdot) at ([xshift=.85cm,yshift=.15cm]p1)  {$\dot{\vec{x}}(t)$};   
      \node[rectangle,draw,minimum width=1cm] (int) at ([xshift=.5cm,yshift=.5cm]plant.center) {\sc $\int$};
      \coordinate (xsouth) at ([xshift=1cm]int);
      \node[draw=none] (x) at ([xshift=1cm,yshift=.15cm]int)  {$\vec{x}(t)$};
      \node[rectangle,draw,minimum width=1cm,minimum height=1cm] (A) at ([xshift=.5cm,yshift=-1cm]plant.center)  {\sc $\mat{A}$};
      \coordinate (aeast) at ([xshift=1cm]A);
      \coordinate (awest) at ([xshift=-1.8cm]A);
    }   
        
   \& complexnode/.pic={ 
     \node[rectangle,dashed,draw,minimum width=3.5cm,minimum height=1.6cm,label=\textbf{ADC},] (adc) {};
     \draw[] ([xshift=-1cm]adc.center) -- ++(0.5,0.2cm);
     \coordinate (switch1) at ([xshift=-1cm]adc.center);
     \coordinate (switch2) at ([xshift=-0.4cm]adc.center);
     \node[circle,add={+}{+}{}{},fill=gray!20] (q1) at ([xshift=.6cm]adc.center) {};
     \node[draw=none] (q2t)  at ([yshift=.55cm]q1) {\sc Q1};
     \node[draw=none] (v1)  at ([yshift=-1.5cm]q1) {$\nu_1$};
     \node[draw=none] (y) at ([xshift=.85cm,yshift=.15cm]q1)  {$\vec{x}_k$};       
     \coordinate (ykeast) at ([xshift=1.9cm]q1);
     \coordinate (yksouth) at ([xshift=1.9cm,yshift=-3.5cm]q1);
   } 
   \& \coordinate (aux1);
   \& \\
  };

  \path[->] (v1) edge (q1.south);
  \path[->] (v2) edge (q2.south);
  \path[->] (r) edge (circle.west);
  \path[->] (circle.east) edge (q2.west);
  \path       (q2.east) edge (zoh.west);
  \path[->] (zoh.east) edge (B.west);
  \path
   (B.east) edge (p1.west)
   (p1.east) edge (int.west)
   (xsouth) edge (aeast)
   (aeast) edge (A.east)
   (A.west) edge (awest)
   (awest) edge (p1.south)
   (int.east) edge (switch1.west)
   (switch2) edge (q1.west);
  \path
   (q1.east) edge (ykeast)
   (ykeast) edge (yksouth)
   (yksouth) edge (kdsouth);
  \path[->]  (kdsouth) edge (Kd.south);
  \path (Kd.north) edge (circle.south);
 \end{tikzpicture}
}
 \caption{Closed-loop digital control system 
 \label{fig:digitalsystem}}
\end{figure*}


%-------------------------------
\subsection{Counterexample Guided Inductive Synthesis - CEGIS} 
\label{ssec:cegis}
%-------------------------------

\begin{figure*}
%\hspace{-2cm}
\centering
\resizebox{.57\textwidth}{!}{
 \begin{tikzpicture}[scale=0.3,->,>=stealth',shorten >=.2pt,auto,
 semithick, initial text=, ampersand replacement=\&,]

  \matrix[nodes={draw, fill=none, shape=rectangle, minimum height=.2cm, minimum width=.2cm, align=center
},
          row sep=1cm, column sep=3cm] {
   \node[fill=gray!20] (synth) {{\sc Synthesize}};
   \&
   \node[fill=gray!20] (verif) {{\sc Verify}};
   \&
   \node[ellipse,fill=gray!20] (done) {{\sc Done}}; 
    \\
  };

   \path
   ([yshift=2em]synth.east) edge node[align=center] {Candidate solution} ([yshift=2em]verif.west)
    ([yshift=-2em]verif.west) edge node[align=center] {Counter-example} ([yshift=-2em]synth.east)
    (verif) edge node {} (done);
 \end{tikzpicture}
}
 \caption{The CEGIS framework. \label{fig:CEGIS}}
\end{figure*}

In this section, we give a brief description of the CEGIS framework, as illustrated in Figure~\ref{fig:CEGIS}. [ADD REFERENCE(S).]

We consider an input specification of the form $\exists P .\, \forall a.\, \phi(a, P)$, 
where $P$ ranges over functions (where a function is represented by the program computing it),
$a$ ranges over ground terms, 
and $\phi$ is a quantifier-free formula. 
We~interpret the ground terms over some finite [CHECK: finite? are we doing only SAT or also SMT?] domain~$\mathcal{D}$. 
This is a synthesis problem, where the objective is indeed to select a valid $P$ satisfying $\phi$ over all the $a$ terms. 
CEGIS breaks down this generally hard synthesis problem into two easier parts. 

The design consists of two phases, an inductive synthesis phase (denoted by {\sc Synthesize} in
Figure~\ref{fig:CEGIS}) and a validation phase (denoted by {\sc
  Verify}), which interact via a finite set of tests {\sc
  inputs} that is updated incrementally.  Given the specification $\phi$, the inductive synthesis procedure tries to
find an existential witness $P$ satisfying the specification
$\phi(a, P)$ for all $a$ in {\sc inputs} (as opposed to all $a \in
\mathcal{D}$).
%
If the synthesis phase succeeds in finding a witness~$P$, this witness is a
candidate solution to the full synthesis formula.  We pass this candidate
solution to the validation phase, which checks whether it is a full solution
(i.e., $P$ satisfies the specification $\phi(a, P)$ for all
$a\in\mathcal{D}$).  If this is the case, then the algorithm terminates. 
Otherwise, additional information is provided to the inductive synthesis
phase in the form of a new counterexample that is added to the {\sc inputs}
set and the loop iterates again.  %% More details about the general
%% architecture of the synthesizer can be found
%% in~\cite{DBLP:conf/lpar/DavidKL15}.
[COMMENT ON TERMINATION?]

%-------------------------------
\section{Formal specification of control systems properties} 
\label{sec:specification}
%-------------------------------

While in the previous section we discussed the generic CEGIS
framework, in the rest of the paper we will explain how we adapt it to
the synthesis of digital controllers. For this purpose, we start by
describing the specific property that we pass to the synthesizer as
the specification $\phi$. Namely, we are interested in capturing
stability and safety, which we discuss in Sections~\ref{ssec:stabspecification}
and~\ref{ssec:safespecification}, respectively.

%-------------------------------
\subsection{Formal specification of stability} 
\label{ssec:stabspecification}
%-------------------------------


  There are a number of algorithms in our verification engine that can
  be used for stability analysis~\cite{daes20161, Bessa16}.
%one based on Schur's decomposition
%and another one based on Jury's criterion~\cite{astrom1997computer}.  
Here we choose Jury stability criterion~\cite{astrom1997computer} in view of its efficiency 
and ease of integration within our implementation: 
this method checks the stability working in the $z$-domain of the characteristic polynomial $S(z)$,  
%
% of the matrix $\left( \begin{array}{c} Y \\ U \end{array}\right)$, where $Y(z)$ is the closed-loop system output and U(z) is the controller output. 
%% \red{[unclear: what matrix? We need to clarify the relationship
%% between the char. poly. $S(z)$ and the later quantities $\Delta
%% N_{G}(z), \Delta D_{G}(z)$ and corresponding controller's
%% structure.]}.
%
considered in its general form as 
% for $S(z)$:
%
\begin{equation*}
S(z) = a_0z^N+a_1z^{N-1}+\cdots+a_{N-1}z+a_N=0, a_0\neq0. 
\end{equation*}
%\cdsay{is this for the matrix $\left( \begin{array}{c} Y \\ U \end{array}\right)$?} 
% Assuming that $\hat{G}(z) = \frac{\hat{N_G}(z)}{\hat{D_G}(z)}$
% and $\hat{C}(z) = \frac{\hat{N_C}(z)}{\hat{D_C}(z)}$, then:
% $$S(z) = FWL[N_C(z)] \times \hat{N_G}(z) + FWL[D_C(z)] \times \hat{D_G}(z)$$
The following matrix
$M = [m_{ij}]_{(2N-2)\times N}$ is built from $S(z)$ coefficients:
%
$$
M=\left( 
\begin{array}{c}
V^{(0)}\\
V^{(1)}\\
\vdots\\
V^{(N-2)}
\end{array}
\right), 
$$
%
where $V^{(k)} = [v^{(k)}_{ij} ]_{2\times N}$ such that:
%
$$
v_{ij}^{(0)}=\left\{
\begin{array}{ll}
a_{j-1}, & \mbox{if}~i=1\\
v_{(1)(N-j+1)}^{0},&\mbox{if}~i=2
\end{array}
\right.
$$
%
$$
v_{ij}^{(k)}=\left\{
\begin{array}{ll}
0,&\mbox{if}~j>n-k\\
v_{1j}^{(k-1)}-v_{2j}^{(k-1)} . \frac{v_{11}^{(k-1)}}{v_{21}^{(k-1)}}, & \mbox{if}~j\leq n-k ~\mbox{and}~i=1\\
v_{(1)(N-j+1)}^{k},& \mbox{if}~j\leq n-k ~\mbox{and}~i=2\\
\end{array}
\right.
$$
%
and where $k \in \mathbb{Z}$ is such that $0 < k < N - 2$. 
We have that $S(z)$ is the characteristic polynomial of a stable system if and only if the following four conditions hold~\cite{astrom1997computer}:
%\begin{itemize}
%\item 
$R_1: S(1) > 0$;
%\item 
$R_2: (−1)^N S(−1) > 0$;
%\item 
$R_3: |a_0| < a_N$;
%\item 
$R_4: m_{11} > 0 \wedge\allowbreak
      m_{31}>0 \wedge\allowbreak
      m_{51}>0 \wedge \ldots \wedge\allowbreak
      m_{(2N{-}3)(1)}>0$.
%\end{itemize}
%
The stability property is then encoded by a constraint of the form:
$
\phi_\mathit{stability} := (R_1 \wedge R_2 \wedge R_3 \wedge R_4).
$


%-------------------------------
\subsection{Formal specification of safety} 
\label{ssec:safespecification}
%-------------------------------

We are not limited to the synthesis of digital stabilizing controllers -- a
well known task in the literature on digital control systems -- but target
safety requirements with an overall approach that is sound and automated. 
%More specifically, we require that the closed-loop system meets given safety specifications.  
A safety specification translates to a requirement on the states of the closed-loop model, 
and the feedback controller (namely the choice of the gains matrix~$K$) 
must ensure that the state never violates the requirement.  
Note that a stable, closed-loop model is not necessarily a safe system: 
indeed, the state values may leave the safe part of the state space while they converge
to the equilibrium, which is typical in the case of oscillatory convergent dynamics. 
%However, a safe system will always be stable.  
In~this work, the safety property is expressed as:
%
\begin{equation}
\label{eq:safetyliteral}
\phi_\mathit{safety} := \forall k\ge 0.\, \bigwedge_{i=1}^{n}{\underline{x_{i}} \leq x_{i,k} \leq \overline{x_{i}}},
\end{equation}
%
%\addtodo{We consider $x_{i}^{-}$ and $x_{i}^{+}$ to be -1 and 1, respectively.}
%
where $\underline{x_{i}}$ and $\overline{x_{i}}$ are lower and upper bounds
for the $i$-th coordinate $x_{i}$ of state $x\in \mathbb R^n$ at the $k$-th
instant, respectively.  This means that the states will always be within an $n$-dimensional hyper-box.

Furthermore, it is practically relevant to consider constraints $\phi_\mathit{input}$ on the input
signal $u_{k}$ and requirements $\phi_\mathit{init}$ on the initial states $x_0$, 
both of which we be expressed via given bounds as: 
$\phi_\mathit{input} := {\forall k.\underline{u} \leq u_{k} \leq \overline{u}} $, 
and $\phi_\mathit{init} := \bigwedge_{i=1}^{n} \underline{x_{i,0}} \leq x_{i,0} \leq \overline{x_{i,0}}$. 
For the input signal, these requirements practically mean that the control input saturates in view of physical constraints. 

%-------------------------------
\subsection{Abstract Acceleration of Linear Dynamics} 
\label{ssec:aa}
%-------------------------------
 
We recall a recently introduced technique called \emph{Abstract Acceleration}~\cite{JSS14,cattaruzza2015unbounded}, 
which will be key in this work for abstraction-based synthesis.  
%\note{This clashes with the model introduced above, with inputs - motivate why? I've added the motivation above by introducing the closed  loop}
Given a model of an iterative program with dynamics
%
\begin{equation}
\vec{x}_{k+1}=\mat{A_d}\vec{x}_k \text{ where } \vec{x}_k \in \mathbb{R}^p, \mat{A_d} \in \mathbb{R}^{p \times p} \text{ and } k \in \mathbb N_0,
\end{equation}
%
\textcolor{red}{[I have modified the notations with the `d' subscript as above.]}
we want to find all possible states visited over an infinite time horizon
starting at an initial set $X_0$.  
This set is known as the \emph{reach tube} of
the model:
%
\begin{equation}
\hat{X} = \{ \vec{x}_k: k \in \mathbb N_0, \vec{x}_0 \in X_0 \text{ and } \vec{x}_{k+1}=\mat{A_d}\vec{x}_k\}.
\end{equation}
%
Using Abstract Acceleration we transform this sequential reachability problem into a one-step problem.  
We first modify the problem statement by means of acceleration into
%
\begin{equation}
\hat{X} = \{ \vec{x}_k=\mat{A_d}^k\vec{x}_0 \mid k \in N_0 \text{ and } \vec{x}_0 \in X_0 \}, 
\end{equation}
%
and further define new model semantics and corresponding set: 
%
\begin{equation}\label{eq:aa_reachtube}
\hat{X} \subseteq \hat{X}^\sharp = \mathcal{A}X_0, \text{ such that } \bigcup_{k \in [0\ \infty)} \mat{A_d}^k \subseteq \mathcal{A}, 
\end{equation}
%
where the newly introduced \emph{abstract reach tube} $\hat{X}^\sharp$ is an
over-approximation of the reach tube of the model \cite{JSS14}.  
In this work we extend the abstract acceleration algorithm to continuous-time models. 
% and  For this reason we must first look at the acceleration of continuous-time dynamics.

%All we need to do is define the nature of $\mathcal{A}X_0$.
%Let $\mat{S}\mat{J}\mat{S}^{-1}=\mat{A}$ be the eigen-decomposition of
%$\mat{A}$, where $\mat{S}$ is the set of generalised eigenvectors of
%$\mat{A}$ and $\mat{J}$ is the Jordan Form containing the eigenvalues of
%$\mat{A}$ in its main diagonal.  We correspondingly define
%$\mathcal{J}=\mat{S}^{-1}\mathcal{A}\mat{S}$, which is such that
%$\mathcal{J} \supseteq \bigcup_{k \in [0\ \infty)} \mat{J}^k$.
%
%Since abstract acceleration operates in the eigenspace, wemust deal with some preliminary transformations.
%Given a set $X=\{ \vec{x} \mid \mat{C}\vec{x} \leq \vec{d}\}$,
%the linear transformation $\vec{x}'=\mat{S}^{-1}\vec{x}$ leads to the set 
%%
%\begin{equation}
%X'= \mat{S}^{-1}X = \{\vec{x}' \mid \mat{C}\mat{S}\vec{x}'\leq \vec{d}\}.  
%\label{eq:eigenInit}
%\end{equation}
%%
%Analogously, let $X_0'=\mat{S}^{-1}X_0$ and
%${\hat{X}'^\sharp}=\mat{S}^{-1}{\hat{X}^\sharp}$ be the initial set and the
%abstract reach tube mapped onto the eigenspace of matrix $\mat{A}$.  We may
%transform equation \eqref{eq:aa_reachtube} into: 
%%
%\begin{equation}
%\hat{X}' \subseteq {\hat{X}'^\sharp} = \mathcal{J}X_0', 
%\end{equation}
%%
%where $\hat{X}'=\mat{S}^{-1}\hat{X}$ and $\mathcal{J}$ is a convex
%polyhedron representing restrictions on the eigenvalues of $\mat{A}$. 
%$\hat{X}'^\sharp$ is calculated by applying a simplex algorithm with a
%tableau defined by $\mathcal{J}$ and objective functions derived from each
%vertex of $X_0'$ (step \eqref{alg:getReachTube} in Algorithm
%\ref{alg:findReachTube} below).  We note, however, that if we wish to use
%numerical analysis in the decomposition of $\mat{A}$, the Tableau in
%$\mathcal{J}$ contains small intervals given by the errors, which cannot be
%processed efficiently by a regular simplex and require a new procedure.
%
%The calculation of the abstract reach tube via abstract acceleration is
%encompassed in Algorithm~\ref{alg:findReachTube}, which can be summarised as
%follows (its steps are denoted in parentheses):
%%
%\begin{enumerate}
%%
%\item We perform unsound eigen-decomposition using an existing algebra package (lines \ref{alg:calcEigenvalues}-\ref{alg:calcEigenvectors}).
%%
%\item Then we restore soundness to the results using the methods described in \cite{cattaruzza2017sound} (lines \ref{alg:soundEigenvalues}-\ref{alg:soundEigenvectors}).
%%
%\item The inverse of the matrix of eigenvectors is calculated after soundness is restored, using interval arithmetic in order to ensure its soundness (line \ref{alg:inverse}).
%%
%\item The abstract dynamics are obtained by evaluating the convex hull of all powers of eigenvalues up to the desired number of iterations as described in \cite{cattaruzza2015unbounded} (line \ref{alg:aa}). 
%%
%\item Using Equation \eqref{eq:eigenInit}, transform the initial state into the eigenspace (line \ref{alg:eigeninit}).
%%
%\item Extract the vertices of the eigen-polyhedron $X_0'$ using the algorithms described in \cite{cattaruzza2015unbounded,cattaruzza2017sound} (line \ref{alg:getVertices}). 
%%
%\item Calculate the mapped \emph{abstract reach tube} ${\hat{X}'^\sharp}$
%that over-approximates the image of the reach tube in the eigenspace (line
%\ref{alg:getReachTube}).  This is achieved by evaluating a set of objective
%functions using the abstract dynamics as a simplex Tableau, and via a sound
%simplex described in \cite{cattaruzza2017sound}.  The objective functions are
%defined by the vertices of $X'_0$, denote as $V_0$, and by the desired
%template directions, such that
%%
%\begin{equation*}
%\vec{w}_{ij}= \vec{v}_i \circ \vec{t}_j \text{ with } \vec{v}_i \in V_0 \text{ and } \vec{t}_j \in T,
%\end{equation*}
%%
%where $T$ is the set of template directions, and $\circ$ denotes a
%component-wise multiplication yielding a vector.
%%
%\item Using Equation~\eqref{eq:eigenInit}, find the reach tube
%$\hat{X}^\sharp=\mat{S}{\hat{X}'^\sharp}$ (line \ref{alg:getNormReachTube}).
%%
%\end{enumerate}
%
%\begin{algorithm}[]
%\small
%\begin{algorithmic}[1]
%\Function{$\mathit{findAbstractReachTube}()$}{}
%\State $\hat{\mat{J}}=$ calculateEigenvalues($ \mat{A}$)
%\label{alg:calcEigenvalues}
%\State $\hat{\mat{S}}=$ calculateEigenvectors($ \mat{A}$)
%\label{alg:calcEigenvectors}
%\State $[\mat{J}]=$ soundifyEigenvalues($\mat{A},\mat{J},\mat{S}$)
%\label{alg:soundEigenvalues}
%\State $[\mat{S}]=$ soundifyEigenvectors($\mat{A},[\mat{J}],\mat{S}$)
%\label{alg:soundEigenvectors}
%\State $[\mat{S}]^{-1}=$ calculateInverse($[\mat{S}]$)
%\label{alg:inverse}
%\State $\mathcal{J}=getAbstractDynamics([\mat{J}])$
%\label{alg:aa}
%\State $[X_0']=$ transformInitialSpace($X_0,\mat{S}$)
%\label{alg:eigeninit}
%\State $[V_0]=$ getVertices($[X_0']$)
%\label{alg:getVertices}
%\State ${\hat{X}'^\sharp}=$ getReachTube($\mathcal{J},[V_0]$)
%\label{alg:getReachTube}
%\State ${\hat{X}^\sharp}=$ transformReachTube(${\hat{X}'^\sharp},[\mat{S}]^{-1}$)
%\label{alg:getNormReachTube}
%\EndFunction
%\end{algorithmic}
%\caption{Calculation of Abstract Reach Tube Using Abstract Acceleration}
%\label{alg:findReachTube}
%\end{algorithm}

%%-------------------------------
%\subsection{Overapproximating continuous time dynamics using discrete models}
%\label{sec:cont_aa}
%%-------------------------------
%
%Thus far we wave discussed the Abstract Accelertion of Discrete Time
%systems.  However, our plant models derive from the discretization of
%continuous time systems.  We therefore seek to establish a sound
%overapproximation which does not only encompass the selected discretization,
%but any chosen discretization in the time domain.
%
%A dynamical system is a system in which a function describes the progression
%of a state over time.  In a continuous domain with linear dynamics, it is
%described by a first order Ordinary Differential Equation (ODE).
%%
%\begin{equation}
%\dot{x}(t)=\mat{A}_o\vec{x}(t)+\mat{B}_o\vec{u}(t)
%\label{eq:dynamical}
%\end{equation}
%%
%Furthermore, a control system may have a derived
%output that is a linear combination of its states and inputs, which may
%restricts the observability of the statespace from the output space.
%%
%\begin{equation}
%\vec{y}(t)=\mat{C}_o\vec{x}(t)+\mat{D}_o\vec{u}(t)
%\end{equation}
%%
%Discretization of a continuous dynamical system turns the ODE into a
%difference equation, assuming zero-order hold for the input $\vec{u}$, to
%%
%\begin{align}
%\label{eq:discretization}
%\vec{x}_{k+1} &= \mat{A}_d\vec{x}_k+\mat{B}_d\vec{u}_k\\
%y_k &= \mat{C}_d \vec{x}_ k + \mat{D}_d \vec{u}_ k 
%\end{align}
%where
%\begin{align}
%\label{eq:discretize}
%\mat{A}_d &= e^{\mat{A}_o T_s} = \mathcal{L}^{-1} { ( s \mat{I} - \mat{A}_o )^{-1} }_{t = T_s}\\
%\mat{B}_d &= \int_{t = 0}^{T_s} e^{\mat{A}_o t} dt\ \mat{B}_o = \mat{A}_o^{-1} ( \mat{A}_d - \mat{I} ) \mat{B}_o\\
%\mat{C}_d &= \mat{C}_o\\
%\mat{D}_d &= \mat{D}_o \\
%\end{align}
%and $T_s$ is the sample time. Then
%\begin{align*}
%x(kT)=x_k \wedge y(kT) = y_k, \forall k
%\end{align*}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsubsection{Acceleration of continuous-time models}
\label{sec:continuous_time_accel}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 

The time discretization in Sec.~\ref{sec:model} only allows us to evaluate
the state of the plant at integer multiples of the sample time.  
%\note{Unlike the CAV18 paper, these gain matrices have not been discussed yet. }
However, in order to synthesize $\mat{K}$, 
we must be able to ensure that given properties of the plant hold at any given point in time.  
In order to do so, we accelerate the dynamics of the plant according to the model
semantics in Sec.~\ref{sec:model} and compute the state
$\vec{x}_T$ at a given time $T$,
%
% namely we find an equation for $\tau^n(\vec{x},\vec{u})$ given $\tau(\vec{x},\vec{u})$. 
%
namely the state $\vec{x}(t)$ of the model 
%$\dot{\vec{x}}(t)=\mat{A}
at time $t=T$. 

\textcolor{red}{[The following three subsections take too much space, plus the results are mostly known or easily derivable with simple algebra: we need to shorten and simplify it. Dario: can you give it a crack?]}
\textcolor{blue}{[I merged the first two]}

%\note{ [add?] In this section we work with fully observed models, namely where $y = x$. } 
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsubsection{Accelerated\! dynamics\! for\! continuous-time\! models\! with\! parametric\! inputs}\label{sec:real_discrete_param_inputs}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
% 
Given a specific time $T$, the state $\vec{x}(t=T)$ can be expressed as a
linear function of $\vec{x}_0$ and $\vec{u}$ as shown below.  
 
\begin{lemma}
The solution to the differential equation $\dot{\vec{x}}(t)=\mat{A}\vec{x}(t)+\mat{B}\vec{u}(t)$, where
$\forall t\geq 0.\,\vec{u}(t)=\vec{u}$, $\mat{A}=\mat{S}\mat{J}\mat{S}^{-1}$, and $\mat{S}$ are the generalized eigenvectors of $\mat{A}$,
evaluated at time $T$ is
%
\begin{align}
\label{eq:continuous_tube_param}
\vec{x}_T&=\vec{x}(t=T)=\mat{A}_T\vec{x}_0 + \mat{B}_T\vec{u}\\
 \mat{A}_{T}&= \mat{S}
 \left [ \begin{array}{cccc}
 e^{T\lambda_1}  & s_1\frac{T^{1}e^{T\lambda_i}}{(2)!} & \hdots  & s_i\frac{T^{p-1}e^{T\lambda_i}}{(p-i)!} \\
0 & e^{T\lambda_i}  & s_i\frac{T^{j-i}e^{T\lambda_i}}{(j-i)!} & \vdots \\
\vdots & & \ddots & \vdots \\
0 & \cdots & 0  &e^{T\lambda_i} \\
\end{array} \right ]
 \mat{S}^{-1}
 \label{eq:continuous_tube_dyn2}\\
 \mat{B}_T&=\mat{A}^{-1}(\mat{I}-\mat{A}_T)\mat{B}
 \footnote{When $\mat{A}$ is not invertible,
we use $\left[\begin{array}{cc}\mat{A}_T&\mat{B}_T\\
0&\mat{I}\end{array}\right]=e^{\left[\begin{array}{cc}\mat{A}&\mat{B}\\0&0\end{array}\right]}$.}\\
 &\text{where } s_i=\left\{\begin{array}{cc}1&\quad gm(\lambda_i)>1\\0&\quad gm(\lambda_i)=1\end{array}\right.,\nonumber
\end{align}
%
$\lambda_i$ are the eigenvalues of $\mat{A}$, and $gm(\lambda_i)$ is the geometric multiplicity of $\lambda_i$.
%

If $\mat{J}$ is diagonal and there exists a discrete dynamics matrix for a sampling time $T_d$ such that $A_d=e^{\mat{A} T_d}$, then 
$$\vec{x}_T=A_d^{\frac{T}{T_d}}\vec{x}_0+(\mat{I}-\mat{A}_d^{\frac{T}{T_d}})\mat{B}_d\vec{u}
\text{ with } T \in \mathbb{R}_0^+$$
where $\mat{A}_d^{\frac{T}{T_d}} =e^{log(\mat{A}_d) \frac{T}{T_d}} = e^{\mat{A} T}$,
is the state of the system at time $t=T$. 
\end{lemma}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsubsection{Accelerated dynamics for models with a sampled-time feedback}\label{sec:real_discrete_feedback_inputs}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

The final case we analyze is that of hybrid-time models, where the plant
dynamics evolve in continuous time while the feedback dynamics evolve in
discrete time.  A~new input value is produced only at every sample time but
implemented over the continuous-time plant dynamics.
%
%\note{Matrix K has not been introduced yet. }
\begin{theorem}
The expression
%
 \begin{align}
 \vec{x}_{T} &= (\mat{A}_{T-kT_s}-\mat{B}_{T-kT_s}\mat{K}) (\mat{A}_d-\mat{B}_d\mat{K})^k\vec{x}_0, 
 \label{eq:cyber_feedback}
 \end{align}
%
with $\mat{A}_T$ as in \eqref{eq:continuous_tube_dyn2}, $\mat{B}_T$ as in
\eqref{eq:continuous_tube_param}, and where $\mat{A}_d=\mat{A}_{T_s}$,
$\mat{B}_d=\mat{B}_{T_s}$ describe the discretized plant dynamics with
sample time $T_s$, is the state of the model
%
\begin{align*}
 \dot{\vec{x}}(t) = \mat{A}\vec{x}(t)+\mat{B}\vec{u}(t), \quad 
 \vec{u}(t)=\mat{K}\vec{x}_k,  \,
 kT_s \leq t < (k+1)T_s \,. 
\end{align*}
%
\end{theorem}
\begin{proof}
%
Let $\mat{K}$ be a feedback controller such that
$\vec{u}_k=-\mat{K}\vec{x}_k$ at time $t=kT_s$.  Let the output of the
feedback system be a zero order holder such that
$\vec{u}(t'+kT_s)=\vec{u}(kT_s), \text{ for } 0 \leq t' < T_s$.  The closed
loop dynamics of the system between times $kT_s$ and $kT_s+T_s$ are
%
\begin{align*}
\vec{x}_{k,t'}=\mat{A}_{t'}\vec{x}_k-\mat{B}_{t'}\mat{K}\vec{x}_k = (\mat{A}_{t'}-\mat{B}_{t'}\mat{K})\vec{x}_k,
\end{align*}
where $0 \leq t' < T_s$
We further explore the dynamics across discrete time boundaries. Let $\mat{A}_d=\mat{A}_{T_s}$ and $\mat{B}_d=\mat{B}_{T_s}$
\begin{align*}
\vec{x}_{k}&=\vec{x}_{k-1,T_s}= (\mat{A}_d-\mat{B}_d\mat{K})\vec{x}_{k-1}\\
\vec{x}_{k,T_s} &= (\mat{A}_d-\mat{B}_d\mat{K}) (\mat{A}_d-\mat{B}_d\mat{K})\vec{x}_{k-1}
\end{align*}
which accelerating results and setting $T=kT_s+t'$ becomes
\begin{align}
\label{eq:feedback_sampled_cont}
\vec{x}_{k} &= (\mat{A}_d-\mat{B}_d\mat{K}) ^k\vec{x}_0\\
\vec{x}_{T} &= (\mat{A}_{T-kT_s}-\mat{B}_{T-kT_s}\mat{K}) (\mat{A}_d-\mat{B}_d\mat{K})^k\vec{x}_0
\label{eq:feedback_cont}
\end{align}
\end{proof}

%-------------------------------
 \subsubsection{Finding Abstract Supports for Continuous Dynamics}
 \label{sec:cont_aasup}
%-------------------------------

\textcolor{red}{[This paragraph is highly unclear - Dario: can you please update it?]}
\textcolor{blue}{[is  this better?]}

Just as the accelerated dynamics in equation \eqref{eq:feedback_sampled_cont} can be abstacted using \eqref{eq:aa_reachtube} (where $\bigcup_{k \in N_0} (\mat{A}_d-\mat{B}_d\mat{K}) ^k \subseteq \mathcal{A}$),
we use the same principle on equation \eqref{eq:feedback_cont} to obtain 
\begin{equation}\label{eq:aa_cont_amatrix}
\bigcup_{T \in [0, T_s], k \in N_0} (\mat{A}_{T-kT_s}-\mat{B}_{T-kT_s}\mat{K}) (\mat{A}_d-\mat{B}_d\mat{K})^k \subseteq \mathcal{A}.
\end{equation}

We describe now how to obtain such a set. Abstract acceleration works by finding support functions of the set that encompasses the matrices $\mat{A}^k$.
Support functions are scalars that measure the distance of a hyperplane tangent to the set boundary to the origin.
In the case of continuous spaces, this translates to calculating the derivatives of the envelope in order to find the direction of the support vector (normal to the hyperplane), and calculating the distance to the corresponding point where the hyperplane touches the set (at which the derivative was calculated).
The direction of the vector is determined by evaluating the support function of another point in the curve,
which is known to be smaller than that of the selected point, and the chosen hyperplanes are aligned with the eigenvectors, hence we only look at eigenvalue pairs to calculate the derivatives~\cite{cattaruzza2015unbounded}.
The corresponding derivatives are:
%
\begin{enumerate}
%
\item for real eigenvalues: we first calculate the slope of the tangent
between the two progressions: $\frac{d f(k)}{d g(k)}=\frac{f'(k)}{g'(k)}$. 
Hence $\frac{d \lambda_1^k}{d \lambda_2^k}=\frac{log(\lambda_1)
\lambda_1^k}{log(\lambda_2) \lambda_2^k}$.  From this we know that the polar
angle of the support vector is $\psi = \tan^{-1}(\frac{log(\lambda_1)
\lambda_1^k}{log(\lambda_2) \lambda_2^k})+\frac{\pi}{2}$
%
\item for conjugate eigenvalue pairs: the pair forms a logarithmic spiral. 
The tangent of a spiral with polar equation $r=a e^{b\theta}$ will have a
derivative $\frac{d r}{d \theta}=b a e^{b\theta}=b r$, hence the angle of
the vector normal to the curve is $\tan^{-1}(\frac{r}{\frac{d r}{d
\theta}})+\frac{\pi}{2}=\tan^{-1}(\frac{1}{b})+\frac{\pi}{2}$
%
\item for Jordan blocks with $gm>1$: in the case of real eigenvalues, we
follow the same procedure as in the real case, but considering that the
equation for each eigenvalue is $\frac{k^j}{j!}e^{\lambda k}$ where $j$ is
the index of the term within the Jordan block (note that when $j=0$ the term
is the same as for real eigenvalues above).  The derivatives f'(k),g'(k) are
in the form $(j+k*log(\lambda))\frac{k^{j-1}}{j!}e^{\lambda k}$.
%
\item for any combination of complex eigenvalues we use the above equations
using the envelope of their magnitude (ie $|\lambda|$).
%
\end{enumerate}

%%-------------------------------
%\subsection{State-space representation of physical systems} 
%\label{ssec:ssrepresentation}
%%-------------------------------
%
%We consider models of physical plants expressed as ordinary differential
%equations (ODEs), which we assume to be controllable and under full state
%information (i.e., we have access to all the model variables):
%%
%\begin{align}
%\label{eq:ode}
%\dot{x}(t) = Ax(t)+ B u(t), \quad x \in \mathbb{R}^{n}, u \in \mathbb{R}^m, \\ \nonumber A \in \mathbb{R}^{n \times n}, B \in \mathbb{R}^{n \times m}, 
%\end{align}
%%
%where $t \in \mathbb R_0^+$, where $A$ and $B$ are matrices that fully
%specify the continuous plant, and with initial states set as $x(0)$.  While
%ideally we intend to work on the continuous-time plant, in this work
%Eq.~\eqref{eq:ode} is soundly discretized in time~\cite{fadali} into
%%
%\begin{align}
%\label{eq:plant}
%x_{k+1} = A_d x_k+ B_d u_k
%\end{align} 
%%
%where $k \in \mathbb N$ and $x_{0}=x(0)$ is the initial state. 
%$A_d$ and $B_d$ denote the matrices that describe the discretized plant dynamics, whereas
%$A$ and $B$ denote the continuous plant dynamics.  
%We synthesize for requirements over this discrete-time domain. 
%Later, we will address the issue of variable quantization, 
%as introduced by the ADC/DAC conversion blocks 
%(\textcolor{red}{we should include a figure that describes the control system model that we tackle}).
%
%
%
%%-------------------------------
%\subsection{Controller synthesis via state feedback}
%\label{ssec:statefeedbackcontrol}
%%-------------------------------
%
%Models \eqref{eq:ode} and \eqref{eq:plant} depend on external non-determinism in the form of input signals $u (t)$ and  $u_k$, respectively. 
%Feedback architectures can be employed to manipulate the properties and behaviors of the continuous process (the plant).   
%We are interested in the synthesis of digital feedback control algorithms, 
%as implemented on Field-Programmable Gate Arrays or Digital Signal Processors. 
%The most basic feedback architecture is the state feedback one, 
%where the control action $u_k$ (notice we work with the discretized signal) is computed by: 
%%
%\begin{equation}
%\label{eq:controlaction}
%u_k = r_{k} - K x_k. 
%\end{equation}
%%
%Here, $K \in \mathbb{R}^{m \times n}$ is a state-feedback gain matrix, 
%and $r_{k}$ is a reference signal (again digital).   
%%
%The closed-loop model then takes the form 
%\begin{align}
%\label{eq:closedloopss}
%x_{k+1} = ( A_d - B_d K ) x_k + B_d r_k.
%\end{align}
%%
%The gain matrix $K$ can be set so that the closed-loop discrete dynamics are
%shaped as desired, for instance according to a specific stability goal or
%around a specific dynamical behavior \cite{astrom1997computer}.  As argued
%later in this work, we will target more complex objectives, such as
%quantitative safety requirements, which are not typical in the digital
%control literature.  Further, we will embrace the digital nature of the
%controller, which manipulates quantized signals as discrete quantities represented with finite precision. 
%
%%-------------------------------
%\subsection{Stability of closed-loop systems}
%\label{ssec:stability}
%%-------------------------------
%
%In this work we employ asymptotic stability in the CEGIS loop,  
%as an objective for guessing controllers that are later proven sound over safety requirements.  
%Asymptotic stability is a property that amounts to convergence of the model executions to an equilibrium point, 
%starting from any states in a neighborhood of the point (see Figure~\ref{fig:ct} for the portrait of a stable execution, converging to the origin).  
%In the case of linear systems as in~\eqref{eq:closedloopss}, 
%considered with a zero reference signal, 
%the equilibrium point of interest is the origin. 
%
%A discrete-time LTI system as \eqref{eq:closedloopss} is asymptotically
%stable if all the roots of its characteristic polynomial (i.e., the
%eigenvalues of the closed-loop matrix $A_d - B_d K$) are inside the unity
%circle of the complex plane, i.e., their absolute values are strictly less than
%one~\cite{astrom1997computer} (this simple sufficient condition can be generalised, 
%however this is not necessary in our work).  
%In this paper, we express this stability specification $\phi_\mathit{stability}$ in terms of a check known as
%\emph{Jury's criterion}~\cite{fadali}: this is an easy algebraic formula to
%select the entries of matrix $K$ so that the closed-loop dynamics are shaped
%as desired.
%
%%-------------------------------
%\subsection{Safety specifications for dynamical systems}
%\label{ssec:safety}
%%-------------------------------
%
%We are not limited to the synthesis of digital stabilizing controllers -- a
%well known task in the literature on digital control systems -- but target
%safety requirements with an overall approach that is sound and automated. 
%More specifically, we require that the closed-loop system
%\eqref{eq:closedloopss} meets given safety specifications.  A safety
%specification gives raise to a requirement on the states of the model, such
%that the feedback controller (namely the choice of the gains matrix~$K$)
%must ensure that the state never violates the requirement.  Note that a
%stable, closed-loop system is not necessarily a safe system: indeed, the
%state values may leave the safe part of the state space while they converge
%to the equilibrium, which is typical in the case of oscillatory dynamics. 
%In~this work, the safety property is expressed as:
%%
%\begin{equation}
%\label{eq:safetyliteral}
%\phi_\mathit{safety}\iff \forall k\ge 0.\, \bigwedge_{i=1}^{n}{\underline{x_{i}} \leq x_{i,k} \leq \overline{x_{i}}},
%\end{equation}
%where $\underline{x_{i}}$ and $\overline{x_{i}}$ are lower and upper bounds
%for the $i$-th coordinate $x_{i}$ of state $x\in \mathbb R^n$ at the $k$-th
%instant, respectively.  This means that the states will always be within an $n$-dimensional hyper-box.
%
%Furthermore, it is practically relevant to consider the 
%constraints $\phi_\mathit{input}$ on the input
%signal $u_{k}$ and $\phi_\mathit{init}$ on the initial states $x_0$,
%which we assume have given bounds:
%$\phi_\mathit{input} = {\forall k.\underline{u} \leq u_{k} \leq \overline{u}} $, 
%$\phi_\mathit{init} = \bigwedge_{i=1}^{n} \underline{x_{i,0}} \leq x_{i,0} \leq \overline{x_{i,0}}.$
%For the former, this means that the control input might saturates in view of
%physical constraints.
%
%%-------------------------------
%\subsection{Performance specifications for dynamical systems}
%\label{ssec:performance}
%%-------------------------------
%
%\textcolor{red}{we should describe here about the performance specifications for dynamical systems.}

%-------------------------------
\section{CEGIS of digital controllers} 
\label{sssec:cegisdig}
%-------------------------------

In this section we discuss two instantiations of CEGIS: the first,
na\"ive one, relies on an unfolding of the dynamics up to a
completeness threshold, while the second one is abstraction-based and
leverages abstraction refinement and acceleration to improve
scalability while retaining soundness.

%-------------------------------
\subsection{Na\"ive approach} 
\label{sssec:naive}
%-------------------------------

\textcolor{red}{[Elizabeth: please rewrite this]} 

\begin{figure*}[htb]
\scriptsize\centering
\begin{tikzpicture}[scale=0.3,->,>=stealth',shorten >=.2pt,auto, semithick, initial text=, ampersand replacement=\&,]
  \matrix[nodes={draw, fill=none, shape=rectangle, minimum height=.2cm, minimum width=.2cm, align=center},
          row sep=.6cm, column sep=.9cm] {
   \coordinate (aux1);
   \& \coordinate (aux2);
   \&;\\
   \coordinate (aux3);
   \& \coordinate (aux4);
   \&;\\
   \coordinate (aux5);
   \& \coordinate (aux6);
   \&;\\
   \node[minimum width=1.5cm, minimum height=0.6cm, fill=gray!20] (synth) {{\sc 1.Synthesize}};
   \&
   complexnode/.pic={ 
     \node[rectangle,draw,dotted,
	minimum width=6cm,
	minimum height=1cm,
        pattern=north west lines, pattern color=gray!20,
	label={\sc ~~~~~~~~~~~~Verify},] (verif) {};
     \node[minimum width=1cm, minimum height=0.6cm, fill=gray!20] (verif1) at ([xshift=-2cm]verif.center) {{\sc 2.Safety}};
     \node[minimum width=1cm, minimum height=0.6cm, fill=gray!20] (verif2) at ([xshift=0cm]verif.center) {{\sc 3.Precision}};
     \node[minimum width=1cm, minimum height=0.6cm, fill=gray!20] (verif3) at ([xshift=2cm]verif.center) {{\sc 4.Complete}};
     %\node[minimum width=1cm, minimum height=0.6cm, fill=gray!20] (verif4) at ([xshift=3.1cm]verif.center) {{\sc 5.Sampling}};
   } 
   \& \node[ellipse, fill=gray!20] (done) {{\sc Done}};\\
   \& \\
   \node[minimum height=0cm] (gp) {\sf Program Search};
   \&
   complexnode/.pic={ 
     \coordinate (aux);
   \node (bmc) at ([xshift=-2cm]aux.center) {\sf BMC-based \\ \sf Verifier};
   \node (fp)  at ([xshift=0cm]aux.center) {\sf Fixed-point \\ \sf Arithmetic\\ \sf Verifier};
   \node (sv)  at ([xshift=2cm]aux.center) {\sf Completeness\\ \sf Verifier};
   %\node (cv)  at ([xshift=3.1cm]aux.center) {\sf Sampling\\Verifier};
   }   
    \\
  };

   \path
    ([yshift=2em]synth.east) edge node[xshift=-0.5em,align=center] {$K$} ([yshift=2em]verif1.west)
    ([yshift=-2em]verif1.west) edge node {C-ex} ([yshift=-2em]synth.east)
    ([xshift=-5em]fp.north) edge node[align=center]  {T/F} ([xshift=-5em]verif2.south)
    ([xshift=-5em]sv.north) edge node[align=center]  {T/F} ([xshift=-5em]verif3.south)
    %([xshift=-5em]cv.north) edge node[align=center]  {T/F} ([xshift=-5em]verif4.south)
    ([xshift=5em]verif1.south) edge node[align=center] {$K$} ([xshift=5em]bmc.north)
    ([xshift=5em]verif2.south) edge node[align=center] {$K$} ([xshift=5em]fp.north)
    ([xshift=5em]verif3.south) edge node[align=center] {$K$} ([xshift=5em]sv.north)
    %([xshift=5em]verif4.south) edge node[align=center] {$K$} ([xshift=5em]cv.north)
    ([xshift=-5em]bmc.north) edge node[align=center]  {UNSAT/\\model} ([xshift=-5em]verif1.south)
    (verif) edge node {PASS} (done)
    ([xshift=5em]synth.south) edge node[align=center] {Inputs} ([xshift=5em]gp.north)
    ([xshift=-5em]gp.north) edge node[align=center] {UNSAT/\\$K$} ([xshift=-5em]synth.south)
    (aux3) edge (synth.north);
   \path[-]
   (verif2.north) edge node[align=center] {} ([xshift=0cm]aux6)
   ([xshift=0cm]aux6) edge node[align=center] {Increase Precision} (aux5)
   (verif3.north) edge node[align=center] {} ([xshift=6.7cm]aux4)
   ([xshift=6.7cm]aux4) edge node[align=center] {Increase Unfolding Bound} (aux3);
   %(verif4.north) edge node[align=center] {} ([xshift=10.5cm]aux2)
   %([xshift=10.5cm]aux2) edge node[align=center] {Increase Sampling Rate} (aux1);
\end{tikzpicture}
\caption{CEGIS with multi-staged verification}
\label{fig:CEGIS-precision-increment}
\end{figure*}

%\subsubsection{Controller synthesis}

An overview of the algorithm for controller synthesis is given in
Fig.~\ref{fig:CEGIS-precision-increment}.  One important observation is that
we verify and synthesize a controller over $k$ time steps.  We~then compute
a completeness threshold $\overline{k}$~\cite{DBLP:conf/vmcai/KroeningS03}
for this controller, and verify correctness for $\overline{k}$ time steps. 
Essentially, $\overline{k}$ is the number of iterations required to
sufficiently unwind the closed-loop state-space system, 
which ensures that the boundaries are not violated for any other $k{>}\overline{k}$.

%\begin{theorem} There exists a finite $\overline{k}$ such that it is
%sufficient to unwind the closed-loop state-space system up to $\overline{k}$
%in order to ensure that $\phi_\mathit{safety}$ holds. 
%\end{theorem}
%
%\begin{proof}
%%
%A stable control system is known to have converging dynamics.  Assume the
%closed-loop matrix eigenvalues are not repeated (which is sensible to do,
%since we select them).  The distance of the trajectory from the reference
%point (origin) decreases over time within subspaces related to real-valued
%eigenvalues; however, this is not the case in general when dealing with
%complex eigenvalues.  Consider the closed-loop matrix that updates the
%states in every discrete time step, and select the eigenvalue $\vartheta$
%with the smallest (non-trivial) imaginary value.  Between every pair of
%consecutive time steps $k\,T_s$ and $(k+1)\,T_s$, the dynamics projected on
%the corresponding eigenspace rotate $\vartheta T_s$ radians.  Thus, taking
%$\overline{k}$ as the ceiling of $\frac{2\pi}{\vartheta T_s}$, after
%$k{\geq}\overline{k}$ steps we have completed a full rotation, which results
%in a point closer to the origin.  The synthesized $\overline{k}$ is the completeness threshold.
%\qed 
%%
%\end{proof}
%
%\medskip

Next, we describe the different phases in Fig.~\ref{fig:CEGIS-precision-increment}
(blocks 1 to 4) in detail.

%\todo{please eventually itemize next}
\begin{enumerate}

\item The inductive synthesis phase ({\sc synthesize}) uses BMC to compute a
candidate solution $K$ that satisfies both the stability criteria and the
safety specification.  To synthesize a controller that satisfies the
stability criteria, we require that a computed polynomial satisfies Jury's
criterion~\cite{fadali}.  The details of this calculation can be found in
the Appendix.

Regarding the second requirement, we synthesize a safe controller by
unfolding the transition system $k$ steps and by picking a controller $K$
and a single initial state, such that the states at each step do not violate
the safety criteria.  That is, we ask the bounded model checker if there
exists a $K$ that is safe for at least one $x_0$ in our set of all possible
initial states.  This is sound if the current $k$ is greater than the completeness
threshold.  We~also assume some precision $\langle I_p,F_p\rangle$ for the
plant and a sampling rate.  The checks that these assumptions hold are
performed by subsequent {\sc verify} stages.

%\begin{algorithm}[]
%\scriptsize
%\begin{algorithmic}[1]
%\Function{$stabilityCheck()$}{}
%  \State computecharPoly($A_d - B_dK$)
%  \State assert(Jury's criteria hold)
  %\State Return $K$
%\EndFunction
%\end{algorithmic}
%\label{alg:stabilitycheck}
%\end{algorithm}


\begin{algorithm}[]
%\scriptsize
\begin{algorithmic}[1]
\Function{$\mathit{safetyCheck}()$}{}
\State assert($ \underline{u}  \leq u \leq \overline{u}$)
 \State set $x_0$ to be a vertex state, e.g., $[\underline{x_0},\underline{x_0}]$	
\For {($c=0;~c < 2^\mathit{Num\_States};~c\mbox{++}$)}
  %\State assert($ \underline{x_0}  \leq x_0 \leq \overline{x_0}$)
	\For{($i=0;~i< k;~i\mbox{++}$)}
		%\State $u = (\langle I_p,F_p\rangle)((\langle I_c,F_c\rangle)K * (\langle I_c,F_c\rangle) x)$
		\State $u = (plant\_typet)((controller\_typet)K * (controller\_typet) x)$
		\State $x = A * x + B * u$
		\State assert($\underline{x} \leq x \leq \overline{x}$ )
  	\EndFor
  	\State set $x_0$ to be a new vertex state
  	\EndFor
  %\State Return $K$
\EndFunction
\end{algorithmic}
\caption{Safety check\label{alg:safetycheck}}
\end{algorithm}

\item The first {\sc verify} stage, {\sc safety}, checks that the candidate
solution $K$, which we synthesized to be safe for at least one initial
state, is safe for \emph{all} possible initial states, i.e., does not reach
an unsafe state within $k$ steps where we assume $k$ to be under the
completeness threshold.  After unfolding the transition system corresponding
to the previously synthesized controller $k$ steps, we check that the safety
specification holds for any initial state. This is shown in Alg.~~\ref{alg:safetycheck}.

\item The second {\sc verify} stage, {\sc precision}, 
 restores soundness with respect to the plant's precision
by using interval arithmetic \cite{moore1966interval} to validate the 
operations performed by the previous stage. 

\item The third {\sc verify} stage, {\sc complete}, checks that the current
$k$ is large enough to ensure safety for any $k'{>}k$.  Here, we compute the
completeness threshold $\overline{k}$ for the current candidate controller $K$ and
check that $k{\geq}\overline{k}$.  This is done according to the argument
given above and illustrated in Fig.~\ref{fig:ct}.

\end{enumerate}

\begin{figure}[t]
\centering
\includegraphics[width=\columnwidth]{figures/ct.eps}
%\vspace{0.1cm}
\caption{Completeness threshold for multi-staged verification. $T_s$ is the time step for the time discretization of the control matrices.}
\label{fig:ct}
\end{figure}

Checking that the safety specification holds for any initial state can be
computationally expensive if the bounds on the allowed initial states are
large.

%-------------------------------
\subsection{Abstraction-based CEGIS} 
\label{sssec:abstraction}
%-------------------------------

\textcolor{red}{[Dario: once Elizabeth has updated the description of the naive approach, can you update the following part, aligning it with hers?]}

%  The na\"ive approach described in Sec.~\ref{sec:CEGIS-precision-incrementation}
  %uses a multi-staged verification phase and performs solution generalization based on
%the plant precision, the number of loop unrollings, 
  %and the sampling rate. Essentially, it
%  synthesizes a controller for an individual initial state
%and input with a bounded time horizon and, subsequently, it generalizes it to all reachable states,
%inputs, and time horizons during the verification phase.

Essentially, this approach relies on the symbolic simulation over a bounded
time horizon of individual initial states and inputs that form part of an
uncountable space and tries to generalize it for an infinite space over an
infinite time horizon.

  %% solution over all times by refining the number of witnesses.  
  %% In order to perform the safety check, this approach uses abstract acceleration
  %% \cite{cattaruzza2015unbounded} to compute the controller's set of states. 
  %% \todo{clarify: what is the ``set of states'' of the controller? }
%\end{itemize}

%% The verification of a hybrid continuous/discrete system over an
%% unbounded time, requires the non-deterministic simulation of an
%% infinite set of states, which is undecidable.


%% Our na\"ive approach
%% creates an abstraction of the system by establishing bounds on the
%% error between such a system and a discrete-time/continuous-space
%% model.  This model is still however, quite complex, hard to verify,
%% and many of the states involved are inconsequential to the safety
%% specification.

Conversely, in this section, we find a controller for a continuous initial
set of states and set of inputs, over an abstraction of the continuous
dynamics \cite{cattaruzza2015unbounded} that conforms to witness proofs at
specific times.  %% It further generalizes the
Moreover, this approach uses abstraction refinement enabling us to always
start with a very simple description regardless of the complexity of the
overall dynamics, and only expand to more complex models when a solution
cannot be found.

The CEGIS loop for this approach is illustrated in Fig.~\ref{fig:CEGARIS}.

% Now that we have explained the verification process, we may proceed to describe the synthesis procedure, which is illustrated in figure \ref{fig:CEGARIS}.
% Our model, rather than look at a bisimulation \todo{specific notion that has not been formally define - do not use} in discrete time, explores a much higher abstraction, 
% evaluating the unbounded time-continuous space reach tube as a set of inequalities that represent only the safety specification.
% We have also identified 
% the quantization noise as a bounded non-deterministic input.


\begin{enumerate}
\item 
  We start by doing some preprocessing:%%  that 
  %% can be computationally intensive and we don't want it to be part of the CEGIS loop.
% Let us recall the formulas used for single-input and single-output (SISO) systems 
  % in sections \ref{sec:reachable} and \ref{sec:observable}.
  \begin{enumerate}
\item Compute the characteristic polynomial of the matrix $(A_d-B_dK)$ as 
$P_a(z) = z^n+\sum_{i=1}^n{(a_i-k_i)z^{n-i}}$. 
%\blue{[shouldn't there be a b term in the polynomial's coefficients here? No. the polynomial only evaluates the poles]}
%%   A controllable system with quantization will have the following dynamics, where
%% we use underscript ``n'' to denote a noise term,
%% ``cf'' to denote Controllable Canonical Form,
%% $\nu_1$, $\nu_2$ are quantization errors
%% caused by the ADC and DAC conversions, respectively, 
%% and $\nu_3$ is the round-off error.
%% \todo{Why do we use $_t$ here?}
%% %
%% \begin{align}
%% \label{eq:observer_LTI_cf}
%% x_{k+1}=&\mat{A}_{t}x_k+\mat{B}_{t} r_k+\mat{B}_{n} (\nu_1 + \nu_2 + \nu_3)
%% \end{align}
%% \begin{align*}
%% \mat{A}_{t}=&\mat{T}\mat{A}_d\mat{T}^{-1}&
%% \mat{B}_{t}=&\mat{T}\mat{B}_d&
%% \mat{B}_{n}=&[1 \cdots 1]^T&
%% \mat{T}=&\mat{W}_{cf}\mat{W}^{-1}&
%% \end{align*}

%% \begin{align*}
%% \mat{A}_{t}=\mat{T}\mat{A}_d\mat{T}^{-1}=&\left[
%% \begin{array}{ccccc}
%% 0&1&0&\cdots&0\\
%% 0&0&1&\cdots&0\\
%% \vdots&\vdots&\vdots&\ddots&\vdots\\
%% 0&0&0&\cdots&1\\
%% k_n-a_n&k_{n-1}-a_{n-1}&k_{n-2}-a_{n-2}&\cdots&k_1-a_1
%% \end{array}\right]
%% \label{eq:cf_SISO_2}
%% \end{align*}


%% \begin{enumerate}
%% \item Calculate $\mat{T}$ as $\mat{W}_{cf}\mat{W}^{-1}$. %using equations \eqref{eq:rncf}\eqref{eq:rcf}\eqref{eq:to_cf}
%% \item Extract the characteristic polynomial of the above matrix:
%% %
%\begin{align*}
%$P_a = z^n+\sum_{i=1}^p{(a_i-k_i)z^{n-i}}$
%\end{align*}

\item Calculate the noise set $N$ from the quantizer resolutions and estimated round-off errors: %($\frac{q_1}{2},\frac{q_2}{2},q_3$)
%
\begin{equation}
\nonumber
\begin{split}
N=\left \{ \nu_1+\nu_2+ \nu_3 \mid \nu_1 \in \left[-\frac{q_1}{2}\ \ \frac{q_1}{2}\right] 
\wedge \right. \\ \left. \nu_2 \in \left[-\frac{q_2}{2}\ \ \frac{q_2}{2}\right]  \wedge  \nu_3 \in \left[-q_3\ \ q_3\right]  \right \}
\end{split}
\end{equation}

%
where  $q_1$ is the error introduced by the truncation in the ADC, $q_2$ is
the error introduced by the DAC and $q_3$ is the maximum truncation and
rounding error in $u_k=-K \cdot \mathcal{F}_{\langle I_c,F_c \rangle}(x_k)$ as
discussed in Section~\ref{sec:numeric_rep}. % More details on how to model
%quantization as noise are given in
%Appendix~\ref{appendix:quantization-noise}.

\item Calculate a set of initial bounds on $K$, $\phi_\mathit{init}^{K}$,
based on the input constraints %\blue{[how is this practically done?With the equation below]}.  
%
$$(\phi_\mathit{init} \wedge \phi_\mathit{input} \wedge u_k=-K x_k)
\Rightarrow \phi_\mathit{init}^{K}$$
Note that these bounds will be used by the {\sc synthesize} phase to reduce the size of the solution space. 

\end{enumerate}
\item In the {\sc synthesize} phase, we synthesize a candidate controller
%We begin with a minimum set of linear inequalities describing the constraints caused by the input and the initial state during a single iteration, in addition to a stability 
% specification defined by Jury's 
%criteria. %, and try to synthesise a controller that meets these specs.
% For a stabilized closed-loop, which is necessary for our safety property, we need
% these roots to remain within the unit circle, which we verify using Jury's criteria.
% Notice that in our polynomials $c_0=1$ and we only use reals.
% Once we have established convergence, we may examine the 
% safety specification $\phi_\mathit{safety}$.
  $K \in \mathbb{R}\langle I_c,F_c\rangle^n$ that satisfies
  $\phi_\mathit{stability} \wedge \phi_\mathit{safety} \wedge \phi_\mathit{init}^{K}$ by invoking a SAT solver.
%%   We obtain it by solving the SAT formula 
%% $$\mathcal{J}_K=\mathcal{J}\langle I,F \rangle (P_{a-k},\mat{T})\wedge \phi_\mathit{safety}$$ 
%% that satisfies the input constraint and Jury's criteria for 
%% $P_{a-k}=z^n+\sum_{i=1}^n (a_i-k_i) z^{n-i} : k_i \in \mat{K} \wedge \tilde{\mat{K}}=\mat{K}\mat{T}$,
%% where $\mathcal{J}\langle I,F \rangle (P,\mat{T})$ is a program describing Jury's method.
If there is no candidate solution we return UNSAT and exit the loop.
\item Once we have a candidate solution, we perform a safety verification % If this step fails, we find a counterexample iteration and initial state and create a new constraint to refine our abstraction.
  %
  of the 
  %consisting of evaluating the
  progression of the system from $\phi_\mathit{init}$ over time,
$x_{k} \models \phi_\mathit{safety}$. %\blue{why $k+1$ here?}. %% For this purpose we require 
%% an initial set $\phi_\mathit{init}= x_0 \in [\underline{x_0} \ \overline{x_0}]$ 
%% from which the system progresses.
% Obviously, this set $x_0$ 
% must satisfy the specification; otherwise, the system will be unsafe to begin with.
% We accept a specification in the form $\mat{E}\mat{T}x_0<\mat{f}$. 
% The presence of $\mat{T}$ is because this will typically be given in the original 
% state-space.
%% Next, we use abstract acceleration to get a second abstraction that 
  %% encompasses the accelerated continuous reach-tube over an unbounded time.
  In order to compute the progression of point $x_0$ at iteration $k$,
  we accelerate the dynamics of the closed-loop system and obtain:
  %we take the
  %the closed-loop model:
  %$x_{k+1}=\mat{A}_{t}x_k+\mat{B}_{n} (\nu_1 + \nu_2 + \nu_3)$
  %and accelerate it to:
%
{
\scriptsize
\begin{equation}
%\begin{split}
x=(A_d-B_dK)^kx_0+ \sum_{i=0}^{k-1} (A_d-B_dK)^i B_{n}(\nu_1+\nu_2+\nu_3)% 
%\end{split}
\end{equation}
\begin{equation}
B_n= [1 \cdots 1]^T
\end{equation}
}
%\label{eq:acc_observer_LTI_cf}
%+\sum_{i=0}^{k-1} \mat{A}_t^i \mat{B}_{t} r_i

%
As this still requires us to verify the system for every $k$ up to infinity,
we use abstract acceleration again to obtain the reach-tube, i.e., the set
of all reachable states at all times given an initial set
$\phi_\mathit{init}$:
%
\begin{align}
\label{eq:aa_observer_LTI_cf}
\hat{X}^\#
=\mathcal{A} X_0 + \mathcal{B}_{n} N, \quad
X_0 =\left \{x \mid x \models \phi_\mathit{init} \right\}, 
\end{align}
%
where $\mathcal{A}=\bigcup_{k=1}^\infty (A_d-B_dK)^k,
\mathcal{B}_{n}=\bigcup_{k=1}^\infty \sum_{i=0}^k(A_d-B_dK)^iB_{n}$ are
abstract matrices for the closed-loop system~\cite{cattaruzza2015unbounded},
whereas the set $N$ is non-deterministically chosen.

We next evaluate $\hat{X}^\# \models \phi_\mathit{safety}$.  If the
verification holds we have a solution, and exit the loop.  Otherwise, we
find a counterexample iteration $k$ and corresponding initial point $x_0$
for which the property does not hold, which we use to locally refine the
abstraction.  When the abstraction cannot be further refined, we provide
them to the {\sc abstract} phase.
%
%\todo{we should have a better argument here.}
%\end{enumerate} 
\item If we reach the {\sc abstract} phase, it means that the candidate solution is not valid,
  in which case we must refine the abstraction used by the synthesizer.
\begin{enumerate}
\item Find the constraints that invalidate the property
 as a set of counterexamples for the eigenvalues, which we define as $\phi_\Lambda$. This is a constraint in the spectrum i.e., transfer function) of the closed loop dynamics. 
\item We use $\phi_\Lambda$ to
  further constrain the characteristic polynomial %\blue{[again, check the coefficients of the characteristic polynomial.]I don't find any error} 
$z^n+\sum_{i=1}^n(a_i-k_i)z^{n-i}=\prod_{i=1}^n (z-\lambda_i) \text{ where } |\lambda_i|<1 \wedge \lambda_i \models \phi_{\Lambda}$. These constraints correspond to specific iterations for which the system may be unsafe.
\item Pass the refined abstraction $\phi(K)$ with the new constraints and the list of iterations $k$ to the {\sc synthesize} phase.
  %, as well as a counterexample plant coefficients ($P_a$) and repeat the loop again. 
\end{enumerate} 
\end{enumerate}


\begin{figure*}
\centering\scriptsize
\begin{tikzpicture}[scale=0.3,->,>=stealth',shorten >=.2pt,auto, semithick, ampersand replacement=\&,]
  \matrix[nodes={draw, fill=none, shape=rectangle, minimum height=.2cm, minimum width=.2cm, align=center},row sep=.8cm, column sep=.2cm] {
   \coordinate (aux1);
   \& \coordinate (aux2);
   \& ;\\
   \&\node[fill=gray!20,align=center,xshift=-1.5cm] (pre) {{\sc 1. pre-}\\{\sc processing}};
   \& \node[fill=gray!20,align=center] (abstract) {\sc 4. abstract};
   \& \coordinate (aux); \\ 
   \&
   \& \node[fill=gray!20,align=center] (synth) {\sc 2. synthesize};
   \& \node[fill=gray!20,align=center, minimum width=4cm] (verify) {\sc 3. verify ($\phi$)};
      \node[draw=none] (SAT) at ([xshift=2.7cm,yshift=-.3cm]verify)  {\sc PASS};
   \& \node[ellipse, fill=gray!20] (done) {{\sc Done}};\\
   \&
   \& \node[draw,rectangle,align=center] (KSAT) {Program \\ Search};
   \& complexnode/.pic={
     \coordinate (AA);
     \node[draw,rectangle,align=center] (AAV) at ([xshift=-1.5cm]AA.center) {Abstract\\Acceleration};
     \node[draw,rectangle,align=center] (AAC) at ([xshift=1.5cm]AA.center) {Abstraction \\ Verifier};
    }\\
  };
  \path
    (pre.east) edge node[align=center] {$P_a$, $N$,\\ $\phi_\mathit{init}^k$} (abstract.west)
    (abstract.south) edge node{$(\phi(K), k)$} (synth.north)
    ([yshift=1em]synth.east) edge node {$K$} ([yshift=1em]verify.west)
    (aux) edge (abstract.east) 
    (verify.east) edge (done.west);
  \path
    ([xshift=+.6cm]KSAT.north) edge[left] node[xshift=-.3cm] {$K$} ([xshift=0.6cm]synth.south) 
    ([xshift=-.6cm]synth.south) edge node[align=center,xshift=.3cm] {$(\phi(K),k)$} ([xshift=-.6cm]KSAT.north)
    ([yshift=.5cm]AAV.east) edge node{\sl $\hat{X}^\#$} ([yshift=.5cm]AAC.west)
    ([yshift=-.5cm]AAC.west) edge node{$(k,x_0)$} ([yshift=-.5cm]AAV.east)
    (AAC.north) edge node{\sl $\hat{X}^\#$} ([xshift=4.9cm]verify.south)
    ([xshift=-5cm]verify.south) edge node{$K$} (AAV.north);
  \path[-] 
     (verify.north) edge node {$(k,x_0)$} (aux);
\end{tikzpicture}
\caption{Abstraction-based CEGIS}
\label{fig:CEGARIS} 
\end{figure*} 


%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\section{Numerical representation and soundness} 
\label{sec:numeric_rep}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\textcolor{red}{Elizabeth: this section needs to be updated to describe floating-point arithmetics.}

The models we consider have two sources of error that are due to numerical representations.  
The first is the numerical error introduced by the
fixed-point numbers employed to model the plant, i.e., to represent the
plant dynamics $A_d$, $B_d$ and $x_k$.  The second is the quantization error
introduced by the digital controller, which performs operations on
fixed-point numbers.  
\textcolor{red}{[what about the DAC/ADC errors?]}
In this section we outline the notation for the
fixed-point representation of numbers, and briefly describe the errors
introduced.  A~formal discussion is in
%Appendix~\ref{appendix:numerical_errors}.

Let $\mathcal{F}_{\langle I,F \rangle}(x)$ denote a real number $x$
represented in a fixed point domain, with $I$ bits representing the integer
part and $F$ bits representing the decimal part.  The smallest number that
can be represented in this domain is $c_m=2^{-F}$.  Any mathematical
operations performed at the precision $\mathcal{F}_{\langle I,F \rangle}(x)$
will introduce errors, for which an upper bound can be
given~\cite{DBLP:conf/arith/BrainTRW15}.

We will use $\mathcal{F}_{\langle I_c,F_c \rangle}(x)$ to denote a real
number $x$ represented at the fixed-point precision of the controller, and
$\mathcal{F}_{\langle I_p,F_p \rangle}(x)$ to denote a real number $x$
represented at the fixed-point precision of the plant model ($I_c$ and $F_c$
are determined by the controller.  We pick $I_p$ and $F_p$ for our synthesis
such that $I_p \geq I_c$ and $\allowbreak F_p \geq F_c$).  Thus any
mathematical operations in our modelled digital controller will be in the
range of $\mathcal{F}_{\langle I_c,F_c \rangle}$, and all other calculations
in our model will be carried out in the range of $\mathcal{F}_{\langle
I_p,F_p \rangle}$.  The physical plant operates in the reals, which means
our verification phase must also account for the numerical error and
quantization errors caused by representing the physical plant at the finite
precision $\mathcal{F}_{\langle I_p,F_p \rangle}$.


\subsection{Effect on safety specification and stability}

Let us first consider the effect of the quantization errors on safety. 
Within the controller, state values are manipulated at low precision,
alongside the vector multiplication $Kx$.
The inputs are computed using the following equation: 
%
\begin{align*}
u_{k}&=-(\mathcal{F}_{\langle I_c,F_c \rangle}(K)\cdot\mathcal{F}_{\langle I_c,F_c \rangle}(x_{k})). 
\end{align*}

This induces two types of the errors detailed above: first, the truncation
error due to representing $x_k$ as $\mathcal{F}{\langle I_c,F_c
\rangle}(x_{k})$; and second, the rounding error introduced by the
multiplication operation.  We represent these errors as non-deterministic
additive noise.

An additional error is due to the representation of the plant dynamics, namely 
%
{\scriptsize
\begin{equation}
x_{k+1} =\mathcal{F}_{\langle I_p,F_p \rangle}(A_d) \mathcal{F}_{\langle I_p,F_p \rangle}(x_{k}) + \mathcal{F}_{\langle I_p,F_p \rangle}(B_d)\mathcal{F}_{\langle I_p,F_p \rangle}(u_{k}).
\end{equation}
}
We address this error by use of interval
arithmetic~\cite{moore1966interval} in the verification phase.

Previous studies~\cite{gangli1} show that the FWL affects the poles and
zeros positions, degrading the closed-loop dynamics, causing steady-state
errors and eventually de-stabilizing the system~\cite{Bessa16}.  However,
since in this paper we require stability only as a precursor to safety, it
is sufficient to check that the (perturbed, noisy) model converges to a
neighborhood of the equilibrium within the safe set.

In the following, we shall disregard these steady-state errors (caused by
FWL effects) when stability is ensured by synthesis, and then verify its
safety accounting for the finite-precision errors.


%-------------------------------
%\subsection{Formal specification of transient response} 
%\label{ssec:transientspecification}
%-------------------------------

%In a SISO system, there are 2 values that typically define the response-time of the system (using a step response).
%\begin{enumerate}
%\item The \emph{rise time} is defined as the time it takes the output to reach a percentage (eg $90\%$) of the target value given a step chnage in the input.
%\item The \emph{settling time} is defined as the time it takes the output to stabilize within a margin of the target value (eg $10\%$).
%\end{enumerate} 
%In the case of first and second order systems (with ), the decay is governed by the equations 
%\begin{align*}
%&y_{decay}=
%&\left\{
%\begin{array}{cc}
%e^{-|\omega| t}& 1^{st} order\\
%e^{\zeta |\omega| t}\left(\frac{\sin\left(|\omega| t\sqrt{1-\zeta^2}+\sin^{-1}\sqrt{1-\zeta^2}\right)}{\sqrt{1-\zeta^2}} \right)&\zeta<1\\
%e^{-|\omega| t}-|\omega| t e^{-|\omega| t}&\zeta=1\\
%\frac{|\omega| e^{-|\omega_2| t}-|\omega_2| e^{-|\omega| t}}{|\omega|-|\omega_2|}&\zeta>1\end{array}\right.
%\end{align*}
%where $|\omega|$ and $|\omega_2|$ are the magnitudes of the eigenvalues (roots) of the system and  $\zeta=-\cos(\theta)$ where $\theta$ is the polar angle of the conjugate pair if it exists ($\zeta \geq 1$ if it doesn't).
%These equations become increasingly complicated for higher order systems. However, we note their strong dependency on the magnitude of the eigenvalues, and use this property to define an upperbound on the decay function.
%All of the above equations will decay faster than $e^{-|\omega| t}$ given $|\omega| < |\omega_2|$, hence we may use this function as our upper bound.
%\begin{theorem}
%Given a set of eigenvalues for a discrete time model of an $n^{th}$ order system $\lambda_i =e^{\omega_i}: i \in [1\ n]$, the settling time of the system is upperbounded by
%\begin{equation}
%t_s<-log_{|\overline{\lambda}|}({p_s}) : |\overline{\lambda}| =\max(|\lambda_i|) \wedge |\overline{\lambda}|<1,\ \forall i \in [1\ n]
%\label{eq:set_time}
%\end{equation}
%where $0\leq p_s \leq 1$ is the desired percentage of the target within to remain after $t_s$.
%\end{theorem} 
%\begin{proof}
%Given a closed loop single output LTI system of order $n$ with dynamics
%\begin{equation}
%\left\{\begin{array}{c}\vec{x}_k=\mat{A}\vec{x}_{k-1}\\ \vec{y}_k=\mat{C}\vec{x}_k\end{array}\right. \Rightarrow \left\{ \begin{array}{c}\vec{x}_k'=\mat{J}\vec{x}_{k-1}'\\ \vec{y}_k=\mat{C}\mat{S}\vec{x}_k'\end{array}\right. : \left\{ \begin{array}{c}\mat{A}=\mat{S}\mat{J}\mat{S}^{-1} \\ \vec{x}_k'=\mat{S}^{-1}\vec{x}_k\end{array}\right.
%\label{eq:eigendynamics}
%\end{equation}
%
%the output decay is a linear combination of the decay of eigenvalues or
%eigenvalue pairs.  
%Let $\mat{C}'\in \mathbb{R}^{1 \times n}=\mat{C}\mat{S}$. Since $\mat{C}'$ is constant, the output $y_k$ is a linear combination of the states $\vec{x}'_k$. We accelerate equation \eqref{eq:eigendynamics} to obtain
%\begin{align}
%y_k&=\mat{C}'\mat{J}^k\vec{x}_0 = \sum_{i=0}^n \left( c_i \lambda_i^k + c_{il}\binom{k}{l} \lambda_i^{k-l}\right)\\
%|y_k|&\leq \sum_{i=0}^n \left|c_i + c_{il}\binom{k}{l} \lambda_i^{-l}\right||\lambda_i^k|
%\end{align}
%where the second  part of the equation corresponds to the upper diagonal terms of the Jordan blocks. We also have $|\lambda_i^k|\leq |\overline{\omega}^k|$,hence
%\begin{align}
%|y_k|&\leq |\overline{\omega}^k|\sum_{i=0}^n \left|c_i + c_{il}\binom{k}{l} \lambda_i^{-l}\right|
%\end{align}
%Since we are synthesising the eigenvalues, rather than solve this formula for complex Jordan Shapes, we will restrict our synthesiser to provide solutions with distinct eigenvalues (which is by far the most common case). Therefore the right hand terms dissappear and we end up with
%\begin{align}
%|y_k|&\leq |\overline{\omega}^k|\sum_{i=0}^n |c_i|
%\end{align}

%Hence the overall decay of the system is always smaller
%than $p=e^{-|\overline{\omega}| t}$ where $0\leq p\leq 1$ is the remaining
%percentage of the decay expressed.  reversing we have
%$t=-\frac{ln(p)}{|\overline{\omega}|}=-\frac{ln(p)}{ln(|\overline{\lambda}|)}$. 
%replacing for $p_s$ , $t_s$, and $\overline{\lambda}$ we get equation
%\eqref{eq:set_time}
%
%\qed
%\end{proof}
%
%We may now use this limit to express a constraint in terms of the
%coefficients for our synthesis process.  Let
%
%\begin{equation}
%P=\prod_{i=0}^n (s-\lambda_i)=\sum_{j=0}^n c_js^j.
%\end{equation}
%
%We use Jury's criterion to limit $|\lambda_i| \leq 1$.  Let us now define a
%transformation $\lambda_i'=\frac{\lambda_i}{\overline{\lambda}}$.  We want
%to ensure $\lambda_i' \leq 1$ which can be done by applying Jury's criterion
%to $P'=\prod_{i=0}^n (s-\lambda_i')=\sum_{j=0}^n c_j's^j$ where $c_j'$ are
%unknown.  However, if we replace for $\lambda_i$, we obtain
%
%\begin{equation}
%P'=\prod_{i=0}^n (s-\lambda_i')=\prod_{i=0}^n \left(s-\frac{\lambda_i}{\overline{\lambda}}\right)=\sum_{j=0}^n \frac{c_j}{\overline{\lambda}^{n-j}}s^j
%\end{equation}
%
%where all members are known, we may now synthesise coefficients that ensure
%the eigenvalues are smaller than a desired magnitue, thus ensuring that the
%settling time is too.

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
%\section{Verification of a Controllable Observed System}\label{sec:cof_verification}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

%\begin{figure*}[htb]
%\centering

%\tikzset{add/.style n args={4}{
%    minimum width=6mm,
%    path picture={
%        \draw[circle] 
%            (path picture bounding box.south east) -- (path picture bounding box.north west)
%            (path picture bounding box.south west) -- (path picture bounding box.north east);
%        \node[draw=none] at ($(path picture bounding box.south)+(0,0.13)$)     {\small #1};
%        \node[draw=none] at ($(path picture bounding box.west)+(0.13,0)$)      {\small #2};
%        \node[draw=none] at ($(path picture bounding box.north)+(0,-0.13)$)    {\small #3};
%        \node[draw=none] at ($(path picture bounding box.east)+(-0.13,0)$)     {\small #4};
%        }
%    }
% }

%\resizebox{1.0\textwidth}{!}{
% \begin{tikzpicture}[scale=0.6,-,>=stealth',shorten >=.2pt,auto,
%     semithick, initial text=, ampersand replacement=\&,]

%  \matrix[nodes={draw, fill=none, shape=rectangle, minimum height=.2cm, minimum width=.2cm, align=center}, row sep=.6cm, column sep=.6cm] {
%    \node[draw=none] (r) {$r_k$};
%    \node[rectangle,draw,
%	minimum width=1cm,
%	minimum height=1cm,] (gain)at ([xshift=1.2cm]r) {\sc $k_r$};
    
%   \& \node[circle,add={-}{+}{}{}] (circle) {};
%   \node[draw=none] (ez) at ([xshift=1cm,yshift=.15cm]circle)  {$u_k$};
%   \node[rectangle,draw,minimum width=1cm,minimum height=1cm] (Kd) at ([xshift=0,yshift=-5.5cm]circle)  {\sc $\mat{K}_d$};
%   \coordinate (kdsouth) at ([yshift=-3cm]Kd);
      
   
%   \& complexnode/.pic={ 
%     \node[rectangle,dashed,draw,minimum width=3cm,minimum height=1.6cm,label=\textbf{DAC}] (dac) {};
%     \node[circle,add={+}{+}{}{},fill=gray!20] (q2) at ([xshift=-.65cm]dac.center) {};
%     \node[draw=none] (q2t)  at ([yshift=.55cm]q2) {{\sc Q2}};
%     \node[draw=none] (v2)  at ([yshift=-1.5cm]q2) {$\nu_2$};
%     \node[fill=gray!20] (zoh) at ([xshift=.65cm]dac.center) {\sc ZOH};
%   }   

%   \& complexnode/.pic={ 
%      \node[rectangle,dashed,draw,minimum width=8cm,minimum height=3.5cm,label=\textbf{Plant}] (plant)  at ([yshift=-.5cm]dac.center) {};
%      \node[rectangle,draw,minimum width=1cm,minimum height=1cm] (B) at ([xshift=-2.5cm,yshift=.5cm]plant.center)  {\sc $\mat{B}$};
%      \node[draw=none] (u) at ([xshift=-1cm,yshift=.15cm]B)  {$u(t)$};
%      \node[circle,add={+}{+}{}{}] (p1) at ([xshift=-1.3cm,yshift=.5cm]plant.center) {};
%      \node[draw=none] (xdot) at ([xshift=.85cm,yshift=.15cm]p1)  {$\dot{\vec{x}}(t)$};   
%      \node[rectangle,draw,minimum width=1cm] (int) at ([xshift=.5cm,yshift=.5cm]plant.center) {\sc $\int$};
%      \coordinate (xsouth) at ([xshift=1cm]int);
%      \node[draw=none] (x) at ([xshift=1cm,yshift=.15cm]int)  {$\vec{x}(t)$};   
%      \node[rectangle,draw,minimum width=1cm,minimum height=1cm] (C) at ([xshift=2.7cm,yshift=.5cm]plant.center)  {\sc $\mat{C}$};
%      \node[draw=none] (y) at ([xshift=1cm,yshift=.15cm]C)  {$\vec{y}(t)$};   
%      \node[rectangle,draw,minimum width=1cm,minimum height=1cm] (A) at ([xshift=.5cm,yshift=-1cm]plant.center)  {\sc $\mat{A}$};
%      \coordinate (aeast) at ([xshift=1cm]A);
%      \coordinate (awest) at ([xshift=-1.8cm]A);
%    }   
    
%   complexnode/.pic={ 
%      \node[rectangle,dashed,draw,minimum width=8cm,minimum height=5cm,label=\textbf{Observer}] (observer)  at ([yshift=-5cm]plant.center) {};
%      \node[rectangle,draw,minimum width=1cm,minimum height=1cm] (Bd) at ([xshift=-2.5cm]observer.center)  {\sc $\mat{B}_o$};
%      \node[draw=none] (ud) at ([xshift=-1cm,yshift=.15cm]Bd)  {$u_k$};
%      \node[circle,add={+}{+}{+}{}] (o1) at ([xshift=-1.3cm]observer.center) {};
%      \node[draw=none] (xd) at ([xshift=.85cm,yshift=.15cm]o1)  {$\hat{\vec{x}}_{k+1}$};   
%      \node[rectangle,draw,minimum width=1cm] (delay) at ([xshift=.5cm]observer.center) {\sc $z^{-1}$};
%      \coordinate (xdsouth) at ([xshift=1.3cm]delay);
%      \coordinate (fbsouth) at ([xshift=1.3cm,yshift=-3cm]delay);
%      \node[draw=none] (xdp) at ([xshift=1cm,yshift=.15cm]delay)  {$\hat{\vec{x}}_k$};   
%      \node[rectangle,draw,minimum width=1cm,minimum height=1cm] (Cd) at ([xshift=2.7cm]observer.center)  {\sc $\mat{C}_o$};
%      \node[draw=none] (y) at ([xshift=.4cm,yshift=.8cm]Cd)  {$\hat{\vec{y}}_k$};   
%      \node[rectangle,draw,minimum width=1cm,minimum height=1cm] (Ad) at ([xshift=.5cm,yshift=-1.5cm]observer.center)  {\sc $\mat{A}_o$};
%      \coordinate (adeast) at ([xshift=1.3cm]Ad);
%      \coordinate (adwest) at ([xshift=-1.8cm]Ad);
%      \node[circle,add={-}{}{}{+}] (o2) at ([xshift=2.7cm,yshift=1.5cm]observer.center) {};
%      \node[rectangle,draw,minimum width=1cm,minimum height=1cm] (Ld) at ([xshift=.5cm,yshift=1.5cm]observer.center)  {\sc $\mat{L}_d$};
%      \coordinate (ldwest) at ([xshift=-1.8cm]Ld);
%      \coordinate (bdwest) at ([xshift=-5.5cm]Bd);
%      \coordinate (uksouth) at ([xshift=-5.5cm,yshift=5.5cm]Bd);
%      \coordinate (o2east) at ([xshift=6.3cm]o2);
%    }   
    
%   \& complexnode/.pic={ 
%     \node[rectangle,dashed,draw,minimum width=3.5cm,minimum height=1.6cm,label=\textbf{ADC},] (adc) {};
%     \draw[] ([xshift=-1cm]adc.center) -- ++(0.5,0.2cm);
%     \coordinate (switch1) at ([xshift=-1cm]adc.center);
%     \coordinate (switch2) at ([xshift=-0.4cm]adc.center);
%     \node[circle,add={+}{+}{}{},fill=gray!20] (q1) at ([xshift=.6cm]adc.center) {};
%     \node[draw=none] (q2t)  at ([yshift=.55cm]q1) {\sc Q1};
%     \node[draw=none] (v1)  at ([yshift=-1.5cm]q1) {$\nu_1$};
%     \node[draw=none] (y) at ([xshift=.85cm,yshift=.15cm]q1)  {$\vec{y}_k$};       
%     \coordinate (ykeast) at ([xshift=1.9cm]q1);
%   } 
%   \& \coordinate (aux1);
%   \& \\
%  };

  %\path[->] (v1) edge (q1.south);
  %\path[->] (v2) edge (q2.south);
  %\path[->] (r) edge (gain.west);
  %\path[->] (gain.east) edge (circle.west);
  %\path[->] (circle.east) edge (q2.west);
  %\path       (q2.east) edge (zoh.west);
  %\path[->] (zoh.east) edge (B.west);
  %\path
  %(B.east) edge (p1.west)
  %(p1.east) edge (int.west)
%  (xsouth) edge (aeast)
%   (aeast) edge (A.east)
%   (A.west) edge (awest)
%   (awest) edge (p1.south)
%   (int.east) edge (C.west)
%   (C.east) edge (switch1.west)
%   (switch2) edge (q1.west);
%  \path
%   (q1.east) edge (ykeast)
%   (ykeast) edge (o2east);
%  \path       (uksouth) edge (bdwest);
%  \path[->] (bdwest) edge (Bd.west);
%  \path
%   (Bd.east) edge (o1.west)
%   (o1.east) edge (delay.west)
%   (xdsouth) edge (adeast)
%   (adeast) edge (Ad.east)
%   (Ad.west) edge (adwest)
%   (adwest) edge (o1.south)
%   (o2.west) edge (Ld.east)
%   (Ld.west) edge (ldwest)
%   (ldwest) edge (o1.north)
%   (delay.east) edge (Cd.west)
%   (Cd.north) edge (o2.south)
%   (o2east) edge (o2.east)
%   (xdsouth) edge (fbsouth)
 %  (fbsouth) edge (kdsouth);
%\path[->]  (kdsouth) edge (Kd.south);
%\path (Kd.north) edge (circle.south);
% \end{tikzpicture}
%}
 %\caption{Closed-loop digital control system with observer\label{fig:observersystem}}
%\end{figure*}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
%\subsection{Stability of an Observed System}\label{sec:cof_stability}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\comment{
Let us look at observer for a SISO systems as shown in figure \ref{fig:observersystem} where ideally $\mat{A}_o=\mat{A}_d$, $\mat{B}_o=\mat{B}_d$ and $\mat{C}_o=\mat{C}_d$ for a given time discretization.
A controllable and observable system will have the following dynamics:
\begin{align}
\tiny
\left [\begin{array}{c}\vec{x}\\ \hat{\vec{x}}_e \end{array}\right]_{k+1}
&\tiny=\left [\begin{array}{cc}\mat{A}_d-\mat{B}_d\mat{K}_d&\mat{B}_d\mat{K}_d\\ \mat{0}&\mat{A}_d-\mat{L}_d\mat{C}_d\end{array}\right]
\left [\begin{array}{c}\vec{x}\\ \hat{\vec{x}}_e \end{array}\right]_k\nonumber\\
&\tiny+\left [\begin{array}{c}\mat{B}_dk_r\\ \mat{0} \end{array}\right] \vec{r}_k
+\left [\begin{array}{cc}\mat{B}_dk_r&\mat{0}\\ \mat{0}&-\mat{L}_d\end{array}\right]\left [\begin{array}{c}\vec{\nu}_2\\ \vec{\nu}_1\end{array}\right]
\label{eq:observer_LTI}
\end{align}
In order for the system to be in canonical form, we must however perform a transformation. The challenge however is that we want the state space dynamics in
reachable form and the observer error dynamics in observable form. Let 
\begin{equation}
\left[\begin{array}{c}\vec{x}'\\ \hat{\vec{x}}_e'\end{array}\right]=
\left[\begin{array}{cc}\mat{T}_c & \mat{0}\\\mat{0} & \mat{T}_o\end{array}\right] 
\left[\begin{array}{c}\vec{x}\\ \hat{\vec{x}}_e\end{array}\right]
\end{equation}
We can transform equation \eqref{eq:observer_LTI} into the equivalent canonical form

\begin{align}
\left [\begin{array}{c}\vec{x}'\\ \hat{\vec{x}}_e' \end{array}\right]_{k+1}
=&\left [\begin{array}{cc}\mat{A}_{tp}&\mat{B}_{to}\\ \mat{0}&\mat{A}_{to}\end{array}\right]
\left [\begin{array}{c}\vec{x}'\\ \hat{\vec{x}}_e' \end{array}\right]_k
+\mat{B}_{tp} \vec{r}_k
+\mat{B}_{tn}\left [\begin{array}{c}\vec{\nu}_2\\ \vec{\nu}_1\end{array}\right]\nonumber\\
\vec{y}_k=&\mat{C}_{t}\vec{x}_k + \mat{D}_{d}\vec{u}_k
\label{eq:observer_LTI_cf}
\end{align}
\begin{align*}
\mat{A}_{tp}=&\mat{T}_c\left(\mat{A}_d-\mat{B}_d\mat{K}_d\right)\mat{T}_c^{-1}&
\mat{A}_{to}=&\mat{T}_o\left(\mat{A}_d-\mat{L}_d\mat{C}_d\right)\mat{T}_o^{-1}\\
\mat{A}_t=&\left [\begin{array}{cc}\mat{A}_{tp}&\mat{B}_{to}\\ \mat{0}&\mat{A}_{to}\end{array}\right]&
\mat{B}_{to}=&\mat{T}_c\mat{B}_d\mat{K}_d\mat{T}_o^{-1}\\
\mat{B}_{tp}=&\left[\begin{array}{c}\mat{T}_c\mat{B}_d\mat{k}_r\\\mat{0}\end{array}\right]&
\mat{B}_{tn}=&\left[\begin{array}{cc}\mat{T}_c\mat{B}_d\mat{k}_r&\mat{0}\\\mat{0}&-\mat{T}_o\mat{L}_d\end{array}\right]\\
\mat{T}_с=&\mat{R}_{cf}\mat{R}^{-1}&
\mat{T}_o=&\mat{W}_o^{-1}\mat{W}_{of}\\
\mat{L}_d=& \mat{T}_o^{-1}\left[ \begin{array}{c}p_1\\p_2\\p_n\end{array}\right]&
\mat{C}_t=&\mat{C}_d\mat{T}_c
\end{align*}

\begin{align*}
\mat{A}_{tp}=&\left[
\begin{array}{ccccc}
0&1&0&\cdots&0\\
0&0&1&\cdots&0\\
\vdots&\vdots&\vdots&\ddots&\vdots\\
0&0&0&\cdots&1\\
k_n-a_n&k_{n-1}-a_{n-1}&k_{n-2}-a_{n-2}&\cdots&k_1-a_1
\end{array}\right]
\label{eq:cf_SISO_2}
\end{align*}

Careful examination of these matrices reveals that because the $\mat{A}_t$ is upper block diagonal, the spectrum of $\mat{A}_t$ is equal to the union of the spectrum of $\mat{A}_{tp}$ and $\mat{A}_{to}$ which can be calculated separately. Additionally, these correspond to the roots of the polynomials
\begin{align*}
\left(z^n+\sum_{i=1}^p{(a_i-k_i)z^{n-i}}\right) \left(z^n+\sum_{i=1}^p{(p_i-a_i)z^{n-i}}\right)
\end{align*}

As stated in Section~\ref{ssec:stabspecification}, we use Jury's Criterion
to assert this specification.

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{Safety of an Observed System}\label{sec:cof_safety}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Now that we have established convergence, we may examine the safety
specification of the state space.  In the case of SISO systems, this is
given by a range of the input and a range of the output which are considered
safe ($\vec{u}_k \in [\underline{u}\ \ \overline{u}] \wedge \vec{y}_k \in
[\underline{y}\ \ \overline{y}]$).  Whilst there are other properties we may
include in the verification, we will solely focus on these for simplicity of
the explanation.  We will assume that we do not want saturation in our
system, hence the control loop has only one mode.  We have also identified
the quantization noise as a bounded non-deterministic input.  First we must
translate the safety specification into the statespace.  Replacing on the
second part of equation \eqref{eq:observer_LTI_cf} we obtain
%
\begin{equation}
\Psi := \underline{y}-\overline{\mat{B}\vec{u}}<\mat{C}_t\vec{x}_k<\overline{y}-\underline{\mat{B}\vec{u}}
\label{eq:of_bounds}
\end{equation}
Note that we use the bounds of the input after the transformation by $\mat{B}$ since the matrix may reverse the bounds. Equation \eqref{eq:of_bounds} can be solved using linear programming as it describes a polyhedral region in $\mathbb{R}^n$.
The second step is evaluating the progression of the system over time in order to calculate $\vec{x}_k$ to validte against this specification. For this step we require an initial set from which the system progresses. Obviously, this set $\vec{x}_0$ must satisfy the specification, otherwise the system will be unsafe to begin with.
We will accept a specification in the form $\mat{E}\mat{T}\vec{x}_0<\mat{f}$. The presence of $\mat{T}$ is because this will typically be given in the original state-space.
Accelerating \eqref{eq:observer_LTI_cf}, we obtain:
\begin{align}
\label{eq:acc_observer_LTI_cf}
\left [\begin{array}{c}\vec{x}\\ \hat{\vec{x}}_e \end{array}\right]_k
=&\mat{A}_t^k
\left [\begin{array}{c}\vec{x}\\ \hat{\vec{x}}_e \end{array}\right]_0
+\sum_{i=0}^{k-1} \mat{A}_t^i \mat{B}_{tp} \vec{r}_i
+\sum_{i=0}^{k-1} \mat{A}_t^i \mat{B}_{tn}\left [\begin{array}{c}\vec{\nu}_2\\ \vec{\nu}_1\end{array}\right] \nonumber\\
:&\left [\begin{array}{cc}\mat{E}\mat{T}&\mat{0}\end{array}\right] \left [\begin{array}{c}\vec{x}\\ \hat{\vec{x}}_e \end{array}\right]_0<\mat{f}
\end{align}
which would still require us to verify the system for every $k$ up to infinity. Instead we will use abstract acceleration~\cite{}, which translates the formula into
\begin{align}
\label{eq:aa_observer_LTI_cf}
\hat{X}^\#
=&\mathcal{A}_t X_0+\mathcal{B}_{tp} R + \mathcal{B}_{tn} N\\
X_0 =&\left \{ \left[\begin{array}{c}\vec{x}\\ \hat{\vec{x}}_e \end{array}\right] :
 \left [\begin{array}{cc}\mat{E}\mat{T}&\mat{0}\end{array}\right] \left [\begin{array}{c}\vec{x}\\ \hat{\vec{x}}_e \end{array}\right]_0<\mat{f} \right\}\nonumber\\
 R =&\{r : \mat{E}_r < \vec{f}_r \}\nonumber\\
 N=&\left \{ \left[\begin{array}{c}\vec{\nu}_2\\ \vec{\nu}_1\end{array}\right] : \nu_1 \in \left[-\frac{q1}{2}\ \ \frac{q1}{2}\right] \wedge \nu_2 \in \left[-\frac{q2}{2}\ \ \frac{q2}{2}\right]  \right \}\nonumber
\end{align}
%
where $\mathcal{A}_t=\bigcup_{k=1}^\infty \mat{A}^k,
\mathcal{B}_{tp}=\bigcup_{k=1}^\infty \sum_{i=0}^k\mat{A}^i\mat{B}_{tp},
\mathcal{B}_{tn}=\bigcup_{k=1}^\infty \sum_{i=0}^k\mat{A}^i\mat{B}_{tn}$ are
abstract matrices for the system in \eqref{eq:observer_LTI_cf}.  It is worth
noting that $r$ is a non-deterministic parametric input (\emph{ie} $\forall
k>0, r_{k+1} =r_k$) whereas the set N is composed of non-deterministic
variable inputs.

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{Stability of an Digitally Observed System}\label{sec:cof_fwl_stability}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Thus far we have presented a verification procedure for a continuous plant
in discretized time domain (\emph{ie} the range of the quatizers is still
$\mathbb{R}$.  The next step we must reaize is that the controller and the
observer exist in a digital program, hence their domain is
$\mathbb{R}\langle I,F,E\rangle$.  This has two separate effects on the
model.  If we recall equation \eqref{eq:to_of}, the matrices of the observer
and the controller are not necessarily those of the plant.  In fact we have
$\mat{A},\mat{B},\mat{C} \in \mathbb{R}^*$, $\mat{A}_o,\mat{B}_o,\mat{C}_o,
\mat{K}_d, \mat{L}_d \in \mathbb{R}\langle I,F,E\rangle^*$ Where $*$
represents the appropriate dimension for each matrix.  Unfortunately this
means that although combined matrices such as $\mat{A}_t$ are in the reals,
they suffer from the fixed word restrictions in their composing matrices.

When our observer is implemented using a finite precision controller, new
problems arise due to the FWL effects.  Let $\mat{A}_o$, $\mat{B}_o$ and
$\mat{C}_o$ be the dynamics represented in $\mathbb{R} \langle I , F, E
\rangle$, and $\mat{A}_e=\mat{A}_d-\mat{A}_o$,
$\mat{B}_e=\mat{B}_d-\mat{B}_o$, and $\mat{C}_e=\mat{C}_d-\mat{C}_o$ their
corresponding errors.  Equation \eqref{eq:observer_LTI_cf} will become
%
\begin{align}
\tiny
\left [\begin{array}{c}\vec{x}'\\ \hat{\vec{x}}_e' \end{array}\right]_{k+1}
=&\tiny \left [\begin{array}{cc}\mat{A}_{tp}+\mat{B}_{eo}&\mat{B}_{to}\\ \mat{A}_{eo}&\mat{A}_{to}\end{array}\right]
\left [\begin{array}{c}\vec{x}'\\ \hat{\vec{x}}_e' \end{array}\right]_k
+\mat{B}_{tp} \vec{r}_k
+\mat{B}_{tn}\left [\begin{array}{c}\vec{\nu}_2\\ \vec{\nu}_1\end{array}\right]\nonumber\\
\tiny\vec{y}_k=&\tiny\mat{C}_{t}\vec{x}_k + \mat{D}_{d}\vec{u}_k
\label{eq:observer_LTI_FWL_cf}
\end{align}
\begin{align*}
\mat{A}_{tp}=&\mat{T}_c\left(\mat{A}_d-\mat{B}_d\mat{K}_d\right)\mat{T}_c^{-1}&
\mat{A}_{to}=&\mat{T}_o\left(\mat{A}_o-\mat{L}_o\mat{C}_o\right)\mat{T}_o^{-1}\\
\mat{A}_t=&\left [\begin{array}{cc}\mat{A}_{tp}&\mat{B}_{to}\\ \mat{0}&\mat{A}_{to}\end{array}\right]&
\mat{B}_{to}=&\mat{T}_c\mat{B}_o\mat{K}_d\mat{T}_o^{-1}\\
\mat{B}_{tp}=&\left[\begin{array}{c}\mat{T}_c\mat{B}_o\mat{k}_r\\\mat{0}\end{array}\right]&
\mat{B}_{tn}=&\left[\begin{array}{cc}\mat{T}_c\mat{B}_o&\mat{0}\\\mat{0}&-\mat{T}_o\mat{L}_d\end{array}\right]\\
\mat{T}_с=&\mat{R}_{cf}\mat{R}^{-1}&
\mat{T}_o=&\mat{W}_o^{-1}\mat{W}_{of}\\
\mat{L}_d=& \mat{T}_o^{-1}\left[ \begin{array}{c}p_1\\p_2\\p_n\end{array}\right]&
\mat{A}_{eo}=&\mat{T}_o\left(\mat{A}_e-\mat{L}_o\mat{C}_e\right)\mat{T}_o^{-1}\\
\mat{B}_{eo}=&\mat{T}_c\mat{B}_e\mat{K}_d\mat{T}_o^{-1}&
\mat{C}_t=&\mat{C}_d\mat{T}_c
\end{align*}

The first effect of this new equation is that the matrix is no longer upper
diagonal.  We must therefore compensate for the errors introduced in order
to find a stable solution.  We can use Gershgoring disks to limit the error
in the expected eigenvalues.  Let $\delta_o=\max(|\mat{A}_{ei*}|_2)$
(\emph{i.e.} the largest row norm in $\mat{A}_e$) be the largest error bound
for any eigenvalue in $\mat{A}_e$.  Then $\forall i \in [1\ n],
|\lambda_{oi}-\hat{\lambda}_{oi}|<\delta_o$,where $\lambda_{oi}$ are the
true eigenvalues of the observer and $\hat{\lambda}_{oi}$ the eigenvalues of
the perturbed observer.  We note that in the case of stability we only care
about the error with respect to the unit circle, which is equivalent to
upper bounding the estimation of the largest eigenvalue.  Hence given a
desired upper value $\overline{\lambda}$, we apply Iurys criterion on the
polynomial.
%
\begin{equation}
P_o'=\sum_{j=0}^n c_j\overline{\lambda'}^{n-j}s^j : \overline{\lambda'}=(1+\delta_o)\overline{\lambda}
\end{equation}
%
In the case of the reachable eigenvalues, the procedure is the same except
that we obtain our bound $\delta_c=\max(|\mat{A}_{e*i}+\mat{B}_{e*i}|_2)$
(\emph{i.e.} the largest column norm in $[\mat{A}_e\ \mat{B}_e]^T$) and
apply Jury's Criterion over
%
\begin{equation}
P_r'=\sum_{j=0}^n c_j\overline{\lambda'}^{n-j}s^j : \overline{\lambda'}=(1+\delta_c)\overline{\lambda}
\end{equation}

As a final annotation, we remark that the safety specification must be
applied to the model described in this section, accounting for the
representation errors of the FWL domain.
}


%-------------------------------
\section{DSSynth: An Automated Digital Controller Synthesis Tool for Physical Plants}
\label{sec:dssynthtool}
%-------------------------------

\begin{figure*}[t]
\centering
\includegraphics[width=0.7\textwidth]{figures/synthesis-flow.pdf}
\caption{Phases of the controller synthesis}
\label{fig:synthesis-flow}
\end{figure*}

The proposed synthesis methodology for closed-loop digital control
systems is based on the Digital-System Synthesizer 
(DSSynth) tool~\cite{DBLP:conf/kbse/AbateBCCCDKKP17}, 
which can be split into two main stages as follows: manual and 
automated steps, as illustrated in Fig.~\ref{fig:synthesis-flow}. 

In Step~1, the user selects the closed-loop digital control
system representation, which can be a transfer function or a state-space model.  
In Step~2, the physical plant (e.g., in the form of Equation~\eqref{eq:ode1}) must be
given~\cite{astrom1997computer}.  Finally, in Step~3, the numerical
representation for the digital controller implementation must be set by the
user, i.e., the FWL format that defines the number of bits of the integer
and fractional parts when using fixed-point arithmetic or half- and single-precision 
when using floating-point arithmetic as well as the dynamic range inputs.  The input 
provided by the user is a specification of the physical plant.

After that, the automated synthesis process starts with Step~A, where the
\tool~translates the digital system specification into an ANSI-C program.  
In Step~B, our CEGIS engine is invoked to
synthesize the digital controller w.r.t.~the digital system specification. 
Finally, in Step~C, the synthesized digital controller is produced.  The
output generated by the \tool~is the synthesized digital controller
represented either in transfer function or state-space equation.  The
synthesis is considered to be \emph{successful} if a digital controller is
correctly synthesized w.r.t.~FWL effects; otherwise, if any parameter is
incorrectly defined in previous steps, or if there is no solution (no
controller) for the respective physical plant (given the implementation
requirements), then the synthesis is considered to have \emph{failed}.

Our CEGIS engine is implemented as an integrated module within the C bounded
model checker (CBMC)~\cite{ClarkeKL04}.  CBMC transforms the ANSI-C representation
of our closed-loop control system model into its internal representation (IR).  We
instrument this IR for each synthesis or verification scenario accordingly,
and use CBMC as an oracle to answer our queries.  CBMC itself relies on an
underlying SAT or SMT solver to solve verification conditions.  We~model FWL
effects, time discretization and the presence of quantization noise
explicitly using CBMC's nondeterminism API (e.g., \texttt{nondet},
\texttt{CPROVER\_assume} intrinsic functions).  Our module is included into
CBMC~5.7 and is available for
download.\footnote{\url{https://github.com/diffblue/cbmc/archive/cbmc-5.7.zip}}
\textcolor{red}{Lucas: I'll need support from Pascal to create this VirtualBoxOVA}
We further created a VirtualBox OVA image with our tool pre-installed,
including our MATLAB-generated benchmarks and benchmark shell script with
instructions to run all benchmarks and reproduce our
experiments.\footnote{\url{XXXXXXXXXX}}

\textcolor{red}{This paragraph needs to be updated by Elizabeth and Dario.}

The entire implementation consists of $XXX$ and $XXX$ lines of C code in the naive and abstract
accelerator back-ends, respectively, $XXXX$ lines of C code for utility functions such as interval, 
fixed- and floating-point arithmetic, as well as $1000$ lines of C++ code in the control synthesis
module in CEGIS CBMC.  We evaluate \tool~using $XXX$ SISO control system
benchmarks.

%-------------------------------
\section{Experimental Evaluation}
\label{exp:evaluation}
%-------------------------------

%-------------------------------
\subsection{Description of the benchmarks}
\label{exp:benchmarks}
%-------------------------------

%\textcolor{red}{Iury: can you please describe the benchmarks?}

Our benchmark suite consists of 18 SISO models extracted from the 
control literature~\cite{acrobot,cstr,CHEN1979389,KOKOTOVIC198023,gajic2008optimal,Franklin15, maglev, converters, CTMS};
these models are discretized with different sample times, leading to $167$ different benchmarks
to evaluate our proposal approach. 


The \textit{DC motor} plant describes the velocity dynamics of a basic 
brushed direct current electrical machine. 
The \textit{automotive cruise control system} plant is used to keep constant 
the speed of an automobile, tracking a desired speed reference, 
compensating disturbances and uncertainties related to relief and terrain.
The \textit{pendulum} plant consists of a swinging point mass suspended from 
a frictionless pivot by means of a negligible mass rod, while the 
\textit{inverted pendulum} plant describes a system similar to the pendulum, but the point 
mass must be equilibrated above the pivot point, which is mounted on an 
one degree of freedom cart that moves over a track through a DC motor.

The \textit{magnetic suspension} plant corresponds to the discrete model of a 
simple eletromagnet-ball system, where a steel ball is levitated in air 
by the action of an electromagnetic force generated by an electromagnet.
The \textit{magnetic pointer} plant describes a pointer employed in analogue 
gauges and indicators, whose angular position dynamics is controlled 
by a magnetic field. 
The \textit{1/4 car suspension} plant corresponds to the model of a single 
wheel suspension system of a car, {\it i.e.}, the relative motion dynamics 
of a mass springer damp model, which connects the car to one of its wheels.

The \textit{computer tape driver} plant describes a computer storage device used to read and write 
data on magnetic tapes. The \textit{acrobot} plant corresponds to the model of a two-link 
underactuated robot manipulator, named acrobot, linearized by partial 
feedback linearization~\cite{acrobot}. 
The \textit{high-order system} plants correspond to a series of high-order control system model 
generally used as example for order reduction techniques~\cite{CHEN1979389}.
%Here, these benchmarks are used to evaluate the proposed control 
%synthesis technique under critical conditions, {\it i.e.}, with a large number of parameters 
%to be considered.

There are two \textit{continuous stirred tank reactor} models that describe the PH dynamics of a neutralization 
reaction of an aqueous solution of sodium acetate with hydrochloric acid~\cite{cstr} and the temperature of a 
exothermic reaction~\cite{astrom2006advanced} in a continuous flow stirred-tank reactor. The \textit{bioreactor} 
benchmark is a linear model identified by least squares for the cell mass concentration controlled through dilution 
rate of a bioreactor~\cite{bioreactor}. The \textit{steam drum} benchmark describes the linear model for the 
level dynamics of a  boiler steam drum~\cite{boiler}.
The \textit{flexible beam} is a plant employed in vibration studies; the physical system consists of a flexible 
metallic structure with piezoceramic actuators and sensors.
The \textit{helicopter longitudinal motion} plant describes the dynamics of 
transitional motion with respect to a longitudinal plane and the 
rotational motion around the longitudinal axis.
The \textit{USCG cutter tampa heading angle} plant describes the heading angle 
dynamics of a Coast Guard cutter. 
The \textit{voltage regulator} plant consists of a linear model of a synchronous 
machine connected to an  infinite bus~\cite{KOKOTOVIC198023}.

The \textit{guidance control system} plant is another high-order system 
model used by Chen et al.~\cite{CHEN1979389}  to evaluate reduction 
techniques, which is used to determine the path of an autonomous vehicle movement.
The \textit{satellite attitude control system} plant describes the dynamics of a satellite attitude, 
{\it i.e.}, the orientation angles. An attitude control system must 
maintain the desired orientation of a satellite with respect to an 
inertial frame during all the excursion. 
The \textit{springer-mass damper system} plant is classic model for several mechanical 
systems dynamics. This benchmark describes a mass, which is fixed to a node by means 
of a springer and moves under the action of a input force, damping, and elastic force.

%-------------------------------
\subsection{Objectives}
\label{exp:objectives}
%-------------------------------

Using the state-space models given in Section~\ref{exp:benchmarks}, 
our evaluation has the following two experimental goals:

\begin{enumerate}

\item[EG1] \textbf{(Performance)} Show that both the multi-staged and the abstraction-based
CEGIS approaches are able to generate FWL digital controllers using floating-point arithmetic 
in a reasonable amount of time.

\item[EG2] \textbf{(sanity check)} Confirm the
stability and safety of the synthesized controllers outside of our model.

\end{enumerate}

%-------------------------------
\subsection{Results}
\label{exp:results}
%-------------------------------

\textcolor{red}{Lucas describe here the experimental results}

%-------------------------------
\subsection{Threats to validity}
\label{exp:threats-to-validity}
%-------------------------------

\textcolor{red}{Lucas: describe here the threats to validity}

%-------------------------------
\section{Conclusions}
\label{sec:conclusions}
%-------------------------------

\textcolor{red}{Cristina: Can you please write an initial version of the conclusions?}

%\addtodo{[Move material from \ref{sec:rw} here]}


%\begin{ack}                               % Place acknowledgements
%Partially supported by the Roman Senate.  % here.
%\end{ack}

\bibliographystyle{plain}        % Include this if you use bibtex 
\bibliography{paper}           % and a bib file to produce the 
                                 % bibliography (preferred). The
                                 % correct style is generated by
                                 % Elsevier at the time of printing.

%\begin{thebibliography}{99}     % Otherwise use the  
                                 % thebibliography environment.
                                 % Insert the full references here.
                                 % See a recent issue of Automatica 
                                 % for the style.
%  \bibitem[Heritage, 1992]{Heritage:92}
%     (1992) {\it The American Heritage. 
%     Dictionary of the American Language.}
%     Houghton Mifflin Company.
%  \bibitem[Able, 1956]{Abl:56}
%     B.~C.~Able (1956). Nucleic acid content of macroscope. 
%     {\it Nature 2}, 7--9. 
%  \bibitem[Able {\em et al.}, 1954]{AbTaRu:54}   
%     B.~C. Able, R.~A. Tagg, and M.~Rush (1954).
%     Enzyme-catalyzed cellular transanimations.
%     In A.~F.~Round, editor, 
%     {\it Advances in Enzymology Vol. 2} (125--247). 
%     New York, Academic Press.
%  \bibitem[R.~Keohane, 1958]{Keo:58}
%     R.~Keohane (1958).
%     {\it Power and Interdependence: 
%     World Politics in Transition.}
%     Boston, Little, Brown \& Co.
%  \bibitem[Powers, 1985]{Pow:85}
%     T.~Powers (1985).
%     Is there a way out?
%     {\it Harpers, June 1985}, 35--47.

%\end{thebibliography}

%\appendix


%%-------------------------------
%\section{Stability of Closed-loop Models}
%\label{sec:appendix-stability}
%%-------------------------------
%
%%-------------------------------
%\subsection{Stability of closed-loop models with fixed-point controller error}
%\label{sec:stab_FWL}
%%-------------------------------
%
%The proof of Jury's criterion~\cite{fadali} relies on the fact that the relationship between states and
%next states is defined by $x_{k+1} = (A_d - B_dK) x_k$, all computed
%at infinite precision.  When we employ a FWL digital controller, the
%operation becomes:
%%
%\begin{align*}
%x_{k+1} &= A_d \cdot x_{k} -(\mathcal{F}_{\langle I_c,F_c \rangle}(K)\cdot\mathcal{F}_{\langle I_c,F_c \rangle}(x_{k})).  \\
%x_{k+1} &= (A_d  - B_dK) \cdot x_k + B_dK\delta, 
%\end{align*}
%%
%where $\delta$ is the maximum error that can be introduced by the FWL
%controller in one step, i.e., by reading the states values once and
%multiplying by $K$ once.  We derive the closed form expression for $x_n$ as
%follows:
%%
%\begin{align*}
%x_{1} &= (A_d  - B_dK)x_0 + B_dK\delta \\
%x_{2} 
% &=(A_d  - B_dK)^2x_0 + (A_d  - B_dK)B_dK\delta + B_dK\delta \\
%x_{n} &= (A_d  - B_dK)^nx_0 + (A_d  - B_dK)^{n-1}B_dK\delta + ... \\  \nonumber & + (A_d  - B_dK)^1B_dK \delta + B_dK\delta \\
%  &= (A_d - B_dK)^nx_0 + \sum_{i=0}^{i=n-1}(A_d - B_dK)^iB_dk\delta. 
%\end{align*}
%
%The definition of asymptotic stability is that the system converges to a
%reference signal, in this case we use no reference signal so an
%asymptotically stable system will converge to the origin.  We know that the
%original system with an infinite-precision controller is stable, because we
%have synthesized it to meet Jury's criterion.  Hence, $(A_d - B_dK)^n x_0$ 
%must converge to zero.
%
%The power series of matrices
%converges~\cite{horn1990matrix} iff the eigenvalues of the matrix are less
%than~1 as follows:
%%
%%\begin{align*}
%$\sum_{i=0}^{\infty}T^i  = (I - T)^{-1}$, 
%%\end{align*}
%%
%where $I$ is the identity matrix and $T$ is a square matrix. Thus, our system will converge to the value 
%%
%\begin{align*}
%0 + (I - A_d + B_dK)^{-1}B_dk\delta \,. 
%\end{align*}
%%
%As a result, if the value $(I - A_d + B_dK)^{-1}B_dk\delta$ is within the
%safe space, then the synthesized fixed-point controller results in a safe
%closed-loop model.  The convergence to a finite value, however, will not
%make it asymptomatically stable.
%
%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
%\section{Errors in LTI models} \label{sec:appendix:LTIbackground}
%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
%
%\subsection{Errors due to numerical representation} \label{appendix:numerical_errors}
%
%We have  used $\mathcal{F}_{\langle I,F \rangle}(x)$ denote a real number
%$x$ represented in a fixed point domain, with $I$ bits representing the
%integer part and $F$ bits representing the decimal part.  The smallest
%number that can be represented in this domain is $c_m=2^{-F}$.  The
%following approximation errors will arise in mathematical operations and
%representation:
%%
%\begin{enumerate}
%
%\item {\bf Truncation:} Let $x$ be a real number, and $\mathcal{F}_{\langle
%I,F \rangle}(x)$ be the same number represented in a fixed-point domain as
%above.  Then $\mathcal{F}_{\langle I,F \rangle}(x) = x-\delta_T$ where the
%error $ \delta_T=x\ \%_{c_m}\ \tilde x$, and $\%_{c_m}$ is the modulus
%operation performed on the last bit. 
%Thus, $\delta_T$ is the truncation error and it will propagate across
%operations.
%%
%\item {\bf Rounding:} The following errors appear in basic operations.  Let
%$c_1, c_2$ and $c_3$ be real numbers, and $\delta_{T1}$ and $\delta_{T2}$ be
%the truncation errors caused by representing $c_1$ and $c_2$ in the
%fixed-point domain as above.
%%
%\begin{enumerate}
%%
%\item Addition/Subtraction: these operations only propagate errors coming
%from truncation of the operands, namely $\mathcal{F}_{\langle I,F
%\rangle}(c_1) \pm \mathcal{F}_{\langle I,F \rangle}(c_2) = c_3 + \delta_3$
%with $|\delta_3| \leq |\delta_{T1}| + |\delta_{T2}|$.
%%
%\item Multiplication: $\mathcal{F}_{\langle I,F \rangle}(c_1) \cdot
%\mathcal{F}_{\langle I,F \rangle}(c_2) =  c_3 + \delta_3$ with $|\delta_3|
%\leq |\delta_{T1}\cdot\mathcal{F}_{\langle I,F \rangle}(c_2)|\allowbreak +
%|\delta_{T2}\cdot\mathcal{F}_{\langle I,F \rangle}(c_1)| + c_m$, where
%$c_m=2^{-F}$ as above.
%%
%\item Division: the operations performed by our controllers in the FWL
%domain do not include division.  However, we do use division in computations
%at the precision of the plant.  Here the error depends on whether the
%divisor is greater or smaller than the dividend:  $\mathcal{F}_{\langle I,F
%\rangle}(c_1) / \mathcal{F}_{\langle I,F \rangle}(c_2) = c_3 + \delta_{T3}$
%where $\delta_{T3}$ is $(\delta_{T2}\cdot c_1 - \delta_{T1}\cdot
%c_2)/(\delta_{T2}^2 - \delta_{T2} c_2)$,
%\end{enumerate}
%
%\item {\bf Overflow:}
%The maximum size of a real number $x$ that can be represented in a fixed
%point domain as $\mathcal{F}_{\langle I,F \rangle}(x)$ is $\pm
%(2^{I-1}+1-2^{-F})$.  Numbers outside this range cannot be represented by
%the domain.  We check that overflow does not occur.
%
%\end{enumerate}
%
%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
%\subsection{Modeling quantization as noise} \label{appendix:quantization-noise}
%%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
%
%During any given ADC conversion, the continuous signal will be sampled in
%the real domain and transformed by $\mathcal{F}\langle I_{c},F_{c} \rangle
%(x)$ (assuming the ADC discretization is the same as the digital
%implementation).  This sampling uses a threshold which is defined by the
%less significant bit ($q_{c}=c_{m_c}=2^{-F_c}$) 
%of the ADC and some non-linearities of the circuitry.  The overall conversion is
%%
%$$\mathcal{F}\langle I_{c},F_{c} \rangle(y(t)) = y_k :
%y_k \in \left[y(t)-\frac{q_{c}}{2}\ \ \ \ y(t)+\frac{q_{c}}{2}\right] \,.$$
%%
%If we denote the error in the conversion by $\nu_k=y_k-y(t)$ where $t = nk$,
%and $n$ is the sampling time and $k$ the number of steps, then we may define
%some bounds for it $\nu_k \in [-\frac{q_{c}}{2}\ \ \frac{q_{c}}{2}]$.
%
%We will assume, for the purposes of this analysis, that the domain of the
%ADC is that of the digital controller (i.e, the quantizer includes any
%digital gain added in the code).  The process of quantization in the DAC is
%similar except that it is calculating $\mathcal{F}\langle I_{dac},F_{dac}
%\rangle (\mathcal{F}\langle I_{c},F_{c} \rangle (x)) $.  If these domains
%are the same ($I_{c}=I_{dac},\allowbreak F_{c}=F_{dac}$), or if the DAC
%resolution in higher than the ADCs, then the DAC quantization error is equal
%to zero.  From the above equations we can now define the ADC and DAC
%quantization noises ${\nu_1}_k \in [-\frac{q_1}{2}\ \ \frac{q_1}{2}]$ and
%${\nu_2}_k \in [-\frac{q_2}{2}\ \ \frac{q_2}{2}]$, where $q_1=q_{c}$ and 
%$q_2=q_\mathit{dac}$.  This is illustrated in
%Fig.~\ref{ssec:statefeedbackcontrol} where $Q_1$ is the quantizer of the ADC
%and $Q_2$ the quantizer for the DAC.  These bounds hold irrespective of
%whether the noise is correlated, hence we may use them to over-approximate
%the noise effect on the state space progression over time.  The
%resulting dynamics are
%%
%\begin{align*}
%%\label{eq:pre_quantization}
%{x}_{k+1} = {A}_d{x}_k+{B}_d({u}_k+{{\nu}_2}_k), \quad u_k = -K{x}_{k}+{{\nu}_1}_k, 
%\end{align*}
%%
%which result in the following closed-loop dynamics:
%%
%\begin{align*}
%%\label{eq:quantization}
%{x}_{k+1} &= ({A}_d-{B}_d{K}_d) {x}_k+{B}_d{{\nu}_2}_k +{{\nu}_1}_k \,. 
%\end{align*}



%\section{A summary of Latin grammar}    % Each appendix must have a short title.
%\section{Some Latin vocabulary}         % Sections and subsections are supported  
                                        % in the appendices.
\end{document}
