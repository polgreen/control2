
%%%%%%%%%%%%%%%%%%%%%%% file typeinst.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is the LaTeX source for the instructions to authors using
% the LaTeX document class 'llncs.cls' for contributions to
% the Lecture Notes in Computer Sciences series.
% http://www.springer.com/lncs       Springer Heidelberg 2006/05/04
%
% It may be used as a template for your own input - copy it
% to a new file with a new name and use it as the basis
% for your article.
%
% NB: the document class 'llncs' has its own and detailed documentation, see
% ftp://ftp.springer.de/data/pubftp/pub/tex/latex/llncs/latex2e/llncsdoc.pdf
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass[runningheads,a4paper]{llncs}

\usepackage{amssymb}
\usepackage{amsmath}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{framed}
\usepackage{listings}


\usetikzlibrary{positioning, arrows, automata, shapes}

\newcommand{\todo}[1]{{\color{red} TODO: #1}}
\newcommand{\commentib}[1]{{\color{blue} [IB: #1]}}


\usepackage{url}
%\urldef{\mailsa}\path|{alfred.hofmann, ursula.barth, ingrid.haas, frank.holzwarth,|
%\urldef{\mailsb}\path|anna.kramer, leonie.kunz, christine.reiss, nicole.sator,|
%\urldef{\mailsc}\path|erika.siebert-cole, peter.strasser, lncs}@springer.com|    
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\begin{document}

\mainmatter  % start of an individual contribution

% first the title is needed
\title{Automated Synthesis of State-Space Digital Systems}

% a short form should be given in case it is too long for the running head
%\titlerunning{Lecture Notes in Computer Science: Authors' Instructions}

% the name(s) of the author(s) follow(s) next
%
% NB: Chinese authors should write their first names(s) in front of
% their surnames. This ensures that the names appear correctly in
% the running heads and the author index.
%
%\author{Alfred Hofmann%
%\thanks{Please note that the LNCS Editorial assumes that all authors have used
%the western naming convention, with given names preceding surnames. This determines
%the structure of the names in the running heads and the author index.}%
%\and Ursula Barth\and Ingrid Haas\and Frank Holzwarth\and\\
%Anna Kramer\and Leonie Kunz\and Christine Rei\ss\and\\
%Nicole Sator\and Erika Siebert-Cole\and Peter Stra\ss er}
%
%\authorrunning{Lecture Notes in Computer Science: Authors' Instructions}
% (feature abused for this document to repeat the title also on left hand pages)

% the affiliations are given next; don't give your e-mail address
% unless you accept that it will be published
%\institute{Springer-Verlag, Computer Science Editorial,\\
%Tiergartenstr. 17, 69121 Heidelberg, Germany\\
%\mailsa\\
%\mailsb\\
%\mailsc\\
%\url{http://www.springer.com/lncs}}

%
% NB: a more complex sample for affiliations and the mapping to the
% corresponding authors can be found in the file "llncs.dem"
% (search for the string "\mainmatter" where a contribution starts).
% "llncs.dem" accompanies the document class "llncs.cls".
%

%\toctitle{Lecture Notes in Computer Science}
%\tocauthor{Authors' Instructions}
\maketitle


\begin{abstract}
The abstract should summarize the contents of the paper and should
contain at least 70 and at most 150 words. It should be written using the
\emph{abstract} environment.
\keywords{We would like to encourage you to list your keywords within
the abstract section}
\end{abstract}


%-------------------------------
\section{Introduction}
%-------------------------------

In this paper we formalise the notion of solution generalisation for CEGIS. 
This technique allows the inductive generalisation engine to look for 
candidate solutions in a reduced solution space.

%-------------------------------
\section{Counter-Example Guided Inductive Synthesis with solution generalisation}
%-------------------------------

This technique relies on parametrising the target language, which
induces a lattice of progressively more expressive languages.  We
start by attempting to synthesise a program at the lowest point on
this lattice and increase the parameters of the language until we
reach a point at which the synthesis succeeds. As well as giving us an
automatic search procedure, this parametrisation greatly increases the
efficiency of our system since languages low down the lattice are very
easy to decide safety for (i.e. the validation oracle finds an answer
fast). If a program can be synthesised in a low-complexity language,
the whole procedure finishes much faster than if synthesis had been
attempted in a high-complexity language.

\textcolor{red}{LC: Cristina, may I ask you to expand further this section by connecting it to our control-synthesis work?}
\begin{figure}
\centering
\hspace*{-1cm}
\begin{tikzpicture}[scale=0.3,->,>=stealth',shorten >=.2pt,auto, semithick, initial text=, ampersand replacement=\&,]
  \matrix[nodes={draw, fill=none, shape=rectangle, minimum height=.2cm, minimum width=.2cm, align=center
},
          row sep=1cm, column sep=1.5cm] {
   \coordinate (aux1);
   \& \coordinate (aux2);
   \& ;\\
   \node[fill=yellow!20,align=center] (synth) {{\sc inductive}\\{\sc generalisation}};
   \&
   complexnode/.pic={ 
     \node[rectangle,draw,dashed,
	minimum width=6.7cm,
	minimum height=.8cm,
	label={\sc Validation oracles},] (verif) {};
   \node[fill=yellow!20] (verif1) at ([xshift=-2.1cm]verif.center) {{\sc Validate}};
   \node[fill=yellow!20,align=center] (verif2) at ([xshift=1.7cm]verif.center) {{\sc validate general}};
   } 
   \& \node[ellipse, fill=yellow!20] (done) {{\sc Done}};\\
   %% \node[fill=yellow!20] (verif) {{\sc ~~~~~~Uncertainty~~~~~~}};
   %% \&
   %% \node[fill=yellow!20] (verif2) {{\sc ~~~~~~Precision~~~~~~~}};\\
   \& \\
   \& \\
   \node (gp) {Program Search};
   \&
   complexnode/.pic={ 
     \coordinate (aux);
   \node (bmc) at ([xshift=-2.1cm]aux.center) {SAT/SMT Solver};
   \node (fp)  at ([xshift=1.9cm]aux.center) {SAT/SMT Solver};
   }   
    \\
  };

   \path
    ([yshift=2em]synth.east) edge node[xshift=-0.7em] {Candidate} ([yshift=2em]verif1.west)
    ([yshift=-2em]verif1.west) edge node[xshift=-0.7em] {New input} ([yshift=-2em]synth.east)
    (verif1) edge node {Generalise} (verif2)
    ([xshift=5em]verif1.south) edge node[align=center] {Candidate} ([xshift=5em]bmc.north)
    ([xshift=5em]verif2.south) edge node[align=center] {Candidate} ([xshift=3.8em]fp.north)
    ([xshift=-5em]bmc.north) edge node[align=center]  {UNSAT/\\Model} ([xshift=-5em]verif1.south)
    ([xshift=-6.2em]fp.north) edge node[align=center]  {UNSAT/\\Model} ([xshift=-5em]verif2.south)
    (verif2) edge node {} (done)
    ([xshift=5em]synth.south) edge node[align=center] {{\sc Inputs}} ([xshift=5em]gp.north)
    ([xshift=-5em]gp.north) edge node[align=center] {No solution/\\Candidate} ([xshift=-5em]synth.south)
    (aux1) edge (synth.north);
   \path[-]
   (verif2.north) edge node[align=center] {} ([xshift=5.6cm]aux2)
   ([xshift=5.6cm]aux2) edge node[align=center] {Increase parameters} (aux1);

\end{tikzpicture}
\caption{The CEGIS loop with solution generalisation\label{fig:CEGIS-multiple-verif}.}
\end{figure}

  %% \textcolor{red}{LC: Cristina, can you please fix this figure? The text ``candidate'' overlaps with the dotted box.}

%-------------------------------
\section{Discretising Continuous Space Dynamics}
%-------------------------------

A dynamical system is a system in which a function describes the progression of a state over time. 
In a continuous domain with linear dynamics, it is described by a first order Ordinary Differential Equation (ODE).
\begin{equation}
\dot{x}(t)=\vec{A}\vec{x}(t)+\vec{B}\vec{u}(t) +\vec{w}(t).
\label{eq:dynamical}
\end{equation}

\noindent with $\vec{w} \sim \mathcal{N}(0,Q)$.\\
Furthermore, a control system may have a derived output that is a linear combination of its states and inputs, 
which may restricts the observability of the state-space from the output space.
\begin{equation}
\vec{y}(t)=\vec{C}\vec{x}(t)+\vec{D}\vec{u}(t).
\end{equation}

Discretization of an continuous dynamical system turns the ODE into a difference equation, assuming zero-order hold
for the input $\vec{u}$ and continuous integration for the noise $\vec{w}$, to
\begin{align}
\label{eq:discretization}
\vec{x}_{k+1} &= \vec{A}_d\vec{x}_k+\vec{B}_d\vec{u}_k + \vec{w}_k,\\
y_k &= \vec{C}_d \vec{x}_ k + \vec{D}_d \vec{u}_ k. 
\end{align}
with covariance for $\vec{w}_k \sim \mathcal{N}(0,Q_d)$,
where
\begin{align}
\label{eq:discretize}
\vec{A}_d &= e^{\vec{A} T_s} = \mathcal{L}^{-1} { ( s \vec{I} - \vec{A} )^{-1} }_{t = T_s},\\
\vec{B}_d &= \int_{0}^{T_s} e^{\vec{A} t} dt\ \vec{B} = \vec{A}^{-1} ( \vec{A}_d - \vec{I} ) \vec{B},\\
\vec{C}_d &= \vec{C},\\
\vec{D}_d &= \vec{D},\\
Q_d &= \int_{0}^{T_s} e^{\vec{A} t} Q e^{\vec{A}^T t} dt.
\end{align}
and $T_s$ is the sample time. Then
\begin{align*}
x(kT)=x_k \wedge y(kT) = y_k, \forall k.
\end{align*}
Let $g_d(k)=\mathcal{G}(t,g(t),T)$ be a function that performs the discretization described above, where $g(t)$
represents the continuous dynamics and $g_d(k)$ the corresponding discrete dynamics. 
Let $G(s)=\mathcal{L}(g(t))$ and $G_d(z)=\mathcal{Z}(g_d(k))$ be the corresponding Laplace and Z-transforms
of $g(t)$ and $g_d(k)$. Given this relation, we have 
$$G_d(z)=G(z)|_{z=e^{sT}} : g_d(k)=\mathcal{G}(t,g(t),T) \wedge T < \frac{1}{.5f_s},$$
where $.5f_s$ is the Nyquist frequency of $g(t)$. This last restriction is introduced to avoid the effects of aliasing
which could cause ``phantom poles'' to appear otherwise. 
The eigenvalues of $\vec{A}_d$ corresponding to the poles of $G_d(z)$, and those of $\vec{A}$ corresponding to the poles of $G(s)$ are similarly related.
$\hat{\lambda}_i=e^{-\lambda_iT} : \hat{\lambda}_i \in \sigma(\vec{A}_d) \wedge \lambda_i \in \sigma(\vec{A})$
where $\sigma(\cdot)$ is the spectrum of a matrix.
The following remark is worth mentioning regarding the above.
\begin{remark}
The witnessed maximum amplitude of the discrete signals $x_k,y_k$ may be smaller to that of $x(t),y(t)$ due to synchronism at fraction-frequency sampling.
This means that reasoning about the state-space must consider the effects of this possibility as well of the case of maximal inputs from the continuous specification.
\end{remark}
\textcolor{red}{LC: Dario, where is the section you mention?... Since \eqref{eq:discretization} is a bisimulation of \eqref{eq:dynamical}, we may use the semantics in section \ref{sec:model_semantics} to model continuous dynamical systems.}

%-------------------------------
\section{LTI representations of ARMA models}
%-------------------------------

Let us have a discrete time SISO system with an $n^{th},m{^th} : n\geq m$ order armax model
$$y[k]=\sum_{i=1}^n a_iy[k-i]+\sum_{i=0}^m b_iu[k-i],$$
where $y$ is the output of the system and $u$ its input.
The equivalent LTI dynamics of such a model are:
\begin{align}
\vec{x}_k=&\vec{A}\vec{x}_{k-1}+\vec{B}u_k : \vec{x}_k=[y_{k-n}\ \hdots y_{k-1}\ y_{k}]^T\\
y_k=&\vec{C}\vec{x}_k + b_0u_k\nonumber\\
\vec{A}=&\left[
\begin{array}{ccccc}
0&1&0&\cdots&0\\
0&0&1&\cdots&0\\
\vdots&\vdots&\vdots&\ddots&\vdots\\
0&0&0&\cdots&1\\
-a_n&-a_{n-1}&-a_{n-2}&\cdots&-a_1
\end{array}\right],
\vec{B}=\left[
\begin{array}{c}
0\\0\\ \vdots\\ 0\\ 1
\end{array}\right]\nonumber\\
\vec{C}=&[b_n-a_nb_0\ b_{n-1}-a_{n-1}b_0 \cdots b_1-a_1b_0] : b_{i \in (m\ n]}=0\nonumber
\end{align}

%-------------------------------
\section{Experimental Evaluation}
%-------------------------------


%-------------------------------
\subsection{Description of the Benchmarks}
%-------------------------------

A set of state-space models for different classes of systems were extracted from the literature and employed for validating our automated synthesis methodology. All the systems are SISO models of the following form:
\begin{equation}
\left\lbrace\begin{array}{c}
\dot{\textbf{x}}(t)=\textbf{A}\textbf{x}(t)+\textbf{B}u(t)\\
y(t)=\textbf{C}\textbf{x}(t)+\textbf{D}u(t)
\end{array}\right.
\end{equation}

The first plant represents a DC motor position model from~\cite{CTMS}. It is a third order system and presents the following set of matrices $\textbf{A}$, $\textbf{B}$, $\textbf{C}$, $\textbf{D}$, and $\textbf{x}$:
$$
\textbf{A}=\left[\begin{array}{ccc}
0		& 1 		& 0						\\
0 		& -1.087	& 8587					\\
0		& -9964		& -1.455\times 10^{6}	\\
\end{array}\right],~~ \textbf{B} = \left[\begin{array}{c}
0 \\ 0 \\ -1.455\times10^{6}
\end{array}\right]
$$
%
$$
\textbf{C}=\left[\begin{array}{ccc}
1 & 0 & 0\\
\end{array}\right],~~ \textbf{D}= 0,~~ \textbf{x}=\left[\begin{array}{c}
\theta \\ \dot{\theta} \\ i \\
\end{array}\right],
$$
where the states $\theta$, $\dot{\theta}$, and $i$ are respectively the rotor angular position, rotor angular rate and the current of armature. The DC motor is stable in open loop.

The second benchmark is an aircraft pitch dynamics model extracted from~\cite{CTMS}. It is a third order system and it presents the following set of matrices $\textbf{A}$, $\textbf{B}$, $\textbf{C}$, $\textbf{D}$, and $\textbf{x}$:
$$
\textbf{A}=\left[\begin{array}{ccc}
-0.313	& 56.7 		& 0		\\
-0.0139	& -0.426	& 0		\\
0		& 56.7		& 0		\\
\end{array}\right],~~ \textbf{B} = \left[\begin{array}{c}
0.232 \\ 0.0203 \\ 0
\end{array}\right]
$$
%
$$
\textbf{C}=\left[\begin{array}{ccc}
0 & 0 & 1\\
\end{array}\right],~~ \textbf{D}= 0,~~ \textbf{x}=\left[\begin{array}{c}
\alpha \\ \dot{\theta} \\ \theta \\
\end{array}\right],
$$
where the states $\alpha$, $\dot{\theta}$, and $\theta$ are respectively the aircraft attack angle, pitch rate and the pitch angle. The aircraft pitch dynamic is critically stable in open loop, with a pole in origin of $s$-plane.

The third benchmark is a ball magnetic levitation model extracted from~\cite{maglev}. It is a third order system presents the following set of matrices $\textbf{A}$, $\textbf{B}$, $\textbf{C}$, $\textbf{D}$, and $\textbf{x}$:
$$
\textbf{A}=\left[\begin{array}{ccc}
0		& 1 		& 0		\\
1752	& 0			& -34.07\\
0		& 0			& -38.27\\
\end{array}\right],~~ \textbf{B} = \left[\begin{array}{c}
0 \\ 0 \\ 1.923
\end{array}\right]
$$
%
$$
\textbf{C}=\left[\begin{array}{ccc}
1 & 0 & 0\\
\end{array}\right],~~ \textbf{D}= 0,~~ \textbf{x}=\left[\begin{array}{c}
z \\ \dot{z} \\ i \\
\end{array}\right],
$$
where the states $z$, $\dot{z}$, and $i$ are respectively the vertical displacement of the ball, its rate and the coil current. This system  is unstable in open loop.

The remaining of benchmarks represents classic DC-DC converters: buck, boost, and buck-boost. They are SISO second-order systems stable in open-loop, and their state vector is $\textbf{x}=\textbf{x}=\left[\begin{array}{c}
i_{L} \\ v_{C}\\
\end{array}\right]$, where $i_{L}$ is the current in the coil and $v_{c}$ is the voltage on the capacitor. The matrices $\textbf{A}$, $\textbf{B}$, $\textbf{C}$, and $\textbf{D}$ for the buck converter are:
$$
\textbf{A}=\left[\begin{array}{cc}
0		& -500 \\
4545	& -1515\\
\end{array}\right],~ \textbf{B} = \left[\begin{array}{c}
125 \\ 0 \\
\end{array}\right]~
\textbf{C}=\left[\begin{array}{cc}
0 & 1\\
\end{array}\right],~ \textbf{D}= 0.
$$

The matrices of the boost converter are:
$$
\textbf{A}=\left[\begin{array}{cc}
0		& -375 \\
3409	& -1515\\
\end{array}\right],~ \textbf{B} = \left[\begin{array}{c}
500 \\ 0 \\
\end{array}\right]~
\textbf{C}=\left[\begin{array}{cc}
0 & 1\\
\end{array}\right],~ \textbf{D}= 0.
$$

Finally, the matrices of the buck-boost converter are:
$$
\textbf{A}=\left[\begin{array}{cc}
0		& 375 \\
-3409	& -1515\\
\end{array}\right],~ \textbf{B} = \left[\begin{array}{c}
125 \\ 0 \\
\end{array}\right]~
\textbf{C}=\left[\begin{array}{cc}
0 & 1\\
\end{array}\right],~ \textbf{D}= 0.
$$.



%-------------------------------
\subsection{Objectives}
%-------------------------------

%-------------------------------
\subsection{Results}
%-------------------------------


%-------------------------------
\subsection{Threats to validity}
%-------------------------------


%-------------------------------
\section{Related Work}
%-------------------------------

\paragraph{CEGIS}

Program synthesis is the problem of computing correct-by-design programs
from high-level specifications, and algorithms for this problem have made
substantial progress in recent years.  One such
approach~\cite{itzhaky2010simple} inductively synthesizes invariants to
generate the desired programs.

Program synthesisers are an ideal fit for synthesis of parametric
controllers since the semantics of programs capture effects such as FWL
precisely.  In~\cite{DBLP:conf/cdc/RavanbakhshS15}, the authors use CEGIS
for the synthesis of switching controllers for stabilizing continuous-time
plants with polynomial dynamics.  The work extends to its application on
affine systems, finding its major challenge in the hardness of solving
linear arithmetic with the state-of-the-art SMT solvers.  Since this
approach uses switching states instead of linear dynamics in the digital
controller, it entirely circumvents the FWL problem.  It is also not
suitable for the kind of control we seek to synthesize.
Moreover, in \cite{DBLP:conf/emsoft/RavanbakhshS16} the same authors 
use a CEGIS-based approach for synthesizing continuous-time switching
controllers that guarantee reach while stay properties of a closed
loop system. The solution is based on synthesizing control Lyapunov
functions for switched systems, that yield switching controllers with
a guaranteed minimum dwell time in each mode.

We require a
combination of a synthesis engine with a control verification tool that
addresses the challenges presented here in the form of FWL effects and
stability measures for LTI SISO controllers.  We take the former
from~\cite{DBLP:conf/lpar/DavidKL15} and the latter from~\cite{daes20161},
while enhancing the procedure by evaluating the quantization effects of the
Hardware interfaces (ADC/DAC) to obtain an accurate discrete-time FWL
representation of the continuous dynamics.




\textcolor{red}{LC: Cristina and Dario, should we further expand this section with other initiatives to synthesise control systems?}

\bibliographystyle{abbrv}
\bibliography{paper}  
%\begin{thebibliography}{4}
%\end{thebibliography}


\end{document}
