
%%%%%%%%%%%%%%%%%%%%%%% file typeinst.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is the LaTeX source for the instructions to authors using
% the LaTeX document class 'llncs.cls' for contributions to
% the Lecture Notes in Computer Sciences series.
% http://www.springer.com/lncs       Springer Heidelberg 2006/05/04
%
% It may be used as a template for your own input - copy it
% to a new file with a new name and use it as the basis
% for your article.
%
% NB: the document class 'llncs' has its own and detailed documentation, see
% ftp://ftp.springer.de/data/pubftp/pub/tex/latex/llncs/latex2e/llncsdoc.pdf
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass[runningheads,a4paper]{llncs}

\usepackage{amssymb}
\usepackage{amsmath}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{framed}
\usepackage{listings}


\usetikzlibrary{positioning, arrows, automata, shapes}

\newcommand{\todo}[1]{{\color{red} TODO: #1}}
\newcommand{\commentib}[1]{{\color{blue} [IB: #1]}}


\usepackage{url}
%\urldef{\mailsa}\path|{alfred.hofmann, ursula.barth, ingrid.haas, frank.holzwarth,|
%\urldef{\mailsb}\path|anna.kramer, leonie.kunz, christine.reiss, nicole.sator,|
%\urldef{\mailsc}\path|erika.siebert-cole, peter.strasser, lncs}@springer.com|    
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\begin{document}

\mainmatter  % start of an individual contribution

% first the title is needed
\title{Automated Synthesis of State-Space Digital Controllers}

% a short form should be given in case it is too long for the running head
%\titlerunning{Lecture Notes in Computer Science: Authors' Instructions}

% the name(s) of the author(s) follow(s) next
%
% NB: Chinese authors should write their first names(s) in front of
% their surnames. This ensures that the names appear correctly in
% the running heads and the author index.
%
%\author{Alfred Hofmann%
%\thanks{Please note that the LNCS Editorial assumes that all authors have used
%the western naming convention, with given names preceding surnames. This determines
%the structure of the names in the running heads and the author index.}%
%\and Ursula Barth\and Ingrid Haas\and Frank Holzwarth\and\\
%Anna Kramer\and Leonie Kunz\and Christine Rei\ss\and\\
%Nicole Sator\and Erika Siebert-Cole\and Peter Stra\ss er}
%
%\authorrunning{Lecture Notes in Computer Science: Authors' Instructions}
% (feature abused for this document to repeat the title also on left hand pages)

% the affiliations are given next; don't give your e-mail address
% unless you accept that it will be published
%\institute{Springer-Verlag, Computer Science Editorial,\\
%Tiergartenstr. 17, 69121 Heidelberg, Germany\\
%\mailsa\\
%\mailsb\\
%\mailsc\\
%\url{http://www.springer.com/lncs}}

%
% NB: a more complex sample for affiliations and the mapping to the
% corresponding authors can be found in the file "llncs.dem"
% (search for the string "\mainmatter" where a contribution starts).
% "llncs.dem" accompanies the document class "llncs.cls".
%

%\toctitle{Lecture Notes in Computer Science}
%\tocauthor{Authors' Instructions}
\maketitle


\begin{abstract}
The abstract should summarize the contents of the paper and should
contain at least 70 and at most 150 words. It should be written using the
\emph{abstract} environment.
\keywords{We would like to encourage you to list your keywords within
the abstract section}
\end{abstract}


%-------------------------------
\section{Introduction}
%-------------------------------
In this paper we formalise the notion of solution generalisation for CEGIS. 
This technique allows the inductive generalisation engine to look for 
candidate solutions in a reduced solution space.

\section{Counter-Example Guided Inductive Synthesis with solution generalisation}

This technique relies on parametrising the target language, which
induces a lattice of progressively more expressive languages.  We
start by attempting to synthesise a program at the lowest point on
this lattice and increase the parameters of the language until we
reach a point at which the synthesis succeeds. As well as giving us an
automatic search procedure, this parametrisation greatly increases the
efficiency of our system since languages low down the lattice are very
easy to decide safety for (i.e. the validation oracle finds an answer
fast). If a program can be synthesised in a low-complexity language,
the whole procedure finishes much faster than if synthesis had been
attempted in a high-complexity language.

\begin{figure}
\centering
\hspace*{-1cm}
\begin{tikzpicture}[scale=0.3,->,>=stealth',shorten >=.2pt,auto, semithick, initial text=, ampersand replacement=\&,]
  \matrix[nodes={draw, fill=none, shape=rectangle, minimum height=.2cm, minimum width=.2cm, align=center
},
          row sep=1cm, column sep=1.5cm] {
   \coordinate (aux1);
   \& \coordinate (aux2);
   \& ;\\
   \node[fill=yellow!20,align=center] (synth) {{\sc inductive}\\{\sc generalisation}};
   \&
   complexnode/.pic={ 
     \node[rectangle,draw,dashed,
	minimum width=7cm,
	minimum height=.8cm,
	label={\sc Validation oracles},] (verif) {};
   \node[fill=yellow!20] (verif1) at ([xshift=-2.1cm]verif.center) {{\sc Validate}};
   \node[fill=yellow!20,align=center] (verif2) at ([xshift=1.9cm]verif.center) {{\sc validate general}};
   } 
   \& \node[ellipse, fill=yellow!20] (done) {{\sc Done}};\\
   %% \node[fill=yellow!20] (verif) {{\sc ~~~~~~Uncertainty~~~~~~}};
   %% \&
   %% \node[fill=yellow!20] (verif2) {{\sc ~~~~~~Precision~~~~~~~}};\\
   \& \\
   \& \\
   \node (gp) {Program Search};
   \&
   complexnode/.pic={ 
     \coordinate (aux);
   \node (bmc) at ([xshift=-2.1cm]aux.center) {SAT/SMT Solver};
   \node (fp)  at ([xshift=1.9cm]aux.center) {SAT/SMT Solver};
   }   
    \\
  };

   \path
    ([yshift=2em]synth.east) edge node[xshift=-0.7em] {Candidate} ([yshift=2em]verif1.west)
    ([yshift=-2em]verif1.west) edge node[xshift=-0.7em] {New input} ([yshift=-2em]synth.east)
    (verif1) edge node {Generalise} (verif2)
    ([xshift=5em]verif1.south) edge node[align=center] {Candidate} ([xshift=5em]bmc.north)
    ([xshift=5em]verif2.south) edge node[align=center] {Candidate} ([xshift=5em]fp.north)
    ([xshift=-5em]bmc.north) edge node[align=center]  {UNSAT/\\Model} ([xshift=-5em]verif1.south)
    ([xshift=-5em]fp.north) edge node[align=center]  {UNSAT/\\Model} ([xshift=-5em]verif2.south)
    (verif2) edge node {} (done)
    ([xshift=5em]synth.south) edge node[align=center] {{\sc Inputs}} ([xshift=5em]gp.north)
    ([xshift=-5em]gp.north) edge node[align=center] {No solution/\\Candidate} ([xshift=-5em]synth.south)
    (aux1) edge (synth.north);
   \path[-]
   (verif2.north) edge node[align=center] {} ([xshift=6.5cm]aux2)
   ([xshift=6.5cm]aux2) edge node[align=center] {Increase parameters} (aux1);

\end{tikzpicture}
\caption{The CEGIS loop with solution generalisation\label{fig:CEGIS-multiple-verif}}
\end{figure}

\section{Discretising Continuous Space Dynamics}

A dynamical system is a system in which a function describes the progression of a state over time. 
In a continuous domain with linear dynamics, it is described by a first order Ordinary Differential Equation (ODE).
\begin{equation}
\dot{x}(t)=\vec{A}\vec{x}(t)+\vec{B}\vec{u}(t) +\vec{w}(t)
\label{eq:dynamical}
\end{equation}

Where \textcolor{red}{$\vec{w}$  is a continuous zero-mean white noise source with covariance $N ( 0 , Q )$} \commentib{$N(0,Q)$ is the notation for PDF (specifically a normal zero mean PDF with Q variance) and it is not a notation for covariance. All the above expression may be rewritten with "$\vec{w} \sim \mathcal{N}(0,Q)$"}.
Furthermore, a control system may have a derived output that is a linear combination of its states and inputs, 
which may restricts the observability of the statespace from the output space.
\begin{equation}
\vec{y}(t)=\vec{C}\vec{x}(t)+\vec{D}\vec{u}(t)
\end{equation}

Discretization of an continuous dynamical system turns the ODE into a difference equation, assuming zero-order hold
for the input $\vec{u}$ and continuous integration for the noise $\vec{w}$, to
\begin{align}
\label{eq:discretization}
\vec{x}_{k+1} &= \vec{A}_d\vec{x}_k+\vec{B}_d\vec{u}_k + \vec{w}_k\\
y_k &= \vec{C}_d \vec{x}_ k + \vec{D}_d \vec{u}_ k 
\end{align}
with covariance for $\vec{w}_k$, $N ( 0 , Q_d )$
where \commentib{Are the second parts of equations (5) and (6) really nedded?}
\begin{align}
\label{eq:discretize}
\vec{A}_d &= e^{\vec{A} T_s} = \mathcal{L}^{-1} { ( s \vec{I} - \vec{A} )^{-1} }_{t = T_s}\\
\vec{B}_d &= \int_{0}^{T_s} e^{\vec{A} t} dt\ \vec{B} = \vec{A}^{-1} ( \vec{A}_d - \vec{I} ) \vec{B}\\
\vec{C}_d &= \vec{C}\\
\vec{D}_d &= \vec{D} \\
Q_d &= \int_{0}^{T_s} e^{\vec{A} t} Q e^{\vec{A}^T t} dt
\end{align}
and $T_s$ is the sample time. Then
\begin{align*}
x(kT)=x_k \wedge y(kT) = y_k, \forall k
\end{align*}
Similarly, we can now state that the Z-transform of the discrete-time equation g(k) and the Laplace transform of the continuous time
equation g(t) are related.
$$g(t) \rightarrow g(k) \Leftrightarrow G(S)=\mathcal{L}(g(t)) \rightarrow G(Z)=\mathcal{Z}(g(k))$$ \commentib{The notation is wrong. There is no implications ($\rightarrow$) between functions. The discretization process is not a transition system. And this symbol is employed for transformation, but in respect to the domain and counterdomain.}
where the poles $\hat{\lambda}_i=e^{-\lambda_iT} : \hat{\lambda}_i \in G(Z) \wedge \lambda_i \in G(S)$ \commentib{This notation is wrong. G(s) (lowercase 's' and not S) is a function in the complex frequency domain, it is not a set. Consequently, the set membership notation $\in$ cannot be employed. It is valid for G(z) too. } are derived from \eqref{eq:discretize}.
Two remarks are worth mentioning regarding the above.
\begin{remark} 
The above statement is only valid if the sampling frequency is above the Nyquist criteria, since aliasing could cause 'phantom poles' to appear otherwise. 
\end{remark}
\begin{remark}
The witnessed maximum amplitude of the discrete signals $x_k,y_k$ may be smaller to that of $x(t),y(t)$ due to synchronism at fraction-frequency sampling.
This means that reasoning about the statespace must consider the effects of this possibility as well of the case of maximal inputs from the continuous specification.
\end{remark}
Since \eqref{eq:discretization} is a bisimulation of \eqref{eq:dynamical}, we may use the semantics in section \ref{sec:model_semantics} 
to model continuous dynamical systems.

\section{LTI representations of ARMAX models}

Let us have a discrete time SISO system with an $n^{th},m{^th} : n\geq m$ order armax model
$$y[k]=\sum_{i=1}^n a_iy[k-i]+\sum_{i=0}^m b_iu[k-i]$$ \commentib{It is not an armax model. There is not a moving average noise component. It is an ARX, there are only autoregressive and exogenous terms.}
where $y$ is the output of the system and $u$ its input.
The equivalent LTI dynamics of such a model are:
\begin{align}
\vec{x}_k=&\vec{A}\vec{x}_{k-1}+\vec{B}u_k : \vec{x}_k=[y_{k-n}\ \hdots y_{k-1}\ y_{k}]^T\\
y_k=&\vec{C}\vec{x}_k + b_0u_k\nonumber\\
\vec{A}=&\left[
\begin{array}{ccccc}
0&1&0&\cdots&0\\
0&0&1&\cdots&0\\
\vdots&\vdots&\vdots&\ddots&\vdots\\
0&0&0&\cdots&1\\
-a_n&-a_{n-1}&-a_{n-2}&\cdots&-a_1
\end{array}\right],
\vec{B}=\left[
\begin{array}{c}
0\\0\\ \vdots\\ 0\\ 1
\end{array}\right]\nonumber\\
\vec{C}=&[b_n-a_nb_0\ b_{n-1}-a_{n-1}b_0 \cdots b_1-a_1b_0] : b_{i \in (m\ n]}=0\nonumber
\end{align}

\section{Related works}

\paragraph{CEGIS}

Program synthesis is the problem of computing correct-by-design programs
from high-level specifications, and algorithms for this problem have made
substantial progress in recent years.  One such
approach~\cite{itzhaky2010simple} inductively synthesizes invariants to
generate the desired programs.

Program synthesisers are an ideal fit for synthesis of parametric
controllers since the semantics of programs capture effects such as FWL
precisely.  In~\cite{DBLP:conf/cdc/RavanbakhshS15}, the authors use CEGIS
for the synthesis of switching controllers for stabilizing continuous-time
plants with polynomial dynamics.  The work extends to its application on
affine systems, finding its major challenge in the hardness of solving
linear arithmetic with the state-of-the-art SMT solvers.  Since this
approach uses switching states instead of linear dynamics in the digital
controller, it entirely circumvents the FWL problem.  It is also not
suitable for the kind of control we seek to synthesize.  We require a
combination of a synthesis engine with a control verification tool that
addresses the challenges presented here in the form of FWL effects and
stability measures for LTI SISO controllers.  We take the former
from~\cite{DBLP:conf/lpar/DavidKL15} and the latter from~\cite{daes20161}
while enhancing the procedure by evaluating the quantization effects of the
Hardware interfaces (ADC/DAC) to obtain an accurate discrete-time FWL
representation of the continuous dynamics.

\bibliographystyle{abbrv}
\bibliography{paper}  
%\begin{thebibliography}{4}
%\end{thebibliography}


\end{document}
