
%%%%%%%%%%%%%%%%%%%%%%% file typeinst.tex %%%%%%%%%%%%%%%%%%%%%%%%%
%
% This is the LaTeX source for the instructions to authors using
% the LaTeX document class 'llncs.cls' for contributions to
% the Lecture Notes in Computer Sciences series.
% http://www.springer.com/lncs       Springer Heidelberg 2006/05/04
%
% It may be used as a template for your own input - copy it
% to a new file with a new name and use it as the basis
% for your article.
%
% NB: the document class 'llncs' has its own and detailed documentation, see
% ftp://ftp.springer.de/data/pubftp/pub/tex/latex/llncs/latex2e/llncsdoc.pdf
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\documentclass[runningheads,a4paper]{llncs}

\usepackage{amssymb}
\usepackage{amsmath}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{framed}
\usepackage{listings}
\usepackage{algorithm,algpseudocode}
\usepackage{microtype}

\usepackage{todonotes}
\usetikzlibrary{positioning, automata, shapes.arrows, calc, shapes, arrows}
\usetikzlibrary{patterns}


\newcommand{\addtodo}[1]{{\color{red} TODO: #1}}
\newcommand{\commentib}[1]{{\color{blue} [IB: #1]}}
\newcommand{\mat}[1]{\boldsymbol{#1}}

\usepackage{url}
%\urldef{\mailsa}\path|{alfred.hofmann, ursula.barth, ingrid.haas, frank.holzwarth,|
%\urldef{\mailsb}\path|anna.kramer, leonie.kunz, christine.reiss, nicole.sator,|
%\urldef{\mailsc}\path|erika.siebert-cole, peter.strasser, lncs}@springer.com|    
\newcommand{\keywords}[1]{\par\addvspace\baselineskip
\noindent\keywordname\enspace\ignorespaces#1}

\begin{document}

\newcommand\tool{{\sf DSSynth}\xspace}

\mainmatter  % start of an individual contribution

% first the title is needed
\title{Automated Formal Synthesis of Digital Controllers for State-Space Physical Plants} 

% a short form should be given in case it is too long for the running head
%\titlerunning{Lecture Notes in Computer Science: Authors' Instructions}

% the name(s) of the author(s) follow(s) next
%
% NB: Chinese authors should write their first names(s) in front of
% their surnames. This ensures that the names appear correctly in
% the running heads and the author index.
%
%\author{Alfred Hofmann%
%\thanks{Please note that the LNCS Editorial assumes that all authors have used
%the western naming convention, with given names preceding surnames. This determines
%the structure of the names in the running heads and the author index.}%
%\and Ursula Barth\and Ingrid Haas\and Frank Holzwarth\and\\
%Anna Kramer\and Leonie Kunz\and Christine Rei\ss\and\\
%Nicole Sator\and Erika Siebert-Cole\and Peter Stra\ss er}
%
%\authorrunning{Lecture Notes in Computer Science: Authors' Instructions}
% (feature abused for this document to repeat the title also on left hand pages)

% the affiliations are given next; don't give your e-mail address
% unless you accept that it will be published
%\institute{Springer-Verlag, Computer Science Editorial,\\
%Tiergartenstr. 17, 69121 Heidelberg, Germany\\
%\mailsa\\
%\mailsb\\
%\mailsc\\
%\url{http://www.springer.com/lncs}}

%
% NB: a more complex sample for affiliations and the mapping to the
% corresponding authors can be found in the file "llncs.dem"
% (search for the string "\mainmatter" where a contribution starts).
% "llncs.dem" accompanies the document class "llncs.cls".
%

%\toctitle{Lecture Notes in Computer Science}
%\tocauthor{Authors' Instructions}
\maketitle


\begin{abstract}
This work presents a sound and automated approach to synthesise 
digital feedback control architectures for physical plants represented 
as linear, time invariant models. Models are encompassed by dynamical 
equations with inputs, evolving over a continuous state space describing 
the evolution of the physical variables of the system.  The approach is divided 
in two main parts, brought together by a counter-example guided inductive 
synthesis (CEGIS) loop, as follows. First, we devise a static feedback controller 
that stabilises the system; then, we verify its potential safety by means of either 
of the following approaches: forward reachability analysis via unfolding of the dynamics, 
or invariant set generation via abstract acceleration;  
further, if the above step fails, we loop back and invoke a CEGIS call 
to seek alternative stabilising feedbacks, benefiting from the obtained counter-examples 
to safety. 

The approach is proven sound by accounting for errors due to the digitalisation of signals that are manipulated by the controller block.  
The proposed synthesis approaches and a developed tool are evaluated considering 
a set of intricate physical plant models taken from the digital control literature.
\keywords{
State-space dynamical models of physical systems; 
Digital controllers; 
Analogue-to-digital converters; 
Time sampling; 
Quantisation; 
Fixed-point arithmetic; 
CEGIS; 
safety requirements. 
}
\end{abstract}


%-------------------------------
\section{Introduction}
%-------------------------------

Linear Time Invariant (LTI) control models represent a broad class of dynamical systems
%modern embedded software, performing highly non-trivial control tasks,
with significant impact in numerous application areas such as
the life sciences, robotics, and engineering~\cite{astrom1997computer,Franklin15}.
Control synthesis for LTI is broadly investigated, 
however the use of digital control architectures adds new challenges due to 
%exacerbated by specific artefacts,  
the effects of finite-precision arithmetic, time discretization, and quantisation noise, which are typically introduced 
by Analogue-to-Digital (A/D) and Digital-to-Analogue (D/A) conversion.  
Whilst the research on digital control is well developed~\cite{astrom1997computer}, 
automated and sound control synthesis is a challenging task. 
%Thus, the programming is a key barrier to broad adoption of digital control, 
%and requires considerable expertise.

Whilst there is a vast literature on validation of control systems,
the subject of control synthesis has been somewhat restricted in the
properties it explores.  Traditionally, this focuses mainly on stability %, working typically on continuous domains
\cite{DBLP:journals/corr/AbateBCCDKK16,sadabadi2016static}, or using switched
models~\cite{DBLP:conf/emsoft/RavanbakhshS16}.
Reachability tools are
also used when discretizing the state-space for verification and
parametric synthesis~\cite{cimatti2013parameter}.

In this work, we propose the synthesis of \emph{safe} control algorithms for
LTI models taking into consideration the continuous domain of the plant, 
alongside the discrete domain of the controller and the hybrid elements that relate them.  
%% In this paper, we synthesize controllers for hybrid
%% closed-loop systems, i.e., software-implemented embedded controllers along
%% with a model of their physical environment (the plant), that are
%% \emph{safe}.
Due to the complexity of such systems, in this particular work we focus
on linear models with known  implementation features (e.g., number of bits, fixed-point
arithmetic) %\addtodo{[clarify next] with known configurations} 
and perform %parametric 
synthesis of safe digital controllers.

We describe and evaluate two approaches for synthesizing digital controllers 
for state-space physical plants. Both approaches consider a counterexample 
guided inductive synthesis (CEGIS) loop. In the first approach, 
we devise a digital controller that stabilises the system; then, we verify its 
potential safety by unfolding the dynamics of the system and checking for 
a completeness threshold. \textcolor{red}{Dario: Can you please briefly explain your approach?
In the second approach,...}

\textcolor{red}{we have to connect both paragraphs...}

To this end, we formalise the notion of solution generalisation for
Counter-Example Guided Inductive Synthesis (CEGIS), which makes use 
of abstraction refinement in order to achieve scalability.
This strategy enables the inductive generalisation engine inside CEGIS
to look for candidate solutions in a reduced solution space.  

\addtodo{We have to summarise our main contributions here}

%-------------------------------
\section{Related work}
\label{sec:relw}
%-------------------------------

\paragraph{CEGIS}

Program synthesis is the problem of computing correct-by-design programs
from high-level specifications; algorithms for this problem have made
substantial progress in recent years.  One such
approach~\cite{itzhaky2010simple} inductively synthesises invariants to
generate the desired programs.

Program synthesizers are an ideal fit for synthesis of %parametric
controllers since the semantics of programs capture effects such as FWL
precisely.  In~\cite{DBLP:conf/cdc/RavanbakhshS15}, the authors use CEGIS
for the synthesis of switching controllers for stabilising continuous-time
plants with polynomial dynamics.  The work extends to its application on
affine systems, finding its major challenge in the hardness of solving
linear arithmetic with the state-of-the-art SMT solvers.  Since this
approach uses switching states instead of linear dynamics in the digital
controller, it entirely circumvents the FWL problem.  It is also not
suitable for the kind of control we seek to synthesise.

%\textcolor{red}{Cristina: can you please revise this sentence:
Moreover, in \cite{DBLP:conf/emsoft/RavanbakhshS16} the same authors 
use a CEGIS-based approach for synthesising continuous-time switching
controllers that guarantee Reach While Stay properties of closed
loop systems, i.e., properties that specify a set of goal states and safe states.%}. 
The solution is based on synthesising control Lyapunov
functions for switched systems, that yield switching controllers with
a guaranteed minimum dwell time in each mode.

In \cite{DBLP:journals/corr/AbateBCCDKK16}, Abate et al.  focus on
synthesising stabilising controllers for continuous plants
by exploiting advantage in bit-accurate verification of software-implemented 
digital control~\cite{Bessa16}.  While they also make use of a CEGIS-based 
technique, their approach is restricted to synthesising controllers for hybrid 
closed-loop systems that are stable and only consider transfer function models.  
In contrast, in the current paper, we consider a state-space
representation of the physical system, which allows us to synthesise controllers that
make the closed-loop system \emph{safe} as well as stable.  Moreover, 
a key aspect of the second approach we evaluate
is that we integrate abstraction
refinement inside the CEGIS loop.

The tool Pessoa~\cite{mazo2010pessoa} is a MatLab toolbox that synthesises correct-by-design
embedded control software. It is based on the principle of describing a physical system
as an equivalent finite-state machine and computing reachability over the finite-state 
machine. Pessoa can synthesise safe embedded controller software for a range of properties based on a safety specification over state
values, as well as specification on characteristic functions of the controller. 
However, Pessoa does not have native inclusion of the ADC/DAC quantization error needed for
synthesising a fixed-point digital controller.

We use a combination of a synthesis engine with a control
verification tool that addresses the challenges presented here in the
form of FWL effects and stability measures for LTI SISO controllers.

We take the former from~\cite{DBLP:conf/lpar/DavidKL15}. The verification engine, for
the first approach we present, performs bounded model checking of control properties,
based on~\cite{Monteiro16}, but 
enhanced to include evaluation of quantization effects and safety properties
over the state space. In the second approach, we use a verification engine
based on abstract acceleration~\cite{cattaruzza2015unbounded} than avoids the explicit 
unwinding the transition system necessarily for the first approach.





\paragraph{Discretization Effects}

The classical approach to control synthesis has often disregarded
quantization as a minimal effect, thus proving unsound in the case of digital control systems.
Modern techniques focus on different elements of the discretization effect, including delayed
response~\cite{Duggirala2015}, and Finite Word Length (FWL) semantics with
the goal to either verify (e.g.~\cite{daes20161}) or optimise
(e.g.~\cite{oudjida2014design}) given implementations.

There are two different problems that arise from FWL semantics.  The first
is the error in the dynamics caused by the inability to represent the exact
state of the physical system while the second relates to rounding errors
during computation.  In~\cite{fialho1994stability}, a stability measure
based on the error of the digital dynamics ensures that the deviation
introduced by FWL does not make the digital system unstable.  A more recent
approach~\cite{DBLP:journals/automatica/WuLCC09} uses $\mu$ calculus to
directly model the digital controller so that the selected parameters are
stable by design.  The analyses
in~\cite{DBLP:conf/hybrid/RouxJG15,DBLP:conf/hybrid/WangGRJF16} rely on an
invariant computation on the discrete system dynamics using Semi-Definite
Programming (SDP).  While the former uses BIBO properties to determine
stability, the latter uses Lyapunov-based quadratic invariants.  In both
cases, the SDP solver uses floating-point arithmetic and soundness is
checked by bounding the error.  An alternative approach is taken
by~\cite{park2016scalable}, where the verification of existing code is
performed against a known model by extracting an LTI model of the code
through symbolic execution.  In order to account for rounding errors, an
upper bound is introduced in the verification phase.
The work in \cite{picasso2003stabilization,picasso2002construction} introduces
attractive invariant sets as a mechanism to bound the quantization error effect
on stabilisation as an invariant set that always converges toward the controllable
set. In a similar fashion, \cite{liberzon2003hybrid} evaluates the dynamics of the
quantization error and binds their trajectory to a known region over a finite
period of time. This technique works for both linear and non-linear systems.
This paper uses an approach that projects the maximum effect of the noise over
an unbounded time and uses it as a `buffer' region for the safety specification.

%\addtodo{[Move material from \ref{sec:rw} here]}

%-------------------------------
\section{Preliminaries}
\label{sec:preliminaries}
%-------------------------------

%-------------------------------
\subsection{State-space representation of physical systems} 
\label{ssec:ssrepresentation}
%-------------------------------

We consider models of physical plants expressed as ordinary differential equations (ODEs), 
with full state information (namely where we have access to all the model variables):  
%
\begin{align}
\label{eq:ode}
\dot{x}(t) = Ax(t)+ B u(t), \quad x \in \mathbb{R}^{n}, u \in \mathbb{R}^m, A \in \mathbb{R}^{n \times n}, B \in \mathbb{R}^{n \times m}, 
\end{align}
where $t \in \mathbb R_0^+$, 
where $A$ and $B$ are matrices that fully specify the continuous plant, 
and with initial states set as $x(0)$. 
Eq.~\eqref{eq:ode} is soundly discretized in time (as shown in the Appendix) into %\textcolor{red}{What is subscript ``d''?}
%
\begin{align}
\label{eq:plant}
x_{k+1} = A_d x_k+ B_d u_k. 
\end{align} 
where $k \in \mathbb N$, 
and with initial state $x_{0}=x(0)$. $A_d$ and $B_d$ denote the discretized matrices of $A$ and $B$, the plant dynamics. 
Later, we will deal with the issue of variable quantisation, as introduced by the ADC and DAC blocks.  

%
\begin{figure*}[htb]
\centering

\tikzset{add/.style n args={4}{
    minimum width=6mm,
    path picture={
        \draw[circle] 
            (path picture bounding box.south east) -- (path picture bounding box.north west)
            (path picture bounding box.south west) -- (path picture bounding box.north east);
        \node[draw=none] at ($(path picture bounding box.south)+(0,0.13)$)     {\small #1};
        \node[draw=none] at ($(path picture bounding box.west)+(0.13,0)$)      {\small #2};
        \node[draw=none] at ($(path picture bounding box.north)+(0,-0.13)$)    {\small #3};
        \node[draw=none] at ($(path picture bounding box.east)+(-0.13,0)$)     {\small #4};
        }
    }
 }

\resizebox{1.0\textwidth}{!}{
 \begin{tikzpicture}[scale=0.6,-,>=stealth',shorten >=.2pt,auto,
     semithick, initial text=, ampersand replacement=\&,]

  \matrix[nodes={draw, fill=none, shape=rectangle, minimum height=.2cm, minimum width=.2cm, align=center}, row sep=.6cm, column sep=.6cm] {
    \node[draw=none] (r) {$r_k$};
    
   \& \node[circle,add={-}{+}{}{}] (circle) {};
   \node[draw=none] (ez) at ([xshift=1cm,yshift=.15cm]circle)  {$u_k$};
   \node[rectangle,draw,minimum width=1cm,minimum height=1cm] (Kd) at ([xshift=0,yshift=-1.5cm]circle)  {\sc $\mat{K}_d$};
   \coordinate (kdsouth) at ([yshift=-2cm]Kd);
      
   
   \& complexnode/.pic={ 
      \node[rectangle,dashed,draw,minimum width=3cm,minimum height=1.6cm,label=\textbf{DAC}] (dac) {};
     \node[circle,add={+}{+}{}{},fill=gray!20] (q2) at ([xshift=-.65cm]dac.center) {};
     \node[draw=none] (q2t)  at ([yshift=.55cm]q2) {{\sc Q2}};
     \node[draw=none] (v2)  at ([yshift=-1.5cm]q2) {$\nu_2$};
     \node[fill=gray!20] (zoh) at ([xshift=.65cm]dac.center) {\sc ZOH};
   }   

   \& complexnode/.pic={ 
      \node[rectangle,dashed,draw,minimum width=8cm,minimum height=3.5cm,label=\textbf{Plant}] (plant)  at ([yshift=-.5cm]dac.center) {};
      \node[rectangle,draw,minimum width=1cm,minimum height=1cm] (B) at ([xshift=-2.5cm,yshift=.5cm]plant.center)  {\sc $\mat{B}$};
      \node[draw=none] (u) at ([xshift=-1cm,yshift=.15cm]B)  {$u(t)$};
      \node[circle,add={+}{+}{}{}] (p1) at ([xshift=-1.3cm,yshift=.5cm]plant.center) {};
      \node[draw=none] (xdot) at ([xshift=.85cm,yshift=.15cm]p1)  {$\dot{\vec{x}}(t)$};   
      \node[rectangle,draw,minimum width=1cm] (int) at ([xshift=.5cm,yshift=.5cm]plant.center) {\sc $\int$};
      \coordinate (xsouth) at ([xshift=1cm]int);
      \node[draw=none] (x) at ([xshift=1cm,yshift=.15cm]int)  {$\vec{x}(t)$};
      \node[rectangle,draw,minimum width=1cm,minimum height=1cm] (A) at ([xshift=.5cm,yshift=-1cm]plant.center)  {\sc $\mat{A}$};
      \coordinate (aeast) at ([xshift=1cm]A);
      \coordinate (awest) at ([xshift=-1.8cm]A);
    }   
        
   \& complexnode/.pic={ 
     \node[rectangle,dashed,draw,minimum width=3.5cm,minimum height=1.6cm,label=\textbf{ADC},] (adc) {};
     \draw[] ([xshift=-1cm]adc.center) -- ++(0.5,0.2cm);
     \coordinate (switch1) at ([xshift=-1cm]adc.center);
     \coordinate (switch2) at ([xshift=-0.4cm]adc.center);
     \node[circle,add={+}{+}{}{},fill=gray!20] (q1) at ([xshift=.6cm]adc.center) {};
     \node[draw=none] (q2t)  at ([yshift=.55cm]q1) {\sc Q1};
     \node[draw=none] (v1)  at ([yshift=-1.5cm]q1) {$\nu_1$};
     \node[draw=none] (y) at ([xshift=.85cm,yshift=.15cm]q1)  {$\vec{x}_k$};       
     \coordinate (ykeast) at ([xshift=1.9cm]q1);
     \coordinate (yksouth) at ([xshift=1.9cm,yshift=-3.5cm]q1);
   } 
   \& \coordinate (aux1);
   \& \\
  };

  \path[->] (v1) edge (q1.south);
  \path[->] (v2) edge (q2.south);
  \path[->] (r) edge (circle.west);
  \path[->] (circle.east) edge (q2.west);
  \path       (q2.east) edge (zoh.west);
  \path[->] (zoh.east) edge (B.west);
  \path
   (B.east) edge (p1.west)
   (p1.east) edge (int.west)
   (xsouth) edge (aeast)
   (aeast) edge (A.east)
   (A.west) edge (awest)
   (awest) edge (p1.south)
   (int.east) edge (switch1.west)
   (switch2) edge (q1.west);
  \path
   (q1.east) edge (ykeast)
   (ykeast) edge (yksouth)
   (yksouth) edge (kdsouth);
  \path[->]  (kdsouth) edge (Kd.south);
  \path (Kd.north) edge (circle.south);
 \end{tikzpicture}
}
 \caption{Closed-loop digital control system \label{fig:digitalsystem}}
\end{figure*}
%-------------------------------
\subsection{Controller synthesis via state feedback}
\label{ssec:statefeedbackcontrol}
%-------------------------------

Models \eqref{eq:ode} and \eqref{eq:plant} depend on external non-determinism in the form of input signals $u (t), u_k$, respectively. 
Feedback architectures can be employed to affect the properties and behaviours of the continuous process (the plant) of interest.   
%reduce the effect of parametric uncertainties and attenuate the effects of noise and disturbance. 
We are interested in the synthesis of digital feedback, 
as implemented on modern FPGAs or ICs. 
The most basic feedback architecture is the state feedback, 
where the control action $u_k$ (notice we work with the discretized signal) is computed by: 
%
\begin{equation}
\label{eq:controlaction}
u_k = r_{k} - K x_k. 
\end{equation}
%
Here $K \in \mathbb{R}^{m \times n}$ is a feedback gain matrix, 
and $r_{k}$ is a reference signal (again digital).   
%
The closed-loop model then takes the form 
\begin{align}
\label{eq:closedloopss}
x_{k+1} = ( A_d - B_d K ) + B_d r_k.
\end{align}
The gain matrix $K$ can be set so that the closed-loop digitalised dynamics are shaped as desired, 
for instance according to a specific stability goal or around a specific dynamical behaviour \cite{astrom1997computer}. 
As argued later, in this work, we will target more complex objectives, such as quantitative safety requirements that are not typical in the digital control literature. 

%-------------------------------
\subsection{Stability of closed-loop systems}
\label{ssec:stability}
%-------------------------------

%\addtodo{[Here discuss Jury criterium for DISCRETE-TIME models - a simplified version of the first part of what is now in Section \ref{sec:cof_verification} (with no quantisation noises yet).]}  

Asymptotic stability boils down to Lyapunov stability and convergence to an equilibrium point\cite{Astrom08} %\todo{add reference}.  
Lyapunov stability requires that model trajectories remain in a neighbourhood of the equilibrium point. 
In the case of closed-loop LTI models as in \eqref{eq:closedloopss}, 
the equilibrium point is the origin (if the reference is equal to zero), or an offset thereof.  
In this paper, we consider systems with a reference signal equal to zero. 

A discrete-time system as \eqref{eq:closedloopss} is asymptotically stable if and only if all the roots 
of the characteristic polynomial ({\it i.e.}, the eigenvalues of the closed-loop matrix $A_d - B_d K$) are inside the unity circle in the complex plane, 
{\it i.e.} iff their absolute values are less than one~\cite{astrom1997computer}. 
In this paper, we express the stability specification $\phi_{stability}$ in terms of a check known as Jury's criterion \cite{fadali}. 
This condition boils down to an easy algebraic formula to select the entries of matrix $K$, 
so that the closed-loop dynamics are shaped as desired. 
A detailed description of this specification can be found in the Appendix~\ref{sec:appendix-stability}. 

%-------------------------------
\subsection{Safety specifications for dynamical systems}
\label{ssec:safety}
%-------------------------------

As mentioned earlier, 
in this work we are not bound to the synthesis of digital stabilising controllers -- 
a well known task in the literature on digital control system -- 
but target safety requirements with an overall approach that is sound and automated. 
More specifically, 
we require that the closed-loop system \eqref{eq:closedloopss} meets given safety specifications. 
A safety specification raises a requirement on the states of the model, 
such that the feedback controller (namely the choice of the gains in $K$) 
must ensure that the states never exist such requirement. 
Note that a stable, closed-loop system is not necessarily a safe system: 
indeed, the state values may leave the safe whilst they converge to the equilibrium, 
which is typical in the case of oscillatory dynamics. 

In this work, the safety property represented by $\phi_{safety}$ is encoded as follows: 
%
\begin{equation}
\label{eq:safetyliteral}
\phi_{safety}\iff \forall k\geq 0, \bigwedge_{i=1}^{n}{\underline{x_{i}} \leq x_{i,k} \leq \overline{x_{i}}},
\end{equation}
%
%\addtodo{We consider $x_{i}^{-}$ and $x_{i}^{+}$ to be -1 and 1, respectively.}
where $\underline{x_{i}}$ and $\overline{x_{i}}$ are lower and upper bounds for the $i$-th coordinate $x_{i}$ of state $x\in \mathbb R^n$ at the $k$-th instant, respectively. 
This means that the states will always be within the $n$-dimensional hyper-box. 
%, which is typically defined by the safety specification.

Furthermore, 
it is practically relevant to consider constraints on the input signal $u_{k}$, 
which we assume has given bounds $\overline{u}$ and $\underline{u}$, 
such that ${\underline{u} \leq u_{k} \leq \overline{u}},\forall k\geq 0$.  
In practice, 
this means that the control input saturates in view of physical constraints. 


%%%-------------------------------
%%\subsection{Digital implementation of feedback controller}
%%\label{ssec:quantizationerror}
%%%-------------------------------
%%
%%\addtodo{HERE add a figure similar to Fig. \label{fig:observersystem} to explain digital features of controller.} 
%%
%%\addtodo{[The remainder of the section needs to be updated. ]}
%%The output and measurable of the plant is being sampled by an ADC, and since the full state of the
%%plant cannot be witnessed directly, the controller software includes an observer that 
%%estimates the state of the plant (see appendix for details on how such an observer
%%is constructed). In this work, we are assuming that all the states measurements are available for the state feedback purpose, and the state observer design may be disregarded.  
%%\addtodo{[Unclear what the remainder is for: ]}
%%We further presume that there are small tolerances in the system 
%%described in the following form
%%%
%%\begin{align*}
%%\mat{A} \in \mathcal{G}_A=\mat{S}\mat{J}\mat{S}^{-1} : \mat{J} \in \mathcal{G}_J
%%\end{align*}
%%\commentib{What is S?}
%%
%%Where $\mathcal{G}_J$ is a collection of eigenvalue ranges that define the frequency response of the system.
%%We presume that the internal model of the plant is an ARMA model, modified by a
%%state transform that has no tolerances. Tolerances in the eigenvectors will manifest themselves
%%as tolerances in the canonical forms outside of the row/column of interests and complicate the 
%%evaluation. Whilst it is possible to address these with this methodology, we will focus on the case
%%above for simplicity.

% \addtodo{HERE add a figure similar to Fig. \label{fig:observersystem} to explain digital features of controller.} 

% \addtodo{[The remainder of the section needs to be updated. ]}
% The output and measurable of the plant is being sampled by an ADC, and since the full state of the
% plant cannot be witnessed directly, the controller software includes an observer that 
% estimates the state of the plant (see appendix for details on how such an observer
% is constructed). In this work, we are assuming that all the states measurements are available for the state feedback purpose, and the state observer design may be disregarded.  
% \addtodo{[Unclear what the remainder is for: ]}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{Numeric representations and soundness} 
\label{sec:numeric_rep}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++







The 
%systems and 
models we consider have two sources of error due to numeric representation. 
The first is the numeric error introduced by the fixed-point numbers employed to model the plant, i.e. to represent the plant dynamics $A_d$, $B_d$ and its states. 
The second is the numeric error introduced by the digital controller, 
which 
%uses an analogue-to-digital converter to read the states as a fixed-point number and performs operations in this domain. 
performs operations in the domain of fixed-point numbers. 
In this section we formally outline the errors introduced by fixed-point representation of numbers. 
In further sections we will differentiate between these two errors, 
by referring to them as the \emph{plant error} and the \emph{digital controller error} respectively. 

Let $\mathbb{R} \langle I,F \rangle$ \todo{notice this notation differs from the one used above} be a fixed point domain with $I$ bits representing the integer part 
and $F$ bits representing the decimal part \todo{why R, comment on that.}. The smallest number that can be represented in this domain is $c_m=2^{-F}$.
The following approximation errors will arise:
\begin{enumerate}
\item {\bf Truncation:}
Let $\mathcal{F}\langle I,F \rangle(\cdot) : \mathbb{R} \rightarrow \mathbb{R}\langle I,F \rangle, \tilde x=\mathcal{F}\langle I,F \rangle(x) = x-\delta_T : \delta_T=x\ \%_{c_m}\ \tilde x$, where $\%_{c_m}$ is the modulus operation performed on the last bit.
So $\delta_T$ is the truncation error and it will propagate across operations.
\item {\bf Rounding:}
The following errors appear in simple operations:
\begin{enumerate}
\item Addition/Subtraction: these operations only propagate errors coming from truncation of the operands. 
\todo{the following maths is loose. fix as follows: define terms with their domain. define operation. apply operator $\mathcal{F}$ above. derive bound. }
$c_1\pm c_2= c_3 + \delta_3 :|\delta_3| \leq |\delta_{T1}| + |\delta_{T2}|$ 
\item Multiplication: $c_1 * c_2= c_3 + \delta_3 :|\delta_3| \leq |\delta_{T1}*c_2| + |\delta_{T2}*c_1| + c_m$  \todo{same as above.}
\item Division will not be applied in these implementations. \todo{why not? comment further.}
\end{enumerate}

\item {\bf Overflow:}
  %Another source of error introduced by Finite Word Length representations is that of overflow.
  The finite word length set a
maximum representable number in the domain \todo{what is next? a domain? define formally, no back-of-the-envelope mathsy stuff.} ($\pm (2^{I-1}+1-2^{-F})$), which means that any number outside this range
cannot be represented by the domain. Our tool currently assumes no saturation
function and verifies that no state overflows.
\end{enumerate}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
%\subsection{Fixed word length effects on matrix multiplications}
%\label{sec:cof_fwl}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


\todo{yes, please reformat the discussion below so that it fits the discussion above. }

Thus far we have presented a verification procedure for a digitalised plant in a continuous space (\emph{ie} the
range of the quantisers is still $\mathbb{R}$. The next step we must realise is that the controller 
exists in a digital program, hence its domain is $\mathbb{R}\langle I,F\rangle$. We have $\mat{A},\mat{B},\vec{x} \in \mathbb{R}^*$, $\mat{K}_d,\vec{u},\hat{\vec{x}}=\mathcal{F}\langle I,F \rangle(\vec{x}) \in \mathbb{R}\langle I,F\rangle^*$
Where $*$ represents the appropriate dimension for each matrix/vector.
Unfortunately this means that although the closed loop dynamics are in the reals, they suffer from
the fixed word restrictions in their composing elements.
Apart from the quantisation errors $q_1,q_2$ there are rounding errors in the calculation of $u_k$. 
These will introduce a new source of quantisation noise which we may denote $\vec{\nu}_3 \in [-q_3\ \ q_3]$.
The error in $\vec{u}$ corresponds of the multiplication of $\mat{K}_d\hat{\vec{x}}$, hence $q_3=\overline{\delta}_u=(|\mat{K}|_1+1)c_m$

\bigskip

\subsubsection{Effect on safety specification and stability}
The states values must be computed considering the digital controller error, i.e., the error introduced by the ADC and the digital controller. 
%, and the digital reference signal. 
%In this paper, we consider systems with a reference signal equal to zero. 
%the FWL effects in all operations related to the control action~\eqref{eq:controlaction} 
%and disregarding it in the state equation~\eqref{eq:plant}.
Thus, the states are computed using the following equations. We use $\mathcal{F}_{\langle I_c,F_c \rangle}$ \todo{explain and clarify notation.}
to to denote numbers represented with the precision of the digital controller. All other numbers
are represented with the precision of our plant model:
%
\begin{align*}
u_{k}&=-(\mathcal{F}_{\langle I_c,F_c \rangle}(K)\cdot\mathcal{F}_{\langle I_c,F_c \rangle}(x_{k})).  
%\\ x_{k+1}&=A_d x_{k} + B_du_{k}
\end{align*}

We note that the effect on stability due to the fixed-word-length error is that the system may, instead of converging to the desired equilibrium point, converge to a point that is $\delta$ away from the desired equilibrium point, see Appendix. In this paper, we are concerned with \emph{safe} controllers and therefore concerned only that the system converges to a point within the safety specification. Hence, it is sufficient to synthesise a stable controller based on infinite precision, and then verify safety. 


%% %-------------------------------
%% \section{Counter-Example Guided Inductive Synthesis with solution generalisation}
%% %-------------------------------

%% This technique relies on parametrising the target language, which
%% induces a lattice of progressively more expressive languages 
%% \textcolor{red}{Cristina: Citation?}.  We
%% start by attempting to synthesise a program at the lowest point on
%% this lattice and increase the parameters of the language until we
%% reach a point at which the synthesis succeeds. As well as giving us an
%% automatic search procedure, this parametrisation greatly increases the
%% efficiency of our system since languages low down the lattice are very
%% easy to decide safety for (i.e. the validation oracle finds an answer
%% fast). If a program can be synthesised in a low-complexity language,
%% the whole procedure finishes much faster than if synthesis had been
%% attempted in a high-complexity language.

%% \textcolor{red}{Cristina: How does this section relate to our control-synthesis work? 
%% This is text is too generic...}

%% \begin{figure}
%% \centering
%% \hspace*{-1cm}
%% \begin{tikzpicture}[scale=0.3,->,>=stealth',shorten >=.2pt,auto, semithick, initial text=, ampersand replacement=\&,]
%%   \matrix[nodes={draw, fill=none, shape=rectangle, minimum height=.2cm, minimum width=.2cm, align=center
%% },
%%           row sep=1cm, column sep=1.5cm] {
%%    \coordinate (aux1);
%%    \& \coordinate (aux2);
%%    \& ;\\
%%    \node[fill=yellow!20,align=center] (synth) {{\sc inductive}\\{\sc generalisation}};
%%    \&
%%    complexnode/.pic={ 
%%      \node[rectangle,draw,dashed,
%% 	minimum width=6.7cm,
%% 	minimum height=.8cm,
%% 	label={\sc Validation oracles},] (verif) {};
%%    \node[fill=yellow!20] (verif1) at ([xshift=-2.1cm]verif.center) {{\sc Validate}};
%%    \node[fill=yellow!20,align=center] (verif2) at ([xshift=1.7cm]verif.center) {{\sc validate general}};
%%    } 
%%    \& \node[ellipse, fill=yellow!20] (done) {{\sc Done}};\\
%%    %% \node[fill=yellow!20] (verif) {{\sc ~~~~~~Uncertainty~~~~~~}};
%%    %% \&
%%    %% \node[fill=yellow!20] (verif2) {{\sc ~~~~~~Precision~~~~~~~}};\\
%%    \& \\
%%    \& \\
%%    \node (gp) {Program Search};
%%    \&
%%    complexnode/.pic={ 
%%      \coordinate (aux);
%%    \node (bmc) at ([xshift=-2.1cm]aux.center) {SAT/SMT Solver};
%%    \node (fp)  at ([xshift=1.9cm]aux.center) {SAT/SMT Solver};
%%    }   
%%     \\
%%   };

%%    \path
%%     ([yshift=2em]synth.east) edge node[xshift=-0.7em] {Candidate} ([yshift=2em]verif1.west)
%%     ([yshift=-2em]verif1.west) edge node[xshift=-0.7em] {New input} ([yshift=-2em]synth.east)
%%     (verif1) edge node {Generalise} (verif2)
%%     ([xshift=5em]verif1.south) edge node[align=center] {Candidate} ([xshift=5em]bmc.north)
%%     ([xshift=5em]verif2.south) edge node[align=center] {Candidate} ([xshift=3.8em]fp.north)
%%     ([xshift=-5em]bmc.north) edge node[align=center]  {UNSAT/\\Model} ([xshift=-5em]verif1.south)
%%     ([xshift=-6.2em]fp.north) edge node[align=center]  {UNSAT/\\Model} ([xshift=-5em]verif2.south)
%%     (verif2) edge node {} (done)
%%     ([xshift=5em]synth.south) edge node[align=center] {{\sc Inputs}} ([xshift=5em]gp.north)
%%     ([xshift=-5em]gp.north) edge node[align=center] {No solution/\\Candidate} ([xshift=-5em]synth.south)
%%     (aux1) edge (synth.north);
%%    \path[-]
%%    (verif2.north) edge node[align=center] {} ([xshift=5.6cm]aux2)
%%    ([xshift=5.6cm]aux2) edge node[align=center] {Increase parameters} (aux1);

%% \end{tikzpicture}
%% \caption{The CEGIS loop with solution generalisation\label{fig:CEGIS-multiple-verif}. 
%% \textcolor{red}{Cristina: What is the difference of this figure to that in our HSCC paper?}}
%% \end{figure}

%%   %% \textcolor{red}{LC: Cristina, can you please fix this figure? The text ``candidate'' overlaps with the dotted box.}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\section{CEGIS of Safe Controllers for LTI Systems with Solution Generalisation} 
\label{sec:CEGARIS} 
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
%Abstractly-Refined
In this section we outline the general architecture of the program synthesizer used in both approaches%\todo{which approaches?}. 
We then give the details of the two methods of solution generalisation that we compare; the first checking safety by unwinding the transition relation to a completeness threshold; and the second employing abstract acceleration.
 
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{General architecture of the program synthesizer}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\label{synthesizer-general}
The input specification provided to the program synthesizer is of the form
$\exists \vec{P} .  \forall \vec{x}.  \sigma(\vec{x}, \vec{P})$ where
$\vec{P}$ ranges over functions, $\vec{x}$ \todo{now variables are vectorised, however previously the model variables aren't. please align notation. I do not like to use vectors unless essential, let's say it's a waste of ink in printouts. }
 ranges over ground terms and
$\sigma$ is a quantifier-free formula.  We interpret the ground terms over
some finite domain $\mathcal{D}$.

The design of our synthesizer consists of two phases, an inductive
synthesis phase and a validation phase, which interact via a finite
set of test vectors {\sc inputs} that is updated incrementally.  Given
the aforementioned specification $\sigma$, the inductive synthesis
procedure tries to find an existential witness $\vec{P}$ satisfying
the specification $\sigma(\vec{x}, \vec{P})$ for all $\vec{x}$ in {\sc
  inputs} (as opposed to all $\vec{x} \in \mathcal{D}$).
%
If the synthesis phase succeeds in finding a witness~$\vec{P}$, this
witness is a candidate solution to the full synthesis formula.  We
pass this candidate solution to the validation phase, which checks
whether it is a full solution (i.e., $\vec{P}$ satisfies the
specification $\sigma(\vec{x}, \vec{P})$ for all
$\vec{x}\in\mathcal{D}$).  If this is the case, then the algorithm
terminates.  Otherwise, additional information is provided to the
inductive synthesis phase in the form of a new counterexample that is
added to the {\sc inputs} set and the loop iterates again.

It is worth noting that each iteration of the loop adds a new input to
the finite set $\text{\sc inputs}$ that is used for synthesis.  Given
that the full set of inputs $\mathcal{D}$ is finite, this means that
the refinement loop can only iterate a finite number of times.

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{Synthesis problem: statement (recap) and connection to program synthesis}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

% \todo{The following paragraph has been already stated above. Let us clarify this is a useful repetition to recap things?} 

At this point, we recap the the synthesis problem that we solve in this work:
find a digital controller $K$ (see Eq.~\ref{eq:controlaction})
that makes the closed-loop system safe for 
initial state $x_0$, reference signal $r_k$ and input $u_k$
as defined in Sec.~\ref{ssec:safety}. 
We consider non-deterministic initial states within a specified range
and the reference signal to be set to zero.  
When mapping back to the notation used for describing the general architecture 
of the program synthesizer, the controller $K$ denotes $P$ and 
$(x_0, u_k)$ represents $x$. 
While the controller's precision $\langle I_c,F_c\rangle$ is given, 
we can vary the plant's precision $\langle I_p,F_p\rangle$ such that 
$\mathbb{R}\langle I_p,F_p \rangle \supseteq \mathbb{R}\langle I_c,F_c \rangle$.

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{Solution generalisation} 
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Given the large solution space to be searched during the inductive
synthesis phase, we parametrise the target language, which induces a
lattice of progressively more expressive languages.  This enables us
to start by attempting to synthesise a program at the lowest point on
this lattice and increase the parameters of the language until we
reach a point at which the synthesis succeeds. Whenever we manage to
synthesise a candidate solution at some lower point on the lattice, we
must apply some form of solution generalisation to obtain a full
solution (i.e. a solution in the original search space).

As well as giving us an automatic search procedure, this
parametrisation greatly increases the efficiency of our system since
languages low down the lattice are very easy to decide safety for
(i.e. the validation oracle finds an answer fast). If a program can be
synthesised in a low-complexity language, the whole procedure finishes
much faster than if synthesis had been attempted in a high-complexity
language.


We investigate two different approaches of integrating solution generalisation 
with CEGIS:
\begin{itemize}
\item[1.] The first approach (described in Sec.~\ref{sec:CEGIS-precision-incrementation})
  uses a multi-staged verification phase and performs solution generalisation based on
the plant precision, the number of loop unrollings, 
and the sampling rate. Essentially, it finds a controller for an individual initial state
and input with a bounded time horizon and generalises to all states,
inputs, and time horizons. The safety check is performed in this approach 
via unfolding of the transition system corresponding to the synthesised controller.


%% (with a final verification loop that verifies
%% the continuous system behaviour against the previously verified
%% discrete system bi-simulation)
\item[2.] The second approach (described in Sec~\ref{sec:CEGIS-abstraction-refinement})
  finds a controller for a continuous initial set of states and input
  set, over an abstraction of the continuous dynamics that conforms to
  witness proofs at specific times; it further generalises the
  solution over all times by refining the number of witnesses.  
  In order to perform the safety check, this approach uses abstract acceleration
  \cite{cattaruzza2015unbounded} to compute the controller's set of states. 
  %\todo{clarify use of abstract acceleration. add references.}
\end{itemize}



%% The advantage of the second approcah are that whereas in the first case we use concrete traces from non-deterministic simulations
%% and generalize over continuous sets into an unbounded time, 
%% the abstract acceleration synthesis analyses the system over a generalized state-space (ie it looks at all the states simultaneously), requiring the CEGIS loop to generalize only over the time horizon of the system.

%% \addtodo{Can we come up with some sort of figure that makes it easier to visualise
%% the generalisation step in each approach?}

% In Sec.~\ref{sec:CEGIS-abstraction-refinement} and 
% Sec.~\ref{sec:CEGIS-precision-incrementation}, we explain how we 
% specialise the general CEGIS approach in order to perform solution generalisation.




%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{CEGIS with multi-staged verification}
\label{sec:CEGIS-precision-incrementation}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\begin{figure}[htb]
{\scriptsize
\centering
%\resizebox{.8\textwidth}{!}
{
 \begin{tikzpicture}[scale=0.3,->,>=stealth',shorten >=.2pt,auto, semithick, initial text=, ampersand replacement=\&,]
  \matrix[nodes={draw, fill=none, shape=rectangle, minimum height=.2cm, minimum width=.2cm, align=center
},
          row sep=.6cm, column sep=.9cm] {
   \coordinate (aux1);
   \& \coordinate (aux2);
   \&;\\
   \coordinate (aux3);
   \& \coordinate (aux4);
   \&;\\
   \coordinate (aux5);
   \& \coordinate (aux6);
   \&;\\
   \node[minimum width=1.5cm, minimum height=0.6cm, fill=gray!20] (synth) {{\sc 1.Synthesize}};
   \&
   complexnode/.pic={ 
     \node[rectangle,draw,dotted,
	minimum width=8cm,
	minimum height=1cm,
        pattern=north west lines, pattern color=gray!20,
	label={\sc Verify},] (verif) {};
     \node[minimum width=1cm, minimum height=0.6cm, fill=gray!20] (verif1) at ([xshift=-2.9cm]verif.center) {{\sc 2.Safety}};
     \node[minimum width=1cm, minimum height=0.6cm, fill=gray!20] (verif2) at ([xshift=-0.8cm]verif.center) {{\sc 3.Precision}};
     \node[minimum width=1cm, minimum height=0.6cm, fill=gray!20] (verif3) at ([xshift=1.2cm]verif.center) {{\sc 4.Complete}};
     \node[minimum width=1cm, minimum height=0.6cm, fill=gray!20] (verif4) at ([xshift=3.1cm]verif.center) {{\sc 5.Sampling}};
   } 
   \& \node[ellipse, fill=gray!20] (done) {{\sc Done}};\\
   \& \\
   \node[minimum height=0cm] (gp) {\sf Closed-loop \\ System Search};
   \&
   complexnode/.pic={ 
     \coordinate (aux);
   \node (bmc) at ([xshift=-2.9cm]aux.center) {\sf BMC-based \\Verifier};
   \node (fp)  at ([xshift=-.8cm]aux.center) {\sf Fixed-point \\ Arithmetic\\Verifier};
   \node (sv)  at ([xshift=1.2cm]aux.center) {\sf Completeness\\Verifier};
   \node (cv)  at ([xshift=3.1cm]aux.center) {\sf Sampling\\Verifier};
   }   
    \\
  };

   \path
    ([yshift=2em]synth.east) edge node[xshift=-0.5em,align=center] {$P$} ([yshift=2em]verif1.west)
    ([yshift=-2em]verif1.west) edge node {C-ex} ([yshift=-2em]synth.east)
    ([xshift=-5em]fp.north) edge node[align=center]  {T/F} ([xshift=-5em]verif2.south)
    ([xshift=-5em]sv.north) edge node[align=center]  {T/F} ([xshift=-5em]verif3.south)
    ([xshift=-5em]cv.north) edge node[align=center]  {T/F} ([xshift=-5em]verif4.south)
    ([xshift=5em]verif1.south) edge node[align=center] {$P$} ([xshift=5em]bmc.north)
    ([xshift=5em]verif2.south) edge node[align=center] {$P$} ([xshift=5em]fp.north)
    ([xshift=5em]verif3.south) edge node[align=center] {$P$} ([xshift=5em]sv.north)
    ([xshift=5em]verif4.south) edge node[align=center] {$P$} ([xshift=5em]cv.north)
    ([xshift=-5em]bmc.north) edge node[align=center]  {UNSAT/\\model} ([xshift=-5em]verif1.south)
    (verif) edge node {} (done)
    ([xshift=5em]synth.south) edge node[align=center] {Inputs} ([xshift=5em]gp.north)
    ([xshift=-5em]gp.north) edge node[align=center] {UNSAT/\\$P$} ([xshift=-5em]synth.south)
    (aux1) edge (synth.north);
   \path[-]
   (verif2.north) edge node[align=center] {} ([xshift=-2.7cm]aux6)
   ([xshift=-2.7cm]aux6) edge node[align=center] {Increase Precision} (aux5)
   (verif3.north) edge node[align=center] {} ([xshift=4cm]aux4)
   ([xshift=4cm]aux4) edge node[align=center] {Increase Completeness Threshold} (aux3)
   (verif4.north) edge node[align=center] {} ([xshift=10.5cm]aux2)
   ([xshift=10.5cm]aux2) edge node[align=center] {Increase Sampling Rate} (aux1);

 \end{tikzpicture}
}}
\caption{CEGIS with multi-staged verification}
\label{fig:CEGIS-precision-increment}
\end{figure}

%\subsubsection{Controller synthesis}

The controller synthesis is described in Fig.~\ref{fig:CEGIS-precision-increment}.
One important observation is that, for this approach, we verify and synthesise 
a controller over $k$ time steps. We then compute a completeness threshold, $\overline{k}$,
for this controller, and verify the controller correctness to $\overline{k}$ time steps.
Essentially, $\overline{k}$ represents the number of iterations 
required to sufficiently unwind the closed-loop state-space system 
such that the boundaries are not violated for any $k{>}\overline{k}$
(i.e. it is sufficient to unwind the closed-loop state-space system up to  
$\overline{k}$ in order to ensure that $\phi_{safety}$ holds). 

\medskip

Next, we describe the different phases in Fig.~\ref{fig:CEGIS-precision-increment}
(blocks 1 to 5):

\todo{please eventually itemize next}

1. The inductive synthesis phase (i.e. {\sc synthesise}) uses BMC to
compute a candidate solution $K$
that satisfies both the stability criteria detailed in 
Sec.~\ref{ssec:stability} and the safety specification in Sec.~\ref{ssec:safety}.
%% The stability criteria are satisfied if the characteristic polynomial of $A_d - B_d * K_d$ meets Jury's criteria. This is 
%% independent of the initial states. 
Regarding the latter, we synthesise a safe controller by unwinding the transition system
$k$ steps and picking a controller $K$ and an initial state such that the states at each step do
not violate the safety criteria. This is sound if the current $k$ is below the
completeness threshold, which we assume to be true in the {\sc synthesise} phase.
We also assume some
precision $\langle I_p,F_p\rangle$ for the plant and a sampling rate.  The
checks that all these assumptions are sound are performed by subsequent
{\sc verify} stages.



\begin{algorithm}[]
\begin{algorithmic}[1]
\Function{$safetyCheck()$}{}
	\State assert($ \underline{u}  \leq u \leq \overline{u}$)
	\While{$i=0; i< k; i++$}
		%\State $u = (\langle I_p,F_p\rangle)((\langle I_c,F_c\rangle)K * (\langle I_c,F_c\rangle) x)$
		\State $u = (plant\_typet)((controller\_typet)K * (controller\_typet) x)$
		\State $x = A * x + B * u$
		\State assert($\underline{x} \leq x \leq \overline{x}$ )
  	\EndWhile
  %\State Return $K$
\EndFunction
\end{algorithmic}
\label{alg:safetycheck}
\end{algorithm}

2. The first {\sc verify} stage, {\sc safety}, checks that the candidate
solution $K$ is safe for all possible initial states, i.e., does not reach an unsafe
state within $k$ steps where again we assume $k$ to be under the completeness threshold. 
%The safety criteria here must be valid for all possible allowed initial states, and so we
After unwinding the transition system corresponding to the previously synthesised controller
$k$ steps, we check that the safety specification holds for any initial state. 

This is relatively computationally expensive if the bounds on the
allowed initial states are large.  However, we can show that, if the
controller is safe for each of the corner cases of our hypercube of
allowed initial states, it is safe for any initial state in the
hypercube. Thus we only need to check $2^N$ initial states, where $N$
is the number of states.

\todo[inline]{please will Alessandro write out the proof that checking only the corner cases is valid for the safety verification - EP}

Proof. 
Consider the set of initial states, $X_0$, assumed to be convex since it's a box. 
Name $v_i$ its vertexes, where $i=1,\ldots, 2^n$.  
Thus any point $x \in X_0$ can be expressed by convexity as $x = \sum_{i=1}^{2^n} \alpha_i v_i$, 
where $\sum_{i=1}^{2^n} \alpha_i =1$. 
So then if $x_0=x$, then $x_k = (A_d - B_d K)^k x = 
(A_d - B_d K)^k \sum_{i=1}^{2^n} \alpha_i v_i = 
\sum_{i=1}^{2^n} \alpha_i (A_d - B_d K)^k v_i  = 
\sum_{i=1}^{2^n} \alpha_i x_k^i$, 
where I have denoted with $x_k^i$ the trajectories obtained from the single vertexes $v_i$.QED


3. The second {\sc verify} stage, {\sc precision}, 
 restores soundness with respect to the plant's precision
by using interval arithmetic \cite{moore1966interval} to validate the 
operations performed by the previous stage. 

4. The third {\sc verify} stage, {\sc complete}, checks that the
current $k$ is large enough to ensure that the boundaries are not
violated for any $k'{>}k$.  For this purpose, we compute the
completeness threshold $\overline{k}$ for the current candidate $K$
and check that $k{\leq}\overline{k}$. 

A stable control system is known to have converging dynamics, i.e., the
distance from the reference (in this case the origin) decreases over time. 

\todo[inline] {please will Alessandro write the proof for the completeness threshold here - EP}
\missingfigure{picture for completeness threshold}

Proof sketch. 
Consider spectrum of matrix $(A_d - B_d K)$ and select eigenvalue with smallest (non trivial) imaginary value.  
call such value $\vartheta$. 
At every time interval $kT_s, (k+1)T_s$ ($T_s$ being the sampling time), 
the dynamics projected on the corresponding eigenspace rotate of $\vartheta T_s$ radiants.  
So surely taking $k$ as the ceiling of $\frac{2\pi}{\vartheta T_s}$, after $k$ steps we've completed a rotation. 
This is the CT. 

5. The last {\sc verify} stage, {\sc sampling}, 
ensures that the current sampling rate is large enough by using an 
external checker (\addtodo{add more details here once we have them}).

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{CEGIS with abstraction refinement}
\label{sec:CEGIS-abstraction-refinement}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

% The verification of a hybrid continuous/discrete system over an unbounded time, requires the
% non-deterministic simulation of an infinite set of states, which is undecidable. Our initial approach creates an
% abstraction of this system by establishing bounds on the error between such a system and a discrete-time/continuous-space model.
% This model is still however, quite complex, hard to verify, and many of the states involved are inconsequential to
% the safety specification.
% The advantage of this model is that it starts with a very simple description regardless of the complexity of the overall dynamics, and only expands to more complex models when a solution cannot be found.

% \addtodo{Move as much as possible from Sec~\ref{sec:cof_verification}
% to the appendix (e.g. discussion on abstract acceleration). 
% Merge the rest in Sec~\ref{sec:cof_synth}.}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
%\subsubsection{Verification of a controllable system}
%\label{sec:cof_verification}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
%Whilst there are other properties, we may include in the verification, 
% we will solely focus on these for simplicity of the explanation.
% We assume that we do not want saturation in our system, 
% hence the control loop has only one mode. 



%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
%\subsubsection{Controller synthesis}\label{sec:cof_synth}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
The CEGIS loop for this approach is illustrated in \ref{fig:CEGARIS}.

% Now that we have explained the verification process, we may proceed to describe the synthesis procedure, which is illustrated in figure \ref{fig:CEGARIS}.
% Our model, rather than look at a bisimulation \todo{specific notion that has not been formally define - do not use} in discrete time, explores a much higher abstraction, 
% evaluating the unbounded time-continuous space reach tube as a set of inequalities that represent only the safety specification.
% We have also identified 
% the quantization noise as a bounded non-deterministic input.


\begin{enumerate}
\item 
We start by preprocessing the dynamics. This can be computationally intensive and we don't want it to be part of the CEGIS loop.
% Let us recall the formulas used for single-input and single-output (SISO) systems 
% in sections \ref{sec:reachable} and \ref{sec:observable}.
A controllable system with quantization will have the following dynamics 
(note that we use underscript ``n'' to denote a noise term and
``cf'' to denote Controllable Canonical Form):
\todo{eliminate vectors}
%
\begin{align}
\label{eq:observer_LTI_cf}
x_{k+1}=&\mat{A}_{t}x_k+\mat{B}_{t} r_k+\mat{B}_{n} (\nu_1 + \nu_2 + \nu_3)
\end{align}
\begin{align*}
\mat{A}_{t}=&\mat{T}\mat{A}_d\mat{T}^{-1}&
\mat{B}_{t}=&\mat{T}\mat{B}_d&
\mat{B}_{n}=&[1 \cdots 1]^T&
\mat{T}=&\mat{W}_{cf}\mat{W}^{-1}&
\end{align*}

\begin{align*}
\mat{A}_{t}=\mat{T}\mat{A}_d\mat{T}^{-1}=&\left[
\begin{array}{ccccc}
0&1&0&\cdots&0\\
0&0&1&\cdots&0\\
\vdots&\vdots&\vdots&\ddots&\vdots\\
0&0&0&\cdots&1\\
k_n-a_n&k_{n-1}-a_{n-1}&k_{n-2}-a_{n-2}&\cdots&k_1-a_1
\end{array}\right]
\label{eq:cf_SISO_2}
\end{align*}

The characteristic polynomial of the above matrix is:
%
\begin{align*}
P_a = z^n+\sum_{i=1}^p{(a_i-k_i)z^{n-i}}
\end{align*}

\begin{enumerate}
\item Calculate $\mat{T}$ as $\mat{W}_{cf}\mat{W}^{-1}$. %using equations \eqref{eq:rncf}\eqref{eq:rcf}\eqref{eq:to_cf}
\item Extract the Plant's characteristic polynomial coefficients from $P_a$. %the last row of $P_a=(\mat{T}\mat{A}\mat{T}^-1)_{n*}$.
\item Calculate the noise set $N$ from the quantizer resolutions and estimated round-off errors: %($\frac{q_1}{2},\frac{q_2}{2},q_3$)
$$N=\left \{ \nu_1+\nu_2+ \nu_3 : \nu_1 \in \left[-\frac{q1}{2}\ \ \frac{q1}{2}\right] 
\wedge \nu_2 \in \left[-\frac{q2}{2}\ \ \frac{q2}{2}\right]  \wedge \nu_3 \in \left[-q3\ \ q3\right]  \right \}\nonumber$$
\item Calculate a set of initial bounds on K based on the input constraints. $$\phi_{safety} \Leftrightarrow u_k=r-Kx_k : x \in X^\# \wedge u_k \in [\underline{u}\ \ \overline{u}]$$
\end{enumerate}
\item Next we synthesise a candidate controller. 
We begin with a minimum set of linear inequalities describing the constraints caused by the input and the initial state during a single iteration, in addition to a stability specification defined by Jury's criteria. %, and try to synthesise a controller that meets these specs.
% For a stabilized closed-loop, which is necessary for our safety property, we need
% these roots to remain within the unit circle, which we verify using Jury's criteria.
% Notice that in our polynomials $c_0=1$ and we only use reals.
% Once we have established convergence, we may examine the 
% safety specification $\phi_{safety}$.

Let $\mathcal{J}\langle I,F \rangle (P,\mat{T})$ be a program describing Jury's method.
\begin{enumerate}
\item Select a controller $\tilde{\mat{K}} \in \mathbb{R}\langle I,F\rangle^n$. This is achieved by solving a SAT formula $\mathcal{J}_K=\mathcal{J}\langle I,F \rangle (P_{a-k},\mat{T})\wedge \phi_{input}$ that satisfies the input constraint and Jury's criteria for $P_{a-k}=z^n+\sum_{i=1}^n (a_i-k_i) z^{n-i} : k_i \in \mat{K} \wedge \mat{K}=\tilde{\mat{K}}\mat{T}$.
\item If there is no candidate solution we return UNSAT and exit the loop.
\end{enumerate}
\item Once we have a candidate solution, we perform a safety verification using abstract acceleration. For this purpose, we make use of a second abstraction that encompasses the accelerated continuous reach-tube over an unbounded time. % If this step fails, we find a counterexample iteration and initial state and create a new constraint to refine our abstraction.
%
The first step constraints
\begin{equation}
\mat{K} \models u_k=-\mat{K}x_k : \phi_{safety}
\label{eq:of_bounds}
\end{equation}
The second step is evaluating the progression of the system over time to evaluate 
$x_{k+1} \models \phi_{safety}$. For this step we require 
an initial set from which the system progresses. Obviously, this set $x_0$ 
must satisfy the specification; otherwise, the system will be unsafe to begin with.
We accept a specification in the form $\mat{E}\mat{T}x_0<\mat{f}$. 
The presence of $\mat{T}$ is because this will typically be given in the original 
state-space. Accelerating \eqref{eq:observer_LTI_cf}, we obtain:
%
\begin{align}
\label{eq:acc_observer_LTI_cf}
x=&\mat{A}_t^kx_0
%+\sum_{i=0}^{k-1} \mat{A}_t^i \mat{B}_{t} r_i
+\sum_{i=0}^{k-1} \mat{A}_t^i \mat{B}_{n}(\nu_1+\nu_2+\nu_3) : x_0 \models \phi_{init}
\end{align}
which would still require us to verify the system for every $k$ up to infinity. 
Instead we use abstract acceleration~\cite{cattaruzza2015unbounded}, which translates the formula into
%
\begin{align}
\label{eq:aa_observer_LTI_cf}
\hat{X}^\#
=&\mathcal{A}_t X_0+\mathcal{B}_{t} R + \mathcal{B}_{n} N\\
X_0 =&\left \{x : x \models \phi_{init} \right\}\nonumber\\
% R =&\{r : \mat{E}_r < f_r \}\nonumber\\
 %N=&\left \{ \nu_1+\nu_2+ \nu_3 : \nu_1 \in \left[-\frac{q1}{2}\ \ \frac{q1}{2}\right] \wedge \nu_2 \in \left[-\frac{q2}{2}\ \ \frac{q2}{2}\right]  \wedge \nu_3 \in \left[-q3\ \ q3\right]  \right \}\nonumber
\end{align}
%
where $\mathcal{A}_t=\bigcup_{k=1}^\infty \mat{A}^k, \mathcal{B}_{t}=\bigcup_{k=1}^\infty \sum_{i=0}^k\mat{A}^i\mat{B}_{t}, \mathcal{B}_{n}=\bigcup_{k=1}^\infty \sum_{i=0}^k\mat{A}^i\mat{B}_{n}$ are abstract matrices for the system in \eqref{eq:observer_LTI_cf} 
%and $r$ is a non-deterministic parametric input (\emph{ie} $\forall k>0, r_{k+1} =r_k$) 
whereas the set N is composed of non-deterministic variable inputs.


\begin{enumerate}
\item Calculate the abstract matrices $\mathcal{A}_t, \mathcal{B}_{t},\mathcal{B}_{n}$ for the candidate closed loop solution.
\item Evaluate $\hat{X}^\# \models \Psi$. If the verification holds we have a solution, and exit the loop.
\end{enumerate} 
\item If the candidate solution is not valid we refine the abstraction used by the synthesizer
\begin{enumerate}
\item Find the constraints that invalidate the property. These are the rows of $\mat{E} \in \Psi$ that intersect/segment $\hat{X}^\#$. Transforming these rows into the eigenspace of $\mat{A}_t$, and applying backward acceleration to obtain a set of counterexamples for the eigenvalues, which we define as $\phi(\Lambda)$. This is a constraint in the spectrum (\emph{ie} frequency response transfer function) of the closed loop dynamics. 
\item Transform the soft constraints on the spectrum into soft constraints on the coefficients of the characteristic polynomial. 
$z^n+\sum_{i=1}^n[a_i-k_i]z^{n-i}=\prod_{i=1}^n (z-[\lambda_i]) : |[\lambda_i]|<1 \wedge [\lambda_i] \models \phi_{\Lambda}$.
\item Pass the refined abstraction with the new constraints to the synthesizer, as well as a counterexample plant coefficients ($P_a$) and repeat the loop again. We note that the Abstraction refinement is a soft constraint on the proposed model which can increase or decrease the parameter space at any time, whereas the concrete counterexample passed to the synthesizer is monotonically decreasing. The first one improves speed of the tool whereas the second ensures convergence.

\end{enumerate} 
\end{enumerate}

\begin{figure}
\centering
{\scriptsize
\hspace*{-1cm}
\begin{tikzpicture}[scale=0.3,->,>=stealth',shorten >=.2pt,auto, semithick, ampersand replacement=\&,]
  \matrix[nodes={draw, fill=none, shape=rectangle, minimum height=.2cm, minimum width=.2cm, align=center},row sep=.8cm, column sep=.2cm] {
   \coordinate (aux1);
   \& \coordinate (aux2);
   \& ;\\
   \&\node[fill=gray!20,align=center] (pre) {{\sc 1. pre-}\\{\sc processing}};
   \& \node[fill=gray!20,align=center] (abstract) {\sc 4. abstract};
   \& \coordinate (aux); \\ % \node[fill=yellow!20,align=center] (counter) {\sc counterexample};\\
   \& 
   \& \node[fill=gray!20,align=center, minimum width=3cm] (synth) {\sc 2. synthesize};
       %\node[draw=none] (KL) at ([xshift=2.5cm,yshift=-.25cm]synth)  {\sc $\mat{K},\mat{L}$};
       %\node[draw=none] (NKL) at ([xshift=2cm,yshift=1cm]synth)  {\sc $P_a$};
   \& \node[fill=gray!20,align=center, minimum width=4cm] (verify) {\sc 3. verify ($\phi$)};
       %\node[draw=none] (VUNS) at ([xshift=.6cm,yshift=1cm]verify)  {\sc SAT};
       \node[draw=none] (SAT) at ([xshift=2.7cm,yshift=-.3cm]verify)  {\sc SAT};
   \& \node[ellipse, fill=gray!20] (done) {{\sc Done}};\\
   \&
   \& complexnode/.pic={
     \coordinate (auxsynth);
     \node[draw,rectangle,align=center] (KSAT) at ([xshift=0cm]auxsynth.center) {\sc Prog.\\Search};
     \node[draw=none] (SATK) at ([xshift=-0.5cm,yshift=1.5cm]KSAT)  {$\mathcal{J}_K$};
     \node[draw=none] (K) at ([xshift=.4cm,yshift=1.5cm]KSAT)  {$\tilde{\mat{K}}$};
    }
   \& complexnode/.pic={
     \coordinate (AA);
     \node[draw,rectangle,align=center] (AAI) at ([xshift=-1.5cm]AA.center) {\sc Abstract};
     \node[draw,rectangle,align=center] (AAC) at ([xshift=1.5cm,yshift=1.5cm]AA.center) {Abstraction \\ Verifier};
     \node[draw,rectangle,align=center] (AAV) at ([xshift=1.5cm]AA.center) {\sc AA\\Solver};
     
     %\node[draw=none] (AB) at ([xshift=.4cm,yshift=1.5cm]AAI.center)  {\sc $\mat{A},\mat{B}$\\$\phi$};     
     \node[draw=none] (MA) at ([yshift=.2cm]AA.center)  {$\mathcal{A}_t$};     
     \node[draw=none] (MB) at ([yshift=-.3cm]AA.center)  {$\mathcal{B}_{t},\mathcal{B}_{n}$}; 
     \node[draw=none] (XT) at ([xshift=0.3cm,yshift=0.5cm]AAC.center)  {\sl $\hat{X}_r^\#$};  
     \node[draw=none] (XT2) at ([xshift=0.3cm,yshift=0.8cm]AAV.center)  {\sl $\hat{X}^\#$};  
     %\draw [->,line width=1pt] ([xshift=-0.1cm,yshift=2cm]AA.center) arc[x radius=0.7cm, y radius =.7cm, start angle=-250, end angle=60];
    }\\
   \&
   \& complexnode/.pic={
     \coordinate (UNSAT);
     \coordinate (KUNSAT)  at ([xshift=0cm]UNSAT.center);
     \node[draw=none] (UNSATB) at ([xshift=1.6cm,yshift=.3cm]UNSAT)  {\sc UNSAT};
  }
  \& \& \coordinate (FAIL);\\
  };
  \path
    (pre.east) edge (abstract.west)
    (abstract.south) edge (synth.north)
    %([yshift=2em]synth.east) edge node {Candidate} ([yshift=2em]verif.west)
    %([yshift=-2em]verif.west) edge node {New input} ([yshift=-2em]synth.east)
    %([yshift=2em]synth.east) edge node[xshift=-0.7em] {Candidate} ([yshift=2em]verif.west)
    %([yshift=-2em]verif.west) edge node[xshift=-0.7em] {New input} ([yshift=-2em]synth.east)
    ([yshift=1em]synth.east) edge node {$\mat{K}$} ([yshift=1em]verify.west)
    ([yshift=-1em]verify.west) edge node {$P_a$} ([yshift=-1em]synth.east)
    (aux) edge (abstract.east) 
    (verify.east) edge (done.west);
  \path
    ([xshift=+.6cm]KSAT.north) edge ([xshift=0.6cm]synth.south) 
    ([xshift=-.6cm]synth.south) edge ([xshift=-.6cm]KSAT.north)
    (AAC) edge[bend right] node[align=center] {$k$} (AAI.north)
    ([xshift=-4.9cm]verify.south) edge node[align=center] {$\mat{A},\mat{B}$\\$\phi$} (AAI.north)
    (AAI.east) edge (AAV.west)
    (AAV.north) edge (AAC.south)
    (AAC.north) edge ([xshift=4.9cm]verify.south)
    %(AAC.west) edge (AB.west)
    %(verify.north) edge (counter.south)
    %(counter.west) edge (abstract.east)
    %(counter.south west) edge (synth.north east)
    (FAIL.north) edge (done.south);
   \path[-] 
     (KSAT.south) edge (KUNSAT.north)
     (KUNSAT.east) edge (FAIL.west)
     (verify.north) edge node {$\phi (\mat{K},k)$} (aux);
\end{tikzpicture}
}
\caption{CEGIS with abstraction refinement}
\label{fig:CEGARIS} 
\end{figure}

%-------------------------------
\section{Experimental Evaluation}
%-------------------------------


%-------------------------------
\subsection{Description of the benchmarks}
\label{experimental-setup}
%-------------------------------

A set of state-space models for different classes of 
systems were extracted from the 
literature~\cite{Franklin15,maglev,converters,CTMS} 
and employed for validating our methodology. 
%All systems are SISO models of the following form:
%
%\begin{equation}
%\left\lbrace\begin{array}{c}
%\dot{\textbf{x}}(t)=\textbf{A}\textbf{x}(t)+\textbf{B}u(t)\\
%y(t)=\textbf{C}\textbf{x}(t)+\textbf{D}u(t)
%\end{array}\right.
%\end{equation}
%
Table~\ref{table:State-space benchmarks} summarizes 
all our benchmarks, which are SISO models (cf. section~\ref{sec:preliminaries}). 

\textit{DC Motor Position and Rate} plants describes the angular position and 
velocity of a DC Motor, respectively. 
\textit{Aircraft Pitch Dynamics} plant represents the air vehicle orientation and 
control based on the pitch dimension. 
\textit{Ball Magnetic Levitation} plant describes a physical model to keep a 
metal ball hanged in air via a magnetic field . 
\textit{Buck Converter} plant represents a power converter model that steps down 
voltage from the supply to the load while stepping up current. 
\textit{Boost Converter} plant also represents a power converter model, but here 
it steps up voltage from the supply to the load while stepping down current. 
\textit{Buck-boost Converter} plant represents a converter model that has an output 
voltage magnitude, which is either greater than or less than the input voltage magnitude. 

\textit{Automotive Cruise System} plant describes a physical model that represents 
the speed of a motor vehicle. 
\textit{Helicopter Longitudinal Motion} plant provides the 
longitudinal motion model of a helicopter. 
\textit{Inverted Pendulum} plant describes a pendulum model
with its center of mass above its pivot point. 
\textit{Magnetic Suspension} plant provides the physical model for which 
a given object is suspended via a magnetic field. 
\textit{Magnetized Pointer} plant describes a physical model that is rotated through interaction 
with magnetic fields (typically employed in analogue gauges and indicators).
\textit{1/4 Car Suspension} plant presents a physical model that connects a car to its wheels 
and allows relative motion between both parts.
\textit{Computer Tape Driver} plant describes a physical model to read and write data 
on a storage device in the computer.
\textit{USCG Cutter Tampa Heading Angle} plant presents a physical model 
for the yaw angle dynamics of a US warship USCG Cutter Tampa.

All benchmarks were discretized with different sample times using 
the approach described in the Appendix~\ref{sec:appendix}. 
All experiments were performed considering $x_{i}^{-}=-1$ and 
$x_{i}^{+}=1$ and the inputs $u_{k}=0, \forall k>0$.

We have conducted the experimental evaluation on a 12-core 2.40 GHz
Intel Xeon E5-2440 with 96 GB of RAM and Linux OS. All times given are wall 
clock time in seconds as measured by the UNIX date command. 

\textcolor{red}{we have to describe the timeout...}

%
\begin{table}[htb]
\centering
\footnotesize
\caption{Benchmarks for State-Space Physical Plants.}
\label{table:State-space benchmarks}
\begin{tabular}{|c|c|c|c|c|}
\hline
%\textbf{ID \#} & 
\textbf{System}                                                               & \textbf{A} & \textbf{B} & \textbf{C} & \textbf{D} \\ \hline
%1              & 
\begin{tabular}[c]{@{}c@{}}DC Motor\\ Position\end{tabular}                   & $\left[\begin{array}{ccc}
0		& 1 		& 0						\\
0 		& -1.087	& 8587					\\
0		& -9964		& -1.455\times 10^{6}	\\
\end{array}\right]$ & $\left[\begin{array}{c}
0 \\ 0 \\ -1.455\times10^{6}
\end{array}\right]$           & $\left[\begin{array}{ccc}
1 & 0 & 0\\
\end{array}\right]$ & 0 \\  \hline
%2              & 
\begin{tabular}[c]{@{}c@{}}Aircraft \\ Pitch\\ Dynamics\end{tabular} & $\left[\begin{array}{ccc}
-0.313	& 56.7 		& 0		\\
-0.0139	& -0.426	& 0		\\
0		& 56.7		& 0		\\
\end{array}\right]$ & $\left[\begin{array}{c}
0.232 \\ 0.0203 \\ 0
\end{array}\right]$ & $\left[\begin{array}{ccc}
1 & 0 & 0\\
\end{array}\right]$ & 0 \\ \hline
%3            & 
\begin{tabular}[c]{@{}c@{}}Ball\\ Magnetic\\ Levitation\end{tabular} & $\left[\begin{array}{ccc}
0		& 1 		& 0		\\
1752	& 0			& -34.07\\
0		& 0			& -38.27\\
\end{array}\right]$ & $\left[\begin{array}{c}
0 \\ 0 \\ 1.923
\end{array}\right]$ & $\left[\begin{array}{ccc}
1 & 0 & 0\\
\end{array}\right]$ & 0 \\ \hline
%4              & 
\begin{tabular}[c]{@{}c@{}}Buck\\ Converter\end{tabular}                      & $\left[\begin{array}{cc}
0		& -500 \\
4545	& -1515\\
\end{array}\right]$ & $\left[\begin{array}{c}
125 \\ 0 \\
\end{array}\right]$ & $\left[\begin{array}{cc}
 0 & 1\\
\end{array}\right]$ & 0 \\ \hline
%5              & 
\begin{tabular}[c]{@{}c@{}}Boost\\ Converter\end{tabular} & $\left[\begin{array}{cc}
0		& -375 \\
3409	& -1515\\
\end{array}\right]$ & $\left[\begin{array}{c}
500 \\ 0 \\
\end{array}\right]$ &  $\left[\begin{array}{cc}
0 & 1\\
\end{array}\right]$  & 0        \\ \hline
%6              & 
\begin{tabular}[c]{@{}c@{}}Buck-boost\\ Converter\end{tabular} & $\left[\begin{array}{cc}
0		& 375 \\
-3409	& -1515\\
\end{array}\right]$ & $\left[\begin{array}{c}
125 \\ 0 \\
\end{array}\right]$ & $\left[\begin{array}{cc}
0 & 1\\
\end{array}\right]$ & 0 \\ \hline
%7              & 
\begin{tabular}[c]{@{}c@{}}Automotive\\ Cruise\\ System\end{tabular} & -0.05 & 0.03125 & 0.032 & 0 \\ \hline
%8              & 
\begin{tabular}[c]{@{}c@{}}DC Motor\\ Rate\end{tabular} & $\left[\begin{array}{cc}
-1000		& -13 \\
-8			& 0\\
\end{array}\right]$ & $\left[\begin{array}{c}
4 \\ 0 \\
\end{array}\right]$ & $\left[\begin{array}{cc}
0 & 6.25\\
\end{array}\right]$ & 0 \\ \hline
%9              & 
\begin{tabular}[c]{@{}c@{}}Helicopter\\ Longitudinal\\ Motion\end{tabular}    & $\left[\begin{array}{ccc}
-0.42		& 0.0168		& -0.396	\\
0.5			& 0				& 0			\\
0			& 0.5 			& 0			
\end{array}\right]$ & $\left[\begin{array}{c}
16 \\ 0 \\ 0
\end{array}\right]$ & $~
\left[\begin{array}{ccc}
0.6125	& -0.6125	& 15.44 \\
\end{array}\right]$ & 0 \\ \hline
%10             & 
Pendulum   & $\left[\begin{array}{cc}
0		& -2.453	\\
4		& 0			\\	
\end{array}\right]$ & $\left[\begin{array}{c}
4 \\ 0
\end{array}\right]$ & $\left[\begin{array}{cc}
-1.225	& -2.15 	\\
\end{array}\right]$           & 9.8           \\ \hline
%11             & 
\begin{tabular}[c]{@{}c@{}}Inverted\\ Pendulum\end{tabular} & $\left[\begin{array}{cccc}
0		& 1		& 0 	& 0	\\
1		& 0		& 0		& 0	\\
0		& 1 	& 0		& 0 \\
0		& 0		& 1 	& 0 \\	
\end{array}\right]$ & $\left[\begin{array}{c}
1 \\ 0 \\ 0 \\ 0
\end{array}\right]$  & $\left[\begin{array}{cccc}
0	& 0	& 1 & -0.75 \\
0	& 1	& 0	& 0		
\end{array}\right]$ & $\left[\begin{array}{c}
0 \\
0 \end{array}\right]$ \\ \hline
%12             & 
\begin{tabular}[c]{@{}c@{}}Magnetic\\ Suspension\end{tabular} & $\left[\begin{array}{cc}
0		& 31.25	\\
32		& 0		\\	
\end{array}\right]$ & $\left[\begin{array}{c}
8 \\ 0
\end{array}\right]$ & $\left[\begin{array}{cc}
0	& 9.766 	\\
\end{array}\right]$ & 0 \\ \hline
%13             & 
\begin{tabular}[c]{@{}c@{}}Magnetic\\ Pointer \end{tabular} & $\left[\begin{array}{ccc}
-0.271		& -0.05336	& 0	\\
0.03125		& 0			& 0	\\
0			& 0.01562 	& 0	\\	
\end{array}\right]$ & $\left[\begin{array}{c}
1 \\ 0 \\ 0
\end{array}\right]$ & $\left[\begin{array}{ccc}
0	& -0.5888	& -0.2562 \\
\end{array}\right]$ & 0           \\ \hline
%14             & 
\begin{tabular}[c]{@{}c@{}}1/4 Car\\ Suspension\end{tabular} & $
\left[\begin{array}{cccc}
-516.1	& -222.1& -79.75& -33.06	\\
256		& 0		& 0		& 0			\\
0		& 64 	& 0		& 0 \\
0		& 0		& 32 	& 0 \\	
\end{array}\right]$ & $\left[\begin{array}{c}
8 \\ 0 \\ 0 \\ 0
\end{array}\right]$ & $\left[\begin{array}{cccc}
0	& 0	& 9.969 & 4.133 \\
\end{array}\right]$ & 0 \\ \hline
%15             & 
\begin{tabular}[c]{@{}c@{}}Computer\\ Tape\\ Driver\end{tabular} & $\left[\begin{array}{ccc}
-1760		& -976.6	& -457.8	\\
1024		& 0			& 0			\\
0			& 512 		& 0			\\	
\end{array}\right]$ & $\left[\begin{array}{c}
8 \\ 0 \\ 0
\end{array}\right]$ & $\left[\begin{array}{ccc}
1.5	& 2.051	& 1.144 \\
\end{array}\right]$ & 0           \\ \hline
%16             & 
\begin{tabular}[c]{@{}c@{}}USCG \\ Cutter\\ Tampa\\ Heading\\ Angle\end{tabular} & $\left[\begin{array}{ccc}
-0.271		& -0.05336	& 0	\\
0.03125		& 0			& 0			\\
0			& 0.01562 	& 0			\\	
\end{array}\right]$ & , $\left[\begin{array}{c}
1 \\ 0 \\ 0
\end{array}\right]$ & $\left[\begin{array}{ccc}
0	& -0.5888	& -0.2562 \\
\end{array}\right]$ & 0 \\ \hline
\end{tabular}
\end{table}


%-------------------------------
\subsection{Objectives}
%-------------------------------

Using the state-space models given in Section~\ref{experimental-setup}, 
our experimental evaluation aims to answer two research questions:
%
\begin{enumerate}

\item[RQ1] \textbf{(CEGIS)} do the CEGIS with multi-stage 
verification and abstraction refinement generate a FWL digital 
controller in a reasonable amount of time?

\item[RQ2] \textbf{(sanity check)} are the synthesized controllers sound
and can their stability and safety be confirmed outside of our model?

\end{enumerate}


%-------------------------------
\subsection{Results}
%-------------------------------


%-------------------------------
\subsection{Threats to validity}
%-------------------------------
We report an assessment of both our approaches over a diverse set of real-world benchmarks. Nevertheless, this set of benchmarks is limited within the scope of this paper and the performance may not generalise to other benchmarks. 

Our algorithm to select suitable FWL word widths to model plant behaviour employs a heuristic based on user-provided controller word-width specifications. For the first approach, where we may need to increase the precision of the time discretization, we select the time steps for the discretizations on a similar basis. This works sufficiently well for our benchmarks, but performance may suffer in some cases, for example if the completeness threshold is high. 

The performance gain from abstract acceleration may not hold for more complex properties than stability, for instance ``eventually always reaches a certain safe set''. 


%% %-------------------------------
%% \section{Related Work}
%% \label{sec:rw}
%% %-------------------------------


%-------------------------------
\section{Extensions}
\label{sec:extensions}
%-------------------------------

%-------------------------------
\subsection{LTI systems with output} 
\label{ssec:LTI}
%-------------------------------

LTI models in the form: 
%
\begin{align}
\dot{\vec{x}}(t)&=\mat{A}\vec{x}(t)+\mat{B}\vec{u}(t)\ \ :\ \ \vec{x} \in \mathbb{R}^{n}, \vec{u} \in \mathbb{R}^m, \mat{A} \in \mathbb{R}^{n \times n},\mat{B} \in \mathbb{R}^{n \times m}\\
\vec{y}(t)&=\mat{C}\vec{x}(t)+\mat{D}\vec{u}(t)\ \ :\ \ \vec{y} \in \mathbb{R}^{o}, \mat{C} \in \mathbb{R}^{o \times n}, \mat{D}  \in \mathbb{R}^{o \times m}\nonumber
\end{align}
\noindent where $\dot{\vec{x}}(t)$ describes the state evolution equation; 
$\vec{y}(t)$ represents an instantaneous output equation; and $\mat{A}$, $\mat{B}$, $\mat{C}$, and $\mat{D}$ are matrices that fully specify 
a continuous plant. Eq.~\eqref{eq:ode} is soundly discretized 
(as shown in the appendix) into
%
\begin{align}
\vec{x}_{k+1}&=\mat{A}_d\vec{x}_k+\mat{B}_d\vec{u}_k\\
\vec{y}_k&=\mat{C}_d\vec{x}_k+\mat{D}_d\vec{u}_k .\nonumber
\end{align}
%


\newpage

\bibliographystyle{abbrv}
\bibliography{paper}  
%\begin{thebibliography}{4}
%\end{thebibliography}

\newpage
\appendix
%-------------------------------
\section{Stability of closed-loop systems}
\label{sec:appendix-stability}
%-------------------------------

%\addtodo{[Here discuss Jury criterium for DISCRETE-TIME models - a simplified version of the first part of what is now in Section \ref{sec:cof_verification} (with no quantisation noises yet).]}  

For a closed-loop system as~\eqref{eq:closedloopss}, 
the characteristic polynomial $P(z)$ should be computed as follows:
\begin{equation}
P(z)= \det( z I_{n} - A_d + B_d K ),
\end{equation}
where $I_{n}$ is the n-th order identity matrix. 

Jury's criterion provides necessary and sufficient conditions for the eigenvalues 
to be within the unit circle and, consequently, the system is stable.  Given a 
polynomial $P(z)$ of the form
$$
P(z) = a_{0}z^{N} + a_{1}z^{N-1} + ... a_{N-1}z + a_{N} = 0, a_{0}\neq 0,
$$
Jury's criterion explores solely the coefficients ($a_{0},a_{1},...,a_{N-1}$) 
of $P(z)$ for checking the validity of the stability property $\phi_{stability}$. 

In particular, Jury stability test is already explained in the control system 
literature ({\it e.g.}~\cite{fadali}). This study, however, limits itself to 
explain the encoding of Jury's criterion for the formal synthesis purpose. 
For the stability  test procedure, the following Jury matrix 
$M=[m_{ij}]_{(2N-2)\times N}$ is built  from $P(z)$ coefficients:
$$
M=\left[
\begin{matrix}
  V^{(0)} \\
  V^{(1)} \\
  \vdots \\
  V^{(N-2)}
 \end{matrix}
\right]\mbox{,}
$$
\noindent where $V^{(k)}=[v^{(k)}_{ij}]_{2\times N}$ such that
$$
v^{(0)}_{ij}=\begin{cases} 
a_{j-1}, & \mbox{if } i=1 \\   v^{(0)}_{(1)(N-j+1)}, & \mbox{if } i=2 
\end{cases}\mbox{, and} 
$$
$$
v^{(k)}_{ij}=\begin{cases} 
0, & \mbox{if } j>n-k\\
v^{(k-1)}_{1j}-v^{(k-1)}_{2j}\cdot\frac{v^{(k-1)}_{11}}{v^{(k-1)}_{21}}, & \mbox{if } j\leq n-k  \mbox{ and } i=1 \\
v^{(k)}_{(1)(N-j+1)}, & \mbox{if } j\leq n-k \mbox{ and } i=2 \\
\end{cases} \mbox{,}
$$
\noindent where $k\in\mathbb{Z}$, such that $0<k<N-2$. $P(z)$ is the 
characteristic polynomial of a stable system if and only if the following 
four propositions hold:
\begin{itemize}
\item $R_{1}$: $S(1)>0$;
\item $R_{2}$: $(-1)^{N}P(-1)>0$;
\item $R_{3}$: $\vert{a_{0}}\vert <a_{N}$;
\item $R_{4}$: $m_{11}>0\iff m_{31}\wedge m_{51}\wedge \dots \wedge m_{(2N-3)(1)}$.
\end{itemize}

The stability property $\phi_{stability}$ is then encoded as follows:
$$
\phi_{stability}\iff \ (R_{1} \wedge R_{2} \wedge R_{3} \wedge R_{4}).
$$


%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\section{LTI system Transformations and Equivalencies} \label{sec:appendix}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{Discretizing continuous space dynamics}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

A dynamical system is a system in which a function describes the progression of a state over time. 
In a continuous domain with linear dynamics, it is described by a first order Ordinary Differential Equation (ODE).
\begin{equation}
\dot{x}(t)=\vec{A}\vec{x}(t)+\vec{B}\vec{u}(t) +\vec{w}(t).
\label{eq:dynamical}
\end{equation}

\noindent with $\vec{w} \sim \mathcal{N}(0,Q)$.\\
Furthermore, a control system may have a derived output that is a linear combination of its states and inputs, 
which may restrict the observability of the state-space from the output space.
\begin{equation}
\vec{y}(t)=\vec{C}\vec{x}(t)+\vec{D}\vec{u}(t).
\end{equation}

Discretization of an continuous dynamical system turns the ODE into a difference equation, assuming zero-order hold
for the input $\vec{u}$ and continuous integration for the noise $\vec{w}$, to
\begin{align}
\label{eq:discretization}
\vec{x}_{k+1} &= \vec{A}_d\vec{x}_k+\vec{B}_d\vec{u}_k + \vec{w}_k,\\
y_k &= \vec{C}_d \vec{x}_ k + \vec{D}_d \vec{u}_ k. 
\end{align}
with covariance for $\vec{w}_k \sim \mathcal{N}(0,Q_d)$,
where
\begin{align}
\label{eq:discretize}
\vec{A}_d &= e^{\vec{A} T_s} = \mathcal{L}^{-1} { ( s \vec{I} - \vec{A} )^{-1} }_{t = T_s},\\
\vec{B}_d &= \int_{0}^{T_s} e^{\vec{A} t} dt\ \vec{B} = \vec{A}^{-1} ( \vec{A}_d - \vec{I} ) \vec{B},\\
\vec{C}_d &= \vec{C},\\
\vec{D}_d &= \vec{D},\\
Q_d &= \int_{0}^{T_s} e^{\vec{A} t} Q e^{\vec{A}^T t} dt.
\end{align}
and $T_s$ is the sample time. Then
\begin{align*}
x(kT_s)=x_k \wedge y(kT_s) = y_k, \forall k.
\end{align*}
Let $g_d(k)=\mathcal{G}(t,g(t),T)$ be a function that performs the discretization described above, where $g(t)$
represents the continuous dynamics and $g_d(k)$ the corresponding discrete dynamics. 
Let $G(s)=\mathcal{L}(g(t))$ and $G_d(z)=\mathcal{Z}(g_d(k))$ be the corresponding Laplace and Z-transforms
of $g(t)$ and $g_d(k)$. Given this relation, we have 
$$G_d(z)=G(z)|_{z=e^{sT}} : g_d(k)=\mathcal{G}(t,g(t),T) \wedge T < \frac{1}{.5f_s},$$
where $.5f_s$ is the Nyquist frequency of $g(t)$. This last restriction is introduced to avoid the effects of aliasing
which could cause ``phantom poles'' to appear otherwise. 
The eigenvalues of $\vec{A}_d$ corresponding to the poles of $G_d(z)$, and those of $\vec{A}$ corresponding to the poles of $G(s)$ are similarly related.
$\hat{\lambda}_i=e^{-\lambda_iT} : \hat{\lambda}_i \in \sigma(\vec{A}_d) \wedge \lambda_i \in \sigma(\vec{A})$
where $\sigma(\cdot)$ is the spectrum of a matrix.
The following remark is worth mentioning regarding the above.
\begin{remark}
The witnessed maximum amplitude of the discrete signals $x_k,y_k$ may be smaller to that of $x(t),y(t)$ due to synchronism at fraction-frequency sampling.
This means that reasoning about the state-space must consider the effects of this possibility as well of the case of maximal inputs from the continuous specification.
\end{remark}
 Since \eqref{eq:discretization} is a bi-simulation of \eqref{eq:ode}, we may use the semantics in section \ref{sec:model_semantics} to model continuous dynamical systems.

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{Overapproximating continuous space dynamics using discrete models}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Let us recall equation \ref{eq:discretize}. The discrete representation of the system dynamics discretized with sample time $T_1$ is ruled by the formula
$\vec{A}_1 = e^{\vec{A} T_1}$. From matrix theory, we have 
\begin{equation}
\vec{A}_1 = \mat{S}_1\mat{J}_1\mat{S}_1^{-1}= \mat{S}_1e^{\mat{J} T_1}\mat{S}_1^{-1}.
\end{equation}
Let $\mat{J}$ be a diagonal matrix, such that ${\lambda_1}_i=e^{\lambda_i T_1}, \forall \lambda \in \mat{J}$.
Let us now take a different sample rate $T_2$, such that ${\lambda_2}_i=e^{\lambda_i T_2}, \forall \lambda \in \mat{J}$. We can then say that 
\begin{equation}
{\lambda_2}_i=e^{\lambda_i T_1 T_2/T_1}={\lambda_1}_i^{T_2/T_1} \Rightarrow A_2=A_1^{\frac{T_2}{T_1}}
\end{equation}
We have also shown in the previous section that $x_k=A^nx_0$ is a witness of $x(t): \dot{x}(t)=Ax(t)$ at time $kT_s$. Applying this notion to multiple sample times, we can state that $x_{k_i}=A_i^nx_0$ are a set of witnesses at times $kT_i$, and by extension the set $\{x=A_i^nx_0 : \forall n \in \mathbb{R} \}$ witnesses all states visited by the continuous system in time $t \in [0,\infty)$. This applies to any arbitrary sample time $T_i$.
Since the controller output is fed to a Zero Order Holder, the progression of the system between times $kT_s$ and $(k+1)T_s$ is $\mat{A}^n\vec{x}_k+\mat{B}\vec{u}_k : n \in (0,1)$. We therefore obtain a reach tube for the continuous dynamics of a time sampled system to be contained within the abstract reach tube $\mathcal{A}^1\mathcal{M}X_0+\mathcal{BK}^1\mathcal{M}X_0=\mathcal{M}X_0$
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{Modelling quantization as noise}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

During any given ADC conversion, the continuous signal will be sampled in the real domain and transformed into a $\mathbb{R}\langle I_{adc},F_{adc} \rangle$ value. this sampling uses a threshold which is defined by the less significant bit ($q_{adc}=2^{-F_{adc}}$) of the ADC and some non-linearities of the circuitry. The overall conversion is
$$\mathcal{F}\langle I_{adc},F_{adc} \rangle(y(t)) = y_k : y_k \in \left[y(t)-\frac{q_{adc}}{2}\ \ \ \ y(t)+\frac{q_{adc}}{2}\right]$$.
If we denote the error in the conversion as $\nu_k=y_k-y(t) : t=nk$ then we may define some bounds for it $\nu_k \in [-\frac{q_{adc}}{2}\ \ \frac{q_{adc}}{2}]$.

We will assume, for the purposes of this analysis, that the domain of the ADC is that of the digital controller (\emph{ie} the quantizer includes any digital gain added in the code).
The process of quantization in the DAC is similar except that it is going from $\mathbb{R}\langle I_{adc},F_{adc} \rangle \rightarrow \mathbb{R}\langle I_{dac},F_{dac} \rangle$. If these domains are the same ($I_{adc}=I_{dac},F_{adc}=F_{dac}$), or if the DAC resolution in higher than the ADCs, then the DAC quantization error is equal to zero.
From the above equations we can now infer that $\nu_1 \in [-\frac{q_1}{2}\ \ \frac{q_1}{2}], \nu_2 \in [-\frac{q_2}{2}\ \ \frac{q_2}{2}] : q_1=q_{adc} \wedge q_2=q_{dac}$.
Note that these bounds hold irrespective of whether the noise is correlated, hence we may use them to over-approximate the effect of the noise on the state space progression over time.
The resulting dynamics are:
\begin{align}
\label{eq:pre_quantization}
\vec{x}_{k+1} &= \vec{A}_d\vec{x}_k+\vec{B}_d(\vec{u}_k+{\vec{\nu}_2}_k) + \vec{w}_k,\\
y_k &= \vec{C}_d \vec{x}_ k + \vec{D}_d \vec{u}_ k+{\vec{\nu}_1}_k. 
\end{align}

Which, when modelled into closed loop dynamics results in:

\begin{align}
\label{eq:quantization}
\vec{x}_{k+1} &= (\vec{A}_d-\vec{B}_d\mat{K}_d\mat{C}_d) \vec{x}_k+\vec{B}_d{\vec{\nu}_2}_k + \vec{w}_k,\\
y_k &= \vec{C}_d \vec{x}_ k + \vec{D}_d \vec{u}_ k+{\vec{\nu}_1}_k. 
\end{align}

%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
\subsection{Controllable canonical form} \label{sec:reachable}
%+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Let us have a discrete time SISO system with an $n^{th},m^{th} : n\geq m$ order armax model
$$y[k]=\sum_{i=1}^n a_iy[k-i]+\sum_{i=0}^m b_iu[k-i],$$
where $y$ is the output of the system and $u$ its input.
The equivalent LTI dynamics of such a model are:
\begin{align}
\label{eq:cf_SISO}
\vec{x}_{k+1}=&\mat{A}_{cf}\vec{x}_k+\mat{B}_{cf}u_k : \vec{x}_k=[y_{k-n}\ \hdots y_{k-1}\ y_{k}]^T\\
y_k=&\mat{C}_{cf}\vec{x}_k + b_0u_k\nonumber\\
\mat{A}_{cf}=&\left[
\begin{array}{ccccc}
0&1&0&\cdots&0\\
0&0&1&\cdots&0\\
\vdots&\vdots&\vdots&\ddots&\vdots\\
0&0&0&\cdots&1\\
-a_n&-a_{n-1}&-a_{n-2}&\cdots&-a_1
\end{array}\right],
\mat{B}_{cf}=\left[
\begin{array}{c}
0\\0\\ \vdots\\ 0\\ 1
\end{array}\right]\nonumber\\
\mat{C}_{cf}=&[\begin{array}{ccccc}b_n-a_nb_0&b_{n-1}-a_{n-1}b_0&\cdots&b_1-a_1b_0\end{array}] : b_{i \in (m\ n]}=0\nonumber
\end{align}

where the coefficients $a_i$ describe the characteristic polynomial of the system. This matrix shape is
called a Controllable Canonical Form because the dynamics of the feedback are directly related to these
coefficients. Specifically, given a feedback controller $\mat{K}$ for this system, the closed loop dynamics
will have the shape
\begin{align}
\mat{A}_{cf}+\mat{B}_{cf}\mat{K}_{cf}=&\left[
\begin{array}{ccccc}
0&1&0&\cdots&0\\
0&0&1&\cdots&0\\
\vdots&\vdots&\vdots&\ddots&\vdots\\
0&0&0&\cdots&1\\
k_n-a_n&k_{n-1}-a_{n-1}&k_{n-2}-a_{n-2}&\cdots&k_1-a_1
\end{array}\right]
\label{eq:cf_SISO_fb}
\end{align}
which means we can directly modify each coefficient by selecting a controller parameter.
In the MIMO case, the Controllable Canonical Form has the following shape:
\begin{align}
\mat{A}_{cf}=&\left[
\begin{array}{ccccc}
0&\mat{I}_{n-1}&0&\cdots&0\\
0&0&\mat{I}_{n-2}&\cdots&0\\
\vdots&\vdots&\vdots&\ddots&\vdots\\
0&0&0&\cdots&1\\
-\mat{a_n}\mat{M}_n&-\mat{a_{n-1}}\mat{M}_{n-1}&-\mat{a_{n-2}}\mat{M}_{n-2}&\cdots&-\mat{a_1}\mat{M}_{1}
\end{array}\right],
\mat{B}_{cf}=\left[
\begin{array}{c}
0\\0\\ \vdots\\ 0\\ \mat{M}_0
\end{array}\right]\nonumber\\
\mat{C}_{cf}=&[\begin{array}{ccccc}\mat{\eta}_n&\mat{\eta}_{n-1}&\cdots&\mat{\eta}_1\end{array}] :
\mat{I}_i,\mat{M}_i \in \mathbb{R}^{q_i \times q_i} \wedge \mat{a}_i \in \mathbb{R}^{q \times q_i} \wedge \mat{\eta}_i \in \mathbb{R}^o \wedge  \mat{\eta}_{i \in (m\ n]}=0 \nonumber
\label{eq:cf_MIMO}
\end{align}
where $q$ is the number of inputs, $q_i$ the number of inputs with a transfer function of order of at least $i$, $\mat{I}_i$ an identity matrix, $\mat{M}_i$ an upper triangular matrix with 1s in its diagonal, $\mat{a_i}$ a matrix of coefficients of the $i^th$ order on its diagonal, and $o$ the number of outputs. Ideally we aim for $\mat{M}_i=\mat{I}_i, \forall i>0$

Any LTI system can be transformed into a controllable canonical form by a matrix $\mat{T} : \vec{x}=\mat{T}\hat{\vec{x}}$
Then the dynamics of the controllable form are
\begin{align}
\hat{\vec{x}}_{k+1}=&\mat{A}_{cf}\hat{\vec{x}}_k+\mat{B}_{cf}u_k : \mat{A}_{cf}=\mat{T}\mat{A}\mat{T}^{-1} \wedge \mat{B}_{cf}=\mat{T}\mat{B}\\
y_k=&\mat{C}_{cf}\hat{\vec{x}}_k + b_0u_k : \mat{C}_{cf}=\mat{C}\mat{T}^{-1}\nonumber
\end{align}
where $\mat{T}$ can be calculated as follows:

Let 
\begin{equation}
\mat{R}=[\begin{array}{ccccc}\mat{B}&\mat{A}\mat{B}&\mat{A}^2\mat{B}&\hdots&\mat{A}^{n-1}\mat{B}\end{array}]
\label{eq:rncf}
\end{equation}
be the reachability matrix of the system, and
\begin{equation}
\mat{R}_{cf}=\left[\begin{array}{ccccc}1&a_1&a_2&\hdots&a_{n-1}\\0&1&a_1&\hdots&a_{n-2}\\ \vdots&\ddots&\ddots&\ddots&\ddots\end{array}\right]
\label{eq:rcf}
\end{equation}
the reachability matrix of the canonical form. Then 
\begin{equation}
\mat{T}=\mat{R}_{cf}\mat{R}^{-1}
\label{eq:to_cf}
\end{equation}


\end{document}
