[X.Y] -> means reviewer X comment Y

---
Reviewer 1
---
[1.1] It would be good to more clearly describe on those two points how your 
methods differ in the results that are produced, and in the cost of producing 
those results. E.g., if both additional factors are removed, does your method 
perform identical to earlier methods? As each factor is added, how much does 
it impact feasibility and cost of finding a solution?

[Elizabeth]

---
Reviewer 2
---

[2.1] Given these motivating points, there is actually a large body of 
work in the context of abstraction based controller synthesis for 
cyber-physical systems (CPS) which is not cited by the authors 
tackling these challenges. Furthermore, most of the work in this 
community can actually handle a lot more powerful specifications 
(beyond safety) and plant models (up to non-linear models without 
stability assumptions or stochastic models) by providing a fully 
automated design scheme as envisioned by the authors. Here is a short 
list of some related works that I have at the top of my head, 
but there are many more:

- textbook on the topic:
[1] Paulo Tabuada, Verification and Control of Hybrid Systems - 
A Symbolic Approach,  2009
(http://www.springer.com/de/book/9781441902238)

- work especially on safety specifications:
[2] Antoine Girard, Controller synthesis for safety and reachability 
via approximate bisimulation, 2012 
(http://www.sciencedirect.com/science/article/pii/S000510981200088X)

- work especially on LTI systems:
[3] Paulo Tabuada, Symbolic models for linear control systems 
with disturbances, 2007 (http://ieeexplore.ieee.org/abstract/document/4434957/)

- some recent works that talk explicitly about how errors 
form digital controller implementations are handled by the framework:
[4] Jun Liu and Necmiye Ozay, Abstraction, Discretization, and 
Robustness in Temporal Logic Control of Dynamical Systems, 
2014 (http://web.eecs.umich.edu/~necmiye/pubs/LiuO_hscc14.pdf)

[5] Gunther Reissig, Alexander Weber, and Matthias Rungger, 
Feedback Refinement Relations for the Synthesis of Symbolic 
Controllers 2016 (http://ieeexplore.ieee.org/abstract/document/7519063/)

[6] Mahmoud Khaled, Mtthias Rungger, and Majid Zamani, 
Symbolic Models of Networked Control Systems: 
A Feedback Refinement Relation Approach, 2016 
(https://www.researchgate.net/profile/Majid_Zamani/publication/306017464_Symbolic_Models_of_Networked_Control_Systems_A_Feedback_Refinement_Relation_Approach/links/5857b7db08ae544d8863bef1.pdf)

[Response] The above referenced literature relates to verification and synthesis of transition systems 
(i.e., LTL or similar discrete-state models), which correspond to sound abstractions of a 
continuous state model. The synthesised controllers are of a different type as the ones 
we synthesise, although they may address a similar control objective. However, the main 
difference of that approaches if compared to ours is that they are not well suited 
for digital systems considering finite word-length (FWL) effects. To quote the cited 
references: "Given the fact that an abstraction may very well comprise millions of states 
and billions of transitions [7], [14], an implementation of the refined controller 
is often too expensive to be practical." (taken from reference [5]). By comparison our 
implementation is a simple controller that operates on a limited number of bits 
with very few instructions per cycle. This also relates to our ability to deal with 
corner cases where our abstraction is more precise, whereas LTL approaches would be too 
costly implementation-wise to achieve similar precision. Furthermore, the mentioned literature 
does not explicitly address fixed-point arithmetic issues (no mention about number of bits 
in the implementation), which means that it lacks in description to easily attain our 
desired control objectives without preprocessing.

[2.2] Given the fact that the authors do not compare their work to the literature 
mentioned above, in which I think the proposed problem is already solved, 
I suggest to reject the paper.

[Lucas]

[2.3] The authors should consider resubmitting the paper if they can show that 
they can generate solutions to problems which are not solvable by those 
abstraction based techniques mentioned above or if they can show that 
their method is solving the problem in a more efficient or less complex way.

[Lucas]


---
Reviewer 3
---

[3.1] In addition, the experimental section misses some details 
which would be helpful to get a better insight into the algorithm 
behaviour.

[Pascal]

[3.2] I am not sure method (a) will scale due to exponential number of
checks in the verification phase. Generally, I am missing a break down
of the performance into phases (synthesis + verification). In
particular, I am wondering which phase dominates the whole run-time.

[Response] CEGIS frameworks reason over a potentially exponential space of 
solution programs, which need to satisfy a property over an exponential input range.  
The reviewer is thus correct in identifying the input range complexity as exponential.  
However, inductive synthesis algorithms as CEGIS are designed to heuristically find
universally compliant programs with only a limited set of counterexamples.  Whether
such an inductive generalisation is possible strongly depends on the search domain.
Our experimental results support the conjecture that this is the case for
our controller synthesis problem: The majority of benchmarks can be synthesised
using less than 5 counterexamples.  In our experiments, 52% of the time was spent
in the synthesis and 48% in the CEGIS verification stage.

[Elizabeth]

[3.3] For the abstraction-based method, I am missing one of the main
indicators relevant for abstraction-based methods and namely number of
refinements for each experiment.

[Response] There are up to 2 refinements in our benchmarks set.

[3.4] * On the naive algorithm: 

- I am confused about the completeness argument: The statement by the
  authors that a stable converges towards an origin seems to be
  correct, which is relevant for *stability*. Yet, I am not sure how
  the authors can derive their guarantees in case of *safety*. Could
  you please clarify?

[Elizabeth]

[3.5] * On the abstraction-based algorithm: 

- How do you use characteristic polynomial in the algorithm? In other
  words, I could not find any references to P_a(x) from step 1(a) in
  any further steps.
  The characteristic polynomial is used to derive constraints on the controller coefficients based on Jury's Criterion (\phi_stability in step 2).

- It is not clear how you derive constraints on the eigen value
  structure based on a counter-example. Please clarify.
  The counter-example corresponds to a support function of the safe polyhedra whose limit is violated.
  Given a set of initial states (vertices), we do a back transformation to find a set of support functions in the abstract dynamics that correspond to each initial state that potentially cause the violation.
  The violation then corresponds to a vertex in the abstract dynamics relating to a set of iterations that are closest to it. Knowing the constraint on the abstract dynamics and the iteration allows us to build a constraint on the corresponding eigenvalue. The solution is sound but not complete (ie we may not be able to refine past a certain point).

[Dario]
