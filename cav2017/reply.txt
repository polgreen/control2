---
Reviewer 1
---
[1.1] It would be good to more clearly describe on those two points how your 
methods differ in the results that are produced, and in the cost of producing 
those results. E.g., if both additional factors are removed, does your method 
perform identical to earlier methods? As each factor is added, how much does 
it impact feasibility and cost of finding a solution?

[Elizabeth]
The reviewer raises an interesting question, unfortunately due to the running time of the benchmarks we will not have time to answer this during the review period. 

Related Work (R2)

The mentioned literature relates to verification and synthesis of transition systems 
(i.e., LTL or similar discrete-state models), which correspond to finite abstractions of a 
continuous-state control model: let us emphasise that these are, in nature, quite different than the method proposed here. 
The synthesised controllers are as well of a different type than those we synthesise here, 
although they may address a similar control objective (safety requirements). 

The main limitation of the approaches in the literature is that they fail to address the whole set of 
model uncertainties and imprecisions (quantisation, FWL representation) that our method tackles: 
for instance, they are not well suited to digital systems with finite word-length (FWL) effects. 
To quote the cited references [18]: "Given the fact that an abstraction may very well comprise millions of states 
and billions of transitions, an implementation of the refined controller is often too expensive to be practical." 
By comparison, our implementation is a simple controller that operates on a limited number of bits 
with very few instructions per cycle. This also relates to our ability to deal with 
corner cases where our abstraction is more precise, whereas LTL approaches would be too 
costly implementation-wise to achieve similar precision. Furthermore, the mentioned literature 
does not explicitly address fixed-point arithmetic issues (no mention about number of bits 
in the implementation), which means that it lacks in description to easily attain our 
desired control objectives without preprocessing. 

We would like to stress that we have cited related work in verification, synthesis, and optimisation of digital controllers that consider FWL effects 
(cf. references [2,5,9,12,17,19,24,25,26,27,33,34] in the present paper). 
In particular, work in [18] is a key contribution by authors mentioned by the reviewer; 
[20, 25, 26, 33, 34] are from hybrid systems literature, [27, 28, 29] are from control literature (in its connection with formal methods); 
[24] is from literature on embedded systems 

Novelty (R1,R2,R3)

Our work synthesises digital stabilising controllers with considerations to their implementation 
aspects, i.e., fixed-point arithmetic and finite word length. In contrast to previous work, 
this submission exploits current advances in bit-accurate verification of programs to obtain 
a synthesiser for software-implemented digital control, which is correct by construction (cf. section 2). 
Thus, the present approach can avoid fragility problems in robust controllers designed for state-space equations, 
which could be overlooked by other existing methods in view of their underestimation of FWL effects. 
As a result, the present paper solves a different problem w.r.t. the references mentioned in the reviews. 
The main novelty in our approach, compared to the mentioned references, is that it is algorithmically and numerically 
sound over implementation aspects. Additionally, as described in section 5, it is able 
to fully automatically synthesise stable controllers for intricate plant models within a reasonable amount of time; 
the median run-time for our benchmark set is 7.9 seconds, 
and most controllers can be synthesised in less than 17.2 seconds. 
The two proposed approaches complement each other and together solve all benchmarks, 
which have been derived from modern control literature. 

---
Reviewer 3
---

[3.1] In addition, the experimental section misses some details 
which would be helpful to get a better insight into the algorithm 
behaviour.

[Pascal]

Scalability (R3)

CEGIS frameworks reason over an exponential space of solution programs, 
which need to satisfy a property over an exponential input range. 
Still, inductive synthesis algorithms as CEGIS are designed to heuristically find 
universally compliant programs with only a limited set of counterexamples.  
Whether this inductive generalisation is possible depends on the search domain, 
but CEGIS literature suggests this is generally the case in practise.  
Our experimental results confirm that it applies to our controller synthesis domain: 
all successful benchmarks are synthesised using 5 counterexamples or less (cf. section 5).  
In our experiments, 52% of the time was spent in the synthesis and 48% in the verification phase.

Experimental evaluation (R3)

The abstraction-based method produces up to 2 refinements in our benchmarks set.


[3.4] * On the naive algorithm: 

- I am confused about the completeness argument: The statement by the
  authors that a stable converges towards an origin seems to be
  correct, which is relevant for *stability*. Yet, I am not sure how
  the authors can derive their guarantees in case of *safety*. Could
  you please clarify?

A stable system is characterised by the state values converging towards an origin. 
By computing the eigenvalues, we can compute the number of time steps for a full rotation (whenever existing) to be complete. 
We can then export this knowledge to check for safety:  
if the state values have not violated the safety property in the first full rotation, 
then the state values shall not violate the safety property ever.

Abstraction-based algorithm (R3) 

The characteristic polynomial is used to derive constraints on the controller coefficients based on Jury's Criterion 
(\phi_stability in step 2, cf. section 4.4).

Given a set of initial states (vertices), we do a back transformation to find a set of support 
functions in the abstract dynamics, which correspond to each initial state potentially causing the violation (cf. section 4.4). 
The violation then corresponds to a vertex in the abstract dynamics, relating to a set of iterations that are closest to it. 
Given the constraint on the abstract dynamics and the iteration, 
they allow us to build a constraint on the corresponding eigenvalue. 
This solution is sound, but not complete (i.e., we might not be able to refine past a certain point).
