---
Reviewer 1
---
[1.1] It would be good to more clearly describe on those two points how your 
methods differ in the results that are produced, and in the cost of producing 
those results. E.g., if both additional factors are removed, does your method 
perform identical to earlier methods? As each factor is added, how much does 
it impact feasibility and cost of finding a solution?

There are three new aspects to our algorithm: introduction of the safety specification, 
accounting for the error due to using a fixed-point controller, and accounting for the 
error due to the finite precision representation of the plant. Undoubtedly adding in 
these additional constraints increases the size of the synthesis/verification problem, 
and we have not explored the relative size of the increase as each factor is added. 

Our architecture is designed to synthesise safe and sound controllers, and, as a result, 
it is more complex than the current state-of-the-art in control synthesis, which simply 
find eigenvalues and places poles, often using the precision available in Matlab. 
Consequently, synthesising a stable, but potentially unsound and unsafe, controller 
with our approach may not be as fast as conventional control synthesis methods. 
Having said that, it should only require one CEGIS loop, so we don't think it would 
do too badly.

The addition of the above factors can change the results obtained: Stable controllers 
obtained by current methods may not be stable, when fixed word-length and quantisation 
error is taken into account, an example of this is shown in https://arxiv.org/abs/1610.04761. 
For the problems we tackled there are many stable controllers that do not satisfy the safety 
specifications, and there is no way of guaranteeing that a stable controller synthesised by 
existing methods would satisfy the safety specification. 


Related Work (R2)

The mentioned literature relates to verification and synthesis of transition systems 
(i.e., LTL or similar discrete-state models), which correspond to finite abstractions of a 
continuous-state control model: let us emphasise that these are, in nature, quite different than the method proposed here. 
The synthesised controllers are as well of a different type than those we synthesise here, 
although they may address a similar control objective (safety requirements). 

The main limitation of the approaches in the literature is that they fail to address the whole set of 
model uncertainties and imprecisions (quantisation, FWL representation) that our method tackles: 
for instance, they are not well suited to digital systems with finite word-length (FWL) effects. 
To quote the cited references [18]: "Given the fact that an abstraction may very well comprise millions of states 
and billions of transitions, an implementation of the refined controller is often too expensive to be practical." 
By comparison, our implementation is a simple controller that operates on a limited number of bits 
with very few instructions per cycle. This also relates to our ability to deal with 
corner cases where our abstraction is more precise, whereas LTL approaches would be too 
costly implementation-wise to achieve similar precision. Furthermore, the mentioned literature 
does not explicitly address fixed-point arithmetic issues (no mention about number of bits 
in the implementation), which means that it lacks in description to easily attain our 
desired control objectives without preprocessing. 

We would like to stress that we have cited related work in verification, synthesis, and optimisation of digital controllers that consider FWL effects 
(cf. references [2,5,9,12,17,19,24,25,26,27,33,34] in the present paper). 
In particular, work in [18] is a key contribution by authors mentioned by the reviewer; 
[20, 25, 26, 33, 34] are from hybrid systems literature, [27, 28, 29] are from control literature (in its connection with formal methods); 
[24] is from literature on embedded systems 

Novelty (R1,R2,R3)

Our work synthesises digital stabilising controllers with considerations to their implementation 
aspects, i.e., fixed-point arithmetic and finite word length. In contrast to previous work, 
this submission exploits current advances in bit-accurate verification of programs to obtain 
a synthesiser for software-implemented digital control, which is correct by construction (cf. section 2). 
Thus, the present approach can avoid fragility problems in robust controllers designed for state-space equations, 
which could be overlooked by other existing methods in view of their underestimation of FWL effects. 
As a result, the present paper solves a different problem w.r.t. the references mentioned in the reviews. 
The main novelty in our approach, compared to the mentioned references, is that it is algorithmically and numerically 
sound over implementation aspects. Additionally, as described in section 5, it is able 
to fully automatically synthesise stable controllers for intricate plant models within a reasonable amount of time; 
the median run-time for our benchmark set is 7.9 seconds, 
and most controllers can be synthesised in less than 17.2 seconds. 
The two proposed approaches complement each other and together solve all benchmarks, 
which have been derived from modern control literature. 

---
Reviewer 3
---

[3.1] In addition, the experimental section misses some details 
which would be helpful to get a better insight into the algorithm 
behaviour.

[Pascal]

Scalability (R3)

CEGIS frameworks reason over an exponential space of solution programs, 
which need to satisfy a property over an exponential input range. 
Still, inductive synthesis algorithms as CEGIS are designed to heuristically find 
universally compliant programs with only a limited set of counterexamples.  
Whether this inductive generalisation is possible depends on the search domain, 
but CEGIS literature suggests this is generally the case in practise.  
Our experimental results confirm that it applies to our controller synthesis domain: 
all successful benchmarks are synthesised using 5 counterexamples or less (cf. section 5).  
In our experiments, 52% of the time was spent in the synthesis and 48% in the verification phase.

Experimental evaluation (R3)

The abstraction-based method produces up to 2 refinements in our benchmarks set.

Naive algorithm (R3) 

A stable system is characterised by the state values converging towards an origin. 
By computing the eigenvalues, we can compute the number of time steps for a 
full rotation (whenever existing) to be complete. We can then export this knowledge 
to check for safety: if the state values have not violated the safety property 
in the first full rotation, then the state values shall not violate the safety 
property ever.

Abstraction-based algorithm (R3) 

The characteristic polynomial is used to derive constraints on the controller coefficients based on Jury's Criterion 
(\phi_stability in step 2, cf. section 4.4).

Given a set of initial states (vertices), we do a back transformation to find a set of support 
functions in the abstract dynamics, which correspond to each initial state potentially causing the violation (cf. section 4.4). 
The violation then corresponds to a vertex in the abstract dynamics, relating to a set of iterations that are closest to it. 
Given the constraint on the abstract dynamics and the iteration, 
they allow us to build a constraint on the corresponding eigenvalue. 
This solution is sound, but not complete (i.e., we might not be able to refine past a certain point).
