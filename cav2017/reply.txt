[X.Y] -> means reviewer X comment Y

---
Reviewer 1
---
[1.1] It would be good to more clearly describe on those two points how your 
methods differ in the results that are produced, and in the cost of producing 
those results. E.g., if both additional factors are removed, does your method 
perform identical to earlier methods? As each factor is added, how much does 
it impact feasibility and cost of finding a solution?

[Elizabeth]

Related Work (R2)

The mentioned literature relates to verification and synthesis of transition systems 
(i.e., LTL or similar discrete-state models), which correspond to sound abstractions of a 
continuous state model. The synthesised controllers are of a different type as the ones 
we synthesise here, although they may address a similar control objective. However, the main 
difference of that approaches if compared to ours is that they are not well suited 
for digital systems considering finite word-length (FWL) effects. To quote the cited 
references: "Given the fact that an abstraction may very well comprise millions of states 
and billions of transitions [7], [14], an implementation of the refined controller 
is often too expensive to be practical." (taken from reference given by the reviewer [5]). 
By comparison our implementation is a simple controller that operates on a limited number of bits 
with very few instructions per cycle. This also relates to our ability to deal with 
corner cases where our abstraction is more precise, whereas LTL approaches would be too 
costly implementation-wise to achieve similar precision. Furthermore, the mentioned literature 
does not explicitly address fixed-point arithmetic issues (no mention about number of bits 
in the implementation), which means that it lacks in description to easily attain our 
desired control objectives without preprocessing (cf. references [2,5,9,17,19] in the 
present paper).

Novelty (R1,R2,R3)

Our work synthesizes digital stabilizing controllers with considerations to the implementation 
aspects, i.e., fixed-point arithmetic and the word-length. In contrast to previous work, 
the present work exlpoits current advances in bit-accurate verification of programs to obtain 
a synthesizer for software-implemented digital control, which is indeed correct by its method of 
construction (cf. section 2). Thus, the present approaches can avoid fragility problems 
in robust controllers, which could be overlooked by other existing methods due to 
underestimating of FWL effects. As a result, the present paper solves a different problem 
w.r.t. the references mentioned by the second reviewer (cf. section 2). The main novelty in our 
approaches if compared to the mentioned references is that they are algorithmically and numerically 
sound considering implementation aspects. Additionally, as described in section 5, both approaches are able 
to synthesize stable controllers for most intricate plant models within a reasonable amount 
of time fully automatically. In particular, both approaches complement each other and together 
solve all benchmarks, which have been derived from the control literature.

---
Reviewer 3
---

[3.1] In addition, the experimental section misses some details 
which would be helpful to get a better insight into the algorithm 
behaviour.

[Pascal]

Scalability (R3)

CEGIS frameworks reason over an exponential space of solution programs, which need 
to satisfy a property over an exponential input range. The reviewer's remark is thus correct.  
However, inductive synthesis algorithms as CEGIS are designed to heuristically find 
universally compliant programs with only a limited set of counterexamples.  
Whether this inductive generalisation is possible depends on the search domain, 
but CEGIS literature suggests this is generally the case in practise.  Our experimental results 
confirm that it applies to our controller synthesis domain: All successful benchmarks are synthesised
using 5 counterexamples or less (cf. section 5).  In our experiments, 52% of the time 
was spent in the synthesis and 48% in the verification phase.

[Elizabeth]

[3.3] For the abstraction-based method, I am missing one of the main
indicators relevant for abstraction-based methods and namely number of
refinements for each experiment.

[Response] There are up to 2 refinements in our benchmarks set related to
the abstraction-based method.

[3.4] * On the naive algorithm: 

- I am confused about the completeness argument: The statement by the
  authors that a stable converges towards an origin seems to be
  correct, which is relevant for *stability*. Yet, I am not sure how
  the authors can derive their guarantees in case of *safety*. Could
  you please clarify?

[Elizabeth]

[3.5] * On the abstraction-based algorithm: 

- How do you use characteristic polynomial in the algorithm? In other
  words, I could not find any references to P_a(x) from step 1(a) in
  any further steps.
  The characteristic polynomial is used to derive constraints on the controller coefficients based on Jury's Criterion (\phi_stability in step 2).

- It is not clear how you derive constraints on the eigen value
  structure based on a counter-example. Please clarify.
  The counter-example corresponds to a support function of the safe polyhedra whose limit is violated.
  
  [Response] Given a set of initial states (vertices), we do a back transformation to find a set of support 
  functions in the abstract dynamics, which correspond to each initial state that potentially cause the violation (cf. section 4.4).
  The violation then corresponds to a vertex in the abstract dynamics, relating to a set of iterations that are closest to it. 
  Given the constraint on the abstract dynamics and the iteration, they allow us to build a constraint on the corresponding eigenvalue. 
  The solution is sound but not complete (i.e., we might not be able to refine past a certain point).
