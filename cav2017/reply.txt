---
Reviewer 1
---
[1.1] It would be good to more clearly describe on those two points how your 
methods differ in the results that are produced, and in the cost of producing 
those results. E.g., if both additional factors are removed, does your method 
perform identical to earlier methods? As each factor is added, how much does 
it impact feasibility and cost of finding a solution?

There are three new aspects to our algorithm: introduction of the safety specification, accounting for the error due to using a fixed-point controller, and accounting for the error due to the finite precision representation of the plant. Undoubtedly adding in these additional constraints increases the size of the synthesis/verification problem, and we have not explored the relative size of the increase as each factor is added. 

Our architecture is designed to synthesise safe and sound controllers, and, as a result, it is more complex than the current state-of-the-art in control synthesis, which simply find eigenvalues and places poles, often using the precision available in Matlab. Consequently, synthesising a stable, but potentially unsound and unsafe, controller with our approach may not be as fast as conventional control synthesis methods. 
Having said that, it should only require one CEGIS loop, so we don't think it would do too badly.

The addition of the above factors can change the results obtained: Stable controllers obtained by current methods may not be stable when fixed word length and quantisation error is taken into account, an example of this is shown in https://arxiv.org/abs/1610.04761. For the problems we tackled there are many stable controllers that do not satisfy the safety specifications, and there is no way of guaranteeing that a stable controller synthesised by existing methods would satisfy the safety specification. 


There are three new aspects to our algorithm: introduction of the safety specification, accounting for the error due to using a fixed-point controller, 
and accounting for the error due to the finite precision representation of the plant. 
Undoubtedly adding in these additional constraints increases the size of the synthesis/verification problem, 
and we have not explored the relative size of the increase as each factor is added. 

Our architecture is designed to synthesise safe and sound controllers, and, as a result, it is more complex than the current state-of-the-art in control synthesis, 
which simply find eigenvalues and places poles, often using the precision available in Matlab. 
Consequently, synthesising a stable, but potentially unsound and unsafe, controller with our approach may not be as fast as conventional control synthesis methods. 
Having said that, it would only require one CEGIS loop, so we don't think it would do too badly.

The addition of the above factors can change the results obtained: 
Stable controllers obtained by current methods may not be stable when fixed word length and quantisation error is taken into account â€”  
an example of this is shown in https://arxiv.org/abs/1610.04761. 
For the problems we tackled there are many stable controllers that do not satisfy the safety specifications, 
and there is no way of guaranteeing that a stable controller synthesised by existing methods would satisfy the safety specification.

Related Work (R2)

The limitation of the approaches in the literature is that they do not address the combined model uncertainties, imprecisions, and restrictions (particularly, FWL representation) that our method tackles: they are not well suited to digital systems with limited resources. To quote a reference cited by the reviewer: "Given the fact that an abstraction may very well comprise millions of states and billions of transitions, an implementation of the refined controller is often too expensive to be practical." By comparison, our implementation operates on a limited number of bits and a few instruction cycles. This relates to our ability to deal with corner cases where our abstraction is more precise, whereas LTL approaches would be too costly implementation-wise to achieve similar precision. The mentioned literature does not explicitly address fixed-point arithmetic (no mention about number of bits in the implementation), which means that it lacks in description to attain our desired control objectives. 

We have cited related work in verification, synthesis, and optimisation of digital controllers that consider FWL effects 
(cf. references [2,5,9,12,17,19,24,25,26,27,33,34]). In particular, [18] is a key contribution by authors mentioned by the reviewer; [20, 25, 26, 33, 34] are from hybrid systems literature, [27, 28, 29] are from control literature; [24] is from literature on embedded systems.

Novelty (R1,R2,R3)

Our work synthesises digital stabilising controllers w.r.t. their implementation aspects (fixed-point arithmetic and FWL). In contrast to previous work, this submission exploits current advances in bit-accurate verification of programs to obtain a synthesiser for software-implemented digital control, which is correct by construction (cf. section 2). The presented approach can avoid fragility problems in robust controllers designed for state-space equations, which could be overlooked by other existing methods in view of their underestimation of FWL effects.  

CEGIS of Safe Controllers (R1)

There are three new aspects to our algorithm: safety specification, accounting for the error due to using a fixed-point controller, and accounting for the plant finite precision representation (cf. section 4). The safety specification increases the verification problem size, hence a configuration with just a stability property is expected to perform faster. The quantisation error introduces much less complexity to the verification problem and thus affects runtime only marginally. Lastly, removing the precise fixed-point model from the analysis would be an impractical comparison since our whole choice of synthesis tools is based on fixed-point precision. It would completely eliminate the soundness guarantees that we establish over comparable work.

Scalability (R3)

CEGIS frameworks reason over an exponential space of solution programs which need to satisfy a property over an exponential input range. Inductive synthesis algorithms such as CEGIS are designed to heuristically find universally compliant programs with only a limited set of counterexamples. Whether this inductive generalisation is possible depends on the search domain, but CEGIS literature suggests this is generally the case in practise.  In our experiments, all successful benchmarks are synthesised using 5 counterexamples or less (cf. section 5); 52% of the time was spent in the synthesis and 48% in the verification phase.