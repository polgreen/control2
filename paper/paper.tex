\documentclass{sig-alternate-05-2015}

\usepackage{url}                  % format URLs
\usepackage{listings}          % format code
\lstset{
  mathescape, 
  language={C},
  basicstyle=\small
}
\usepackage{enumitem}      % adjust spacing in enums
\usepackage[colorlinks=true,allcolors=blue,breaklinks,draft=false]{hyperref}   
\usepackage{graphicx}
\usepackage{float,subfig}
\usepackage{xspace,framed}
\usepackage{colortbl}
\usepackage{calc}
\usepackage[dvipsnames]{xcolor}
\usepackage{amssymb,amsmath,amsfonts} 
\usepackage{mathtools}

\usepackage{algorithm}
\usepackage{amsfonts}
\usepackage{multicol}
\usepackage{multirow}
\usepackage{tikz}
\usetikzlibrary{positioning, automata, shapes.arrows, calc, shapes, arrows}
\usepackage[justification=centering]{caption}
\usepackage{stmaryrd}
\usepackage{hhline}
\usepackage{pifont}
\usepackage{longtable}
\usepackage{afterpage}
\usepackage{wasysym}
%\usetikzlibrary{decorations}
%\usetikzlibrary{decorations.pathmorphing}

\newcommand{\blue}[1]{{\color{blue}#1}}
\newcommand{\red}[1]{{\color{red}#1}}
\newcommand{\green}[1]{{\color{green}#1}}

\newtheorem{myassumption}{Assumption}
\newtheorem{mylemma}{Lemma}
\newtheorem{myprop}{Proposition}

\include{macros}

\begin{document}

% Copyright
\setcopyright{acmcopyright}

% DOI
\doi{}

% ISBN
\isbn{}

%
% --- Author Metadata here ---
%\conferenceinfo{WOODSTOCK}{'97 El Paso, Texas USA}
%\CopyrightYear{2007} % Allows default copyright year (20XX) to be over-ridden - IF NEED BE.
%\crdata{0-12345-67-8/90/01}  % Allows default copyright data (0-89791-88-6/97/05) to be over-ridden - IF NEED BE.
% --- End of Author Metadata ---

\title{
Sound Automated Synthesis of Digital Controllers
%Counterexample-guided Synthesis of Closed-loop Digital Control Systems
}
%\subtitle{[Extended Abstract]
%\titlenote{A full version of this paper is available as
%\textit{Author's Guide to Preparing ACM SIG Proceedings Using
%\LaTeX$2_\epsilon$\ and BibTeX} at
%\texttt{www.acm.org/eaddress.htm}}}
%
% You need the command \numberofauthors to handle the 'placement
% and alignment' of the authors beneath the title.
%
% For aesthetic reasons, we recommend 'three authors at a time'
% i.e. three 'name/affiliation blocks' be placed beneath the title.
%
% NOTE: You are NOT restricted in how many 'rows' of
% "name/affiliations" may appear. We just ask that you restrict
% the number of 'columns' to three.
%
% Because of the available 'opening page real-estate'
% we ask you to refrain from putting more than six authors
% (two rows with three columns) beneath the article title.
% More than six makes the first-page appear very cluttered indeed.
%
% Use the \alignauthor commands to handle the names
% and affiliations for an 'aesthetic maximum' of six authors.
% Add names, affiliations, addresses for
% the seventh etc. author(s) as the argument for the
% \additionalauthors command.
% These 'additional authors' will be output/set for you
% without further effort on your part as the last section in
% the body of your article BEFORE References or any Appendices.

%\numberofauthors{8} %  in this sample file, there are a *total*
% of EIGHT authors. SIX appear on the 'first-page' (for formatting
% reasons) and the remaining two appear in the \additionalauthors section.
%
%% \author{
%% % You can go ahead and credit any number of authors here,
%% % e.g. one 'row of three' or two rows (consisting of one row of three
%% % and a second row of one, two or three).
%% %
%% % The command \alignauthor (no curly braces needed) should
%% % precede each author name, affiliation/snail-mail address and
%% % e-mail address. Additionally, tag each line of
%% % affiliation/address with \affaddr, and tag the
%% % e-mail address with \email.
%% %
%% % 1st. author
%% \alignauthor
%% Ben Trovato\titlenote{Dr.~Trovato insisted his name be first.}\\
%%        \affaddr{Institute for Clarity in Documentation}\\
%%        \affaddr{1932 Wallamaloo Lane}\\
%%        \affaddr{Wallamaloo, New Zealand}\\
%%        \email{trovato@corporation.com}
%% % 2nd. author
%% \alignauthor
%% G.K.M. Tobin\titlenote{The secretary disavows
%% any knowledge of this author's actions.}\\
%%        \affaddr{Institute for Clarity in Documentation}\\
%%        \affaddr{P.O. Box 1212}\\
%%        \affaddr{Dublin, Ohio 43017-6221}\\
%%        \email{webmaster@marysville-ohio.com}
%% }

\author{Author names omitted for review}

\maketitle

\begin{abstract}
%
Modern control systems are by and large implemented via digital
microcontrollers, which are designed to work in an embedded environment,
within a dynamical plant that can present physical components.
%
This poses a new dimension to the problem of controllers synthesis, which is
classically studied in digital control literature.
%
In this study, we plan to provide a principled approach to extend this
literature in a number of directions: we are interested in quantitative
tasks; we focus on automated correct-by-construction synthesis algorithms, as
opposed to verification objectives; and we encompass the complete range of
approximations, related to time discretisation, quantisation effects, and
finite-precision representations (with related rounding errors).  To this
end, we propose a CEGIS-based solution that uses inductive 
synthesis in conjunction with a digital verification algorithm to find a
parametric solution for a digital controller given a continuous 
plant specification.
%
\end{abstract}

%
%  Use this command to print the description
%
\printccsdesc

% We no longer use \terms command
%\terms{Theory}

\keywords{Control synthesis, CEGIS, finite word length, time sampling, quantisation, interval analysis}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

Modern implementations of embedded control have proliferated with the
availability of low cost devices that can perform simple tasks for linear
control, spanning many areas such as environmental control and robotic
manipulations~\cite{astrom1997computer,Franklin15}.  The downside to this
approach is that in order to achieve low prices, devices are often limited
in their capabilities, be it a low number of gates in an FPGA or short word
lengths for microcontrollers.  In most cases, a floating-point implementation
is not feasible and the system can benefit from the added resolution of a
fixed-point representation.  The ubiquity of these devices requires that
they have a robust design that ensures the correct behaviour in a number of
different environments.
%
% For this reason it is
% necessary to provide design tools that formally verify the correctness
% of the digital controller.

There has been previous work to formally verify uncertain linear systems
stability in digital controllers with considerations to the implementation
aspects ({\it i.e.}, fixed-point arithmetic and word-length)~\cite{Bessa16}. 
In particular, Bessa {\it et al.} consider finite-word length (FWL) effects
over digital controllers and also parameter uncertainties in the context of
verifying the (so-called) robust non-fragile
stability~\cite{bhattacharyya97}.  However, the authors do not consider the
compete range of approximations, related to time discretisation, and
quantisation effects.  As a result, the stability verification method
proposed by Bessa {\it et al.} is incomplete, given that false alarms can be
produced due to quantisation effects.  Additionally, the authors do not
find a parametric solution for a digital controller given as a continuous
plant specification, in order to synthesize the controller implementation.

Our work makes two major contributions. First, we explore the automatic synthesis 
of {\em correct-by-construction} digital controllers, which reduces the development
cost and design time for a number of models.  In particular, we are
interested in synthesising controllers for {\em hybrid closed-loop systems},
{\it i.e.}, embedded controllers along with a model of their physical
environment (the plant), which are {\em stable}.  Due to the complexity of
such systems, we focus on linear models with known configurations to perform
parametric synthesis of the controller dynamics.

Second, since the digital control synthesis is performed over a hybrid model, 
where the plant displays a continuous behaviour and the controller operates in
both discrete time and state-space, we initially translate the problem into
a single domain, which represents a bi-simulation of the original dynamics. 
Given our primary interest in evaluating digital effects in addition to
stability, we have modeled a digital equivalent of the plant by evaluating
the effects of the quantisers (A/D and D/A converters) as time
discretisation elements with quantisation noise.  The resulting closed loop
system is a program loop working over bit-vectors of fixed-point arithmetic
with fixed word length.  The deterministic effect of the FWL is considered
and quantization errors are included in the model as an additive uncertainty, 
which must be taken into account for the correct synthesis of the robust controller
for linear systems with parametric uncertainties.

%\begin{figure}
%\centering
%\resizebox{.35\textwidth}{!}{
% \begin{tikzpicture}[scale=0.3,-,>=stealth',shorten >=.2pt,auto,
%     semithick, initial text=, ampersand replacement=\&,]

%  \matrix[nodes={draw, fill=none, shape=rectangle, minimum height=.2cm, minimum width=.2cm, align=center}, row sep=.5cm, column sep=.5cm] {
%   \coordinate (aux0);
%   \& \node[circle] (circle) {}; 
%   \& \node[fill=yellow!20] (da) {{\sc D/A}}; 
%   \& \node[fill=yellow!20] (p) {{\sc P}};
%   \& \node[fill=yellow!20] (ad) {{\sc A/D}}; 
%   \& \coordinate (aux1);\\
%   \& \coordinate (aux3); 
%   \&
%   \&
%   \node[fill=yellow!20] (c) {C};
%   \& 
%   \& \coordinate (aux2);\\
%  };


%  \path[->] (aux0) edge (circle.west);
%  \path  
%   (circle.east) edge (da.west)
%   (da.east) edge (p.west)
%   (p.east) edge (ad.west)
%   (ad.east) edge (aux1.west)
%   (aux1.south) edge (aux2.north)
%   (aux2.west) edge (c.east)
%   (c.west) edge (aux3.east); 
%  \path[->]  (aux3.north) edge (circle.south);
% \end{tikzpicture}
%}
% \caption{Closed-Loop System. \label{fig:closed-system}}
%\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Preliminaries}

%\blue{Please insert a figure clearly distinguishing between continuous and discretised/quantised plant - a template is in a picture sent out by Lucas late last week. Please introduced signals on the plot. 

%Let us straighten the notations next. 
%We should have 
%\begin{itemize}
%\item 
%$G(s) = \frac{s^{M_G}b_{0}+s^{M_G-1}b_{1}+...+b_{M_G}}{s^{N_G}a_{0}+s^{N_G-1}a_{1}+...+a_{N_G}}$ -- this is the physical plant, which is focus of interest and to which we refer our specifications/properties 
%\item 
%$G(z, T) = \frac{\bar b_{0}+\bar b_{1}z^{-1}+...+\bar b_{M_G}z^{-M_G}}{\bar a_{0}+\bar a_{1}z^{-1}+...+\bar a_{N_G}z^{-N_G}}$ -- this is the time-discretised plant (notice the notation encompasses explicitly the sample time $T$; please write out explicitly the relationship between the $a_i$ and the $\bar a_i$ and likewise for the numerator's coefficients 
%(in particular, are the orders $M_G, N_G$ the same? 
%\item 
%we have $Y(z) = G(z,T) U(z)$; then, we introduce $\hat Y(z) \doteq Y(z) + \nu (z)$, so that 
%$$
%\frac{\hat Y(z)}{U(z)} = G(z,T) + \frac{\nu (z)}{U(z)} = G(z,T) + \Delta G_Q(z) \doteq \hat G(z) ,  
%$$ 
%where $\Delta G_Q(z)$ is an error term accounting for the quantisation effects 
%\item 
%finally, we encompass the errors resulting from employing finite parameters representation, 
%which we encompass in a term $\Delta G_P(z)$: is this error additive, so that we would get to a 
%$$
%\tilde G(z) \doteq \hat G(z) + \Delta G_P(z) = G(z,T) + \Delta G_Q(z) + \Delta G_P(z)?  
%$$ 
%Dario, can you write it out explicitly? In other words, if 
%$$
%\hat G(z) = G(z,T) + \Delta G_Q(z) = \frac{\hat b_{0}+\hat b_{1}z^{-1}+...+\hat b_{M_G}z^{-M_G}}{\hat a_{0}+\hat a_{1}z^{-1}+...+\hat a_{N_G}z^{-N_G}},  
%$$ 
%then what is the explicit expression of 
%$$
%\tilde G(z) = \frac{\tilde b_{0}+\tilde b_{1}z^{-1}+...+\tilde b_{M_G}z^{-M_G}}{\tilde a_{0}+\tilde a_{1}z^{-1}+...+\tilde a_{N_G}z^{-N_G}}?
%$$
%(Notice that the orders $M_G, N_G$ need to be properly taken care of.)
%\item 
%Now, it's over the transfer function $\tilde G(z)$ that we want to synthesise the parameters of a template $C(z)$. 
%This controller's transfer function will be subject to the same quantisation and precision limits as the plant's: 
%we need to argue that the way we do synthesis affects manipulation of quantities that relate to specific errors and be explicit about these. 
%\item[]
%\item 
%An additional source of error can be related to the fact that a plant transfer function, 
%per se a physical entity, is actually represented in a program imprecisely: 
%this would mean that $G(s)$ is actually 
%$$
%G^\ast (s) \doteq \frac{s^{M_G^\ast}b_{0}+s^{M_G^\ast-1}b_{1}+...+b_{M_G}}{s^{N_G^\ast}a_{0}+s^{N_G^\ast-1}a_{1}+...+a_{N_G}}, 
%$$ 
%which perhaps can indeed be re-written as $G^\ast (s) = G(s) + \Delta G_P(s)$? (This proof should come from that above.) 
%We should argue that this error is encompassed by the one derived above (or isn't it?). 
%\end{itemize}
%}

%------------------------------------
\subsection{Sampling and Holding in Hybrid Systems}
\label{ssec:SandH}
%------------------------------------

The digital controllers synthesized in this paper are typically used in closed loops with continuous (and physical) plants. Thus, the proposed approach has to consider dynamics of continuous parts of system ({\it e.g.}, plant) and discrete parts ({\it e.g.}, digital controller), {\it i.e.} the synthesized controller has to consider the issues related to the hybrid systems studies.

For this purpose, the design procedure is based on a discretized model for a continuous plant. Considering only transfer function models, we are interested in a $z$-domain transfer function that considers all the aspects about the continuous plant ($G(s)$) and the sampling and hold process.

Note that $G(z)$ is a discrete model of a real (and continuous) plant, {\it
i.e.}, a continuous model of the plant must be discretized to obtain the
discrete equivalent coefficients via ZOH
discretization.  

%\red{[why do we discuss the ZOH at this point?]}

Although there are several discretization methods available
in the literature~\cite{Franklin15}, the zero-order hold (ZOH)
discretization is more suitable for representing the sample and hold
processes that are typically employed in complex systems~\cite{istepanian2012digital}, {\it i.e.}, the ZOH discretization
models the exact effect of sampling and DAC interpolation over the plant.

\begin{myassumption}
%
The Sample and Hold of the ADC and the ZOH of the DAC are synchronized, {\it i.e.}, there is no delay between
sampling the plant output at ADC and updating the DAC accordingly. The DAC interpolator is an ideal ZOH.
%
\end{myassumption}

\begin{mylemma}\cite{astrom1997computer}
%
Given a synchronized ZOH input and sample and hold output on the plant with a sample time $T$ satisfying Nyquist's sampling criteria, the discrete pulse transfer function $G(z,T)$ is an exact z-domain representation of $G(s)$ which can be computed using the following formula: 
%
\begin{equation}
\label{eq:pulsetf}
G(z,T) = (1-z^{-1})\mathcal{Z}\left\lbrace{\mathcal{L}^{-1}\left\lbrace{\frac{G(s)}{s}}\right\rbrace_{t=kT}}\right\rbrace.
\end{equation}
%
For the sake of brevity, we will use the notation $G(z)$ to represent the pulse transfer function.
%
\end{mylemma}

%------------------------------------
\subsection{Verifying Closed-loop Control Systems}
\label{verifying-closed-loop-control-systems}
%------------------------------------

%\red{[This section and the next should be merged into a crisp section with the background on DSVerifier, if not included in previous work? 
%Please stick to the introduced notations. Please clarify what the function FWL does, compared to the general approximations introduced above.]}

%\red{Alessandro, I've made the changes as requested. Please let me know if this is good enough or if I made it too short}

%\textcolor{blue}{[IB: I'm proposing some changes in this section based on Alessandro's comments and trying to obtain a simpler and uniform notation.]}

In this study, the methodology used for verifying closed-loop digital
control system is based on the Digital-System Verifier
(DSVerifier)~\cite{IsmailBCFF15}, which checks the stability of control
systems considering finite-word length (FWL) effects in the digital
controller and uncertainty parameters in the plant model (plant
intervals)~\cite{Bessa16}.  Let $C(z)$ be a digital controller and $G(z)$ be
a plant model given as
%
\begin{align}
\small
\label{controller_plant_tf}
C(z)&=\frac{\beta_{0}+\beta_{1}z^{-1}+...+\beta_{M_C}z^{-M_C}}{\alpha_{0}+\alpha_{1}z^{-1}+...+\alpha_{N_C}z^{-N_C}}, \\
%\label{plant_tf}
G(z)&=\frac{b_{0}+b_{1}z^{-1}+...+b_{M_G}z^{-M_G}}{a_{0}+a_{1}z^{-1}+...+a_{N_G}z^{-N_G}}.
\end{align}
%
\noindent where $\vec{\beta}$ and $\vec{\alpha}$ are vectors containing the controller's coefficients;  
similarly $\vec{b}$ and $\vec{a}$ encompas the plant's coefficients;  
and $N_{(\cdot)}$ and $M_{(\cdot)}$ denote the number of poles and zeros for the corresponding block.



Uncertainties in $G(z)$ may appear due to uncertainties in $G(s)$ (\emph{i.e.} $\Delta{G}_p(s)$), errors in the numeric calculations, or roundoffs in the quantization.
These uncertainties may be parametrically expressed by an additive transfer function $\Delta G(z)$, resulting in a uncertain model $\hat{G}(z)$, such that:
\begin{equation}
\hat{G}(z)=G(z)+\Delta G(z),
\end{equation}
which will be represented by the following transfer function:
\begin{equation}
\hat{G}(z)=\frac{\hat{b}_{0}+\hat{b}_{1}z^{-1}+...+\hat{b}_{M_G}z^{-M_G}}{\hat{a}_{0}+\hat{a}_{1}z^{-1}+...+\hat{a}_{N_G}z^{-N_G}} : N_G \geq M_G .
\end{equation}
\red{[same order?]} 

The vector of parametric coefficient uncertainties $\Delta{p}$ of $\Delta{G}_p(z)$ is defined by:
\begin{equation}
\Delta{\vec{p}}=\begin{bmatrix}
\hat{b_{0}} - b_{0}\\
\hat{b_{1}} - b_{1}\\
\vdots \\
\hat{b}_{M_G} - b_{M_{G}}\\
\hat{a_{0}} - a_{0}\\
\hat{a_{1}} - a_{1}\\
\vdots\\
\hat{a}_{N_G} - a_{N_{G}}\\
\end{bmatrix}=\begin{bmatrix}
\vec{\hat{b}}\\
\vec{\hat{a}}
\end{bmatrix}-\begin{bmatrix}
\vec{b}\\
\vec{a}
\end{bmatrix}
\label{eq:uncertainty}
\end{equation}

A typical hybrid system, with a continuous plant and a discrete controller, is shown in Figure~\ref{fig:sampledsystem}, where the DAC and ADC converters introduce quantisation noises $\nu_{1}(z)$ and $\nu_{2}(z)$, $G(s)$ is the continuous-time plant model with parametric additive uncertainty $\Delta G_{P}(s)$ 
\red{[this Delta term now refers to the continuous plant? this is not what has been discussed before, nor what is in some of the plots.]} 
, $R(z)$ is the reference signal, $U(z)$ is the control signal, and $\hat{Y}(z)$ is the output signal affected by the noises and uncertainties in the closed-loop system.

\begin{figure*}[htb]
\centering

\tikzset{add/.style n args={4}{
    minimum width=6mm,
    path picture={
        \draw[circle] 
            (path picture bounding box.south east) -- (path picture bounding box.north west)
            (path picture bounding box.south west) -- (path picture bounding box.north east);
        \node[draw=none] at ($(path picture bounding box.south)+(0,0.13)$)     {\small #1};
        \node[draw=none] at ($(path picture bounding box.west)+(0.13,0)$)      {\small #2};
        \node[draw=none] at ($(path picture bounding box.north)+(0,-0.13)$)    {\small #3};
        \node[draw=none] at ($(path picture bounding box.east)+(-0.13,0)$)     {\small #4};
        }
    }
 }

\resizebox{.8\textwidth}{!}{
 \begin{tikzpicture}[scale=0.6,-,>=stealth',shorten >=.2pt,auto,
     semithick, initial text=, ampersand replacement=\&,]

  \matrix[nodes={draw, fill=none, shape=rectangle, minimum height=.2cm, minimum width=.2cm, align=center}, row sep=.6cm, column sep=.6cm] {
    \node[draw=none] (r) {$R(z)$};
%   \& \coordinate (aux0);
   \& \node[circle,add={-}{+}{}{}] (circle) {};
   \node[draw=none] (ez) at ([xshift=1cm,yshift=.15cm]circle)  {$e(z)$};
   \& \node[rectangle,draw,
	minimum width=1cm,
	minimum height=1cm,
        label=\textbf{Controller}] (cz) {{\sc C(z)}};
   \node[draw=none] (ud) at ([xshift=1cm,yshift=.15cm]cz)  {$U(z)$};
     
   \& complexnode/.pic={ 
      \node[rectangle,draw,
	minimum width=3cm,
	minimum height=1.6cm,
	label=\textbf{DAC},] (dac) {};
     \node[circle,add={}{+}{+}{},fill=yellow!20] (q2) at ([xshift=-.65cm]dac.center) {};
     \node[draw=none] (q2t)  at ([xshift=-.65cm,yshift=-.65cm]dac.center) {{\sc Q2}};
     \node[draw=none] (v2)  at ([xshift=-.65cm,yshift=1.5cm]dac.center) {$\nu_2(z)$};
     \node[fill=yellow!20] (zoh) at ([xshift=.65cm]dac.center) {{\sc ZOH}};}   
   \& \node[rectangle,draw,
	minimum width=1cm,
	minimum height=1cm,
        label=\textbf{Plant}] (gs) {{\sc $G(s) + \Delta G_p(s)$}};
   \node[draw=none] (ud) at ([xshift=-2cm,yshift=.15cm]gs)  {$U(s)$};
   \node[draw=none] (y) at ([xshift=2cm,yshift=.15cm]gs)  {$Y(s)$};
   \& complexnode/.pic={ 
     \node[rectangle,draw,
	minimum width=4cm,
	minimum height=1.6cm,
	label=\textbf{ADC},] (adc) {};
   \draw[] ([xshift=-1cm]adc.center) -- ++(0.5,0.2cm);
   \coordinate (switch1) at ([xshift=-1cm]adc.center);
   \coordinate (switch2) at ([xshift=-0.4cm]adc.center);
   \node[circle,add={}{+}{+}{},fill=yellow!20] (q1) at ([xshift=1cm]adc.center) {};} 
     \node[draw=none] (q2t)  at ([xshift=1cm,yshift=-.65cm]adc.center) {{\sc Q1}};
   \node[draw=none] (v1)  at ([xshift=1cm,yshift=1.5cm]adc.center) {$\nu_1(z)$};
   \& \coordinate (aux1);
   \& \node[draw=none] (yz) {$\hat{Y}(z)$};\\
   \& \coordinate (aux3); 
   \&
   \&
   \& 
   \& 
   \& \coordinate (aux2);\\
  };


  \path[->] (v1) edge (q1.north);
  \path[->] (v2) edge (q2.north);
  \path[->] (r) edge (circle.west);
  \path[->] (aux1) edge (yz);
  \path  
   (circle.east) edge (cz)
   (cz.east) edge (q2.west)
   (q2.east) edge (zoh.west)
   (zoh.east) edge (gs.west)
   (switch2) edge (q1.west)
   (q1.east) edge (aux1.west)
   (gs.east) edge (switch1.west)
   (aux1.south) edge (aux2.north)
   (aux2.west) edge (aux3.east); 
  \path[->]  (aux3.north) edge (circle.south);
 \end{tikzpicture}
}
 \caption{Sampled System. \label{fig:sampledsystem}}
\end{figure*}


The ADC and DAC may be abstracted changing the hybrid system in figure~\ref{fig:sampledsystem} to the digital system in figure~\ref{fig:digsystem1} where the parametric uncertainties are represented by $\Delta G_{P}(z)=\mathcal{Z}\left\lbrace{G_{P}(s)}\right\rbrace$ and the entire effect of $\nu_{1}$ and $\nu_{2}$ in the output $Y(z)$ is represented as an additive (output) measurement noise $\nu(z)$.

\begin{figure}[ht]
\centering

\tikzset{add/.style n args={4}{
    minimum width=6mm,
    path picture={
        \draw[circle] 
            (path picture bounding box.south east) -- (path picture bounding box.north west)
            (path picture bounding box.south west) -- (path picture bounding box.north east);
        \node[draw=none] at ($(path picture bounding box.south)+(0,0.13)$)     {\small #1};
        \node[draw=none] at ($(path picture bounding box.west)+(0.13,0)$)      {\small #2};
        \node[draw=none] at ($(path picture bounding box.north)+(0,-0.13)$)    {\small #3};
        \node[draw=none] at ($(path picture bounding box.east)+(-0.13,0)$)     {\small #4};
        }
    }
 }

\resizebox{.5\textwidth}{!}{
 \begin{tikzpicture}[scale=0.3,-,>=stealth',shorten >=.2pt,auto,
     semithick, initial text=, ampersand replacement=\&,]

  \matrix[nodes={draw, fill=none, shape=rectangle, minimum height=.2cm, minimum width=.2cm, align=center}, row sep=.6cm, column sep=.3cm] {
    \node[draw=none] (r) {$R(z)$};
%   \& \coordinate (aux0);
   \& \node[circle,add={-}{+}{}{}] (circle) {};
   \node[draw=none] (ez) at ([xshift=1cm,yshift=.15cm]circle)  {$e(z)$};
   \& \node[rectangle,draw,
	minimum width=1cm,
	minimum height=1cm,
        label=\textbf{Controller}] (cz) {{\sc C(z)}};
   \node[draw=none] (ud) at ([xshift=1cm,yshift=.15cm]cz)  {$U(z)$};
   \& \node[rectangle,draw,
	minimum width=1cm,
	minimum height=1cm,
        label=\textbf{Plant}] (gs) {{\sc $G(z) + \Delta G_{P}(z)$}};
   \node[draw=none] (y) at ([xshift=2cm,yshift=.15cm]gs)  {$Y(z)$};

   \& \node[circle,add={}{+}{+}{}] (circle2) {};
%   \node[draw=none] (tyz) at ([xshift=-1cm,yshift=.15cm]circle2)  {$Y(z)$};
   \node[draw=none] (nu) at ([yshift=1cm]circle2)  {$\nu(z)$};
   \& \coordinate (aux1);
   \& \node[draw=none] (yz) {$\tilde Y(z)$};\\
   \& \coordinate (aux3); 
   \&
   \& 
   \& 
   \& \coordinate (aux2);\\
  };


%  \path[->] (v1) edge (q1.north);
%  \path[->] (v2) edge (q2.north);
  \path[->] (r) edge (circle.west);
  \path[->] (nu) edge (circle2.north);
  \path[->] (aux1) edge (yz);
  \path  
   (circle.east) edge (cz)
   (cz.east) edge (gs.west)
   (gs.east) edge (circle2.west)
   (circle2.east) edge (aux1.west)
   (aux1.south) edge (aux2.north)
   (aux2.west) edge (aux3.east); 
  \path[->]  (aux3.north) edge (circle.south);
 \end{tikzpicture}
}
 \caption{Digital system equivalent to ~\ref{fig:sampledsystem}. \label{fig:digsystem1}}
\end{figure}


%
In figure~\ref{fig:digsystem1}, two sources of uncertainties are considered: parametric uncertainties related to modeling errors, and uncertainties introduced by quantisations in sampling and holding process, {\it i.e.} ADC and DAC conversions. Assuming linearity and independence between these sources, the uncertain model may be rewritten as follows:
\begin{equation}
\label{eq:complete_unc_model}
\hat{G}(z)=G(z)+\Delta G_{P}(z)+\Delta G_{Q}(z),
\end{equation}
where $\Delta G_{P}(z)$ is the term that corresponds to the parametric uncertainties and $\Delta G_{Q}(z)$ is the term that reflects the quantisation effects on the plant model. %\red{[next figure is a bit unnecessary, does not ad much to the previous one.]} Figure~\ref{fig:digsystem2} shows the digital closed loop systems with $\Delta G_{P}(z)$ and $\Delta G_{Q}(z)$.


%\begin{figure}[ht]
%\centering
%
%\tikzset{add/.style n args={4}{
%    minimum width=6mm,
%    path picture={
%        \draw[circle] 
%            (path picture bounding box.south east) -- (path picture bounding box.north west)
%            (path picture bounding box.south west) -- (path picture bounding box.north east);
%        \node[draw=none] at ($(path picture bounding box.south)+(0,0.13)$)     {\small #1};
%        \node[draw=none] at ($(path picture bounding box.west)+(0.13,0)$)      {\small #2};
%        \node[draw=none] at ($(path picture bounding box.north)+(0,-0.13)$)    {\small #3};
%        \node[draw=none] at ($(path picture bounding box.east)+(-0.13,0)$)     {\small #4};
%        }
%    }
% }
%
%\resizebox{.5\textwidth}{!}{
% \begin{tikzpicture}[scale=0.3,-,>=stealth',shorten >=.2pt,auto,
%     semithick, initial text=, ampersand replacement=\&,]
%
%  \matrix[nodes={draw, fill=none, shape=rectangle, minimum height=.2cm, minimum width=.2cm, align=center}, row sep=.6cm, column sep=.3cm] {
%  %
%	\& 
%	\&
%	\& \coordinate (aux7); 
%	\& \node[rectangle,draw,
%	minimum width=1cm,
%	minimum height=1cm] (deltag2) {{\sc $\Delta G_{Q}(z)$}};
%	\& \coordinate (aux8);\\
%    \node[draw=none] (r) {$R(z)$};
%%   \& \coordinate (aux0);
%   \& \node[circle,add={-}{+}{}{}] (circle) {};
%   \node[draw=none] (ez) at ([xshift=1cm,yshift=.15cm]circle)  {$e(z)$};
%   \& \node[rectangle,draw,
%	minimum width=1cm,
%	minimum height=1cm,
%        label=\textbf{Controller}] (cz) {{\sc C(z)}};
%   \node[draw=none] (ud) at ([xshift=1cm,yshift=.15cm]cz)  {$U(z)$};
%   \& \coordinate (aux4);
%   \& \node[rectangle,draw,
%	minimum width=1cm,
%	minimum height=1cm,
%        label=\textbf{Plant}] (gs) {{\sc G(z)}};
%   \node[draw=none] (y) at ([xshift=1cm,yshift=.15cm]gs)  {$Y(z)$};
%   \& \node[circle,add={+}{+}{+}{}] (circle2) {};
%%   \node[draw=none] (tyz) at ([xshift=-1cm,yshift=.15cm]circle2)  {$Y(z)$};
%%   \node[draw=none] (nu) at ([yshift=1cm]circle2)  {$\nu(z)$};
%   \& \coordinate (aux1);
%   \& \node[draw=none] (yz) {$\hat{Y}(z)$};\\
%   \& 
%   \&
%   \& \coordinate (aux5); 
%   \& \node[rectangle,draw,
%	minimum width=1cm,
%	minimum height=1cm] (deltag) {{\sc $\Delta G_{P}(z)$}};
%   \& \coordinate (aux6);\\
%   \& \coordinate (aux3); 
%   \&
%   \& 
%   \& 
%   \&
%   \& \coordinate (aux2);\\
%  };
%
%
%%  \path[->] (v1) edge (q1.north);
%%  \path[->] (v2) edge (q2.north);
%  \path[->] (r) edge (circle.west);
%%  \path[->] (nu) edge (circle2.north);
%  \path[->] (aux1) edge (yz);
%  \path  
%   (aux4.north) edge (aux5.south)
%   (aux4.north) edge (aux7.south)
%   (aux5.east) edge (deltag.west)
%   (aux7.east) edge (deltag2.west)
%   (deltag.east) edge (aux6.west)
%   (deltag2.east) edge (aux8.west)
%   (circle.east) edge (cz)
%   (cz.east) edge (gs.west)
%   (circle2.east) edge (aux1.west)
%   (aux1.south) edge (aux2.north)
%   (aux2.west) edge (aux3.east); 
%  \path[->] (aux8.south) edge (circle2.north); 
%  \path[->] (aux6.south) edge (circle2.south);
%  \path[->] (gs.east) edge (circle2.west);
%  \path[->] (aux3.north) edge (circle.south);
% \end{tikzpicture}
%}
% \caption{Digital system with additive uncertainties $\Delta G_{P}(z)$ and $\Delta G_{Q}(z)$. \label{fig:digsystem2}}
%\end{figure}

%\textcolor{blue}{[IB: I propose to exchange the following paragraphs by the previous blue]}

%\textcolor{green}{DC: I believe Alessandro wanted to be more specific about the nature of the modelling error which is why I was trying to explain it. In this case I believe there are also two separate sources for $\Delta{G}_p(z)$. The first is $\Delta{G}_p(s)$ (which is basically a known tolerance that may come from G(t)), whilst the second is the error introduced by the calculations in the $\mathcal{Z}$ transform. Alessandro, do you want to address this second term (possibly as explained below) or just leave the blue section as is?}


%Since $G(z)$ is an approximation of $G(s)$ we introduce an error term caused during its calculation as $\Delta{G}_P$
%
%%
%\begin{align}
%\small
%\label{parametric_plant_tf}
%\hat{G}(z)&=\frac{(b_{0}+\Delta_p b_{0}) +...+(b_{M_G}+\Delta_p b_{M_G})z^{-M_G}}{(a_{0}+\Delta_p a_{0})+...+(a_{N_G}+\Delta_p a_{N_G})z^{-N_G}} \nonumber \\
%&=G(z)+\Delta{G}_P(z).
%\end{align}
%%
%Note that $\Delta{G}_P$ is undefined and upperbound by a user defined
%value such that $\hat{G}(z)$ corresponds to the set of
%possible polynomial forms of $G(z, T)$ that overapproximate $G(s)$.
%This calculation is performed outside of the scope of this work since it depends on the nature of the tool used to obtain the $\mathcal{Z}$ form. The error comes from the bounded horizon and mathematical precision used to calculate the $\mathcal{Z}$ transform, which will be tool and user dependent.
%\red{[The previous statement is confusing and I must disagree here: I want hard error bounds on a specific value of T.]}
%\green{[You are correct. It was absolutely wrong. Hopefully this explanation is clear. We use MATLAB, but still don't know the details of their implementation, so I don't have hard data on how this error is calculated.}

Since the controller is implemented using a FWL, $C(z)$ also suffers disturbances from the FWL effects, with roundoffs in coefficients that may change the closed-loop poles and zeros position, and consequently affect its stability, as shown in~\cite{Bessa16}.


Let $\hat{C}(z)$ be the transfer function of the digital controller represented using this FWL with integer size $I$ and fractional size $F$.  We shall denote the FWL domain of coefficients as $\mathbb{R}\langle I,F \rangle$
%Since the controller is implemented in the $\mathbb{R}\langle I,F \rangle$ 
%domain, {\it i.e.} a Fixed-Point Finite Word Length with integer size $I$ and fractional
%size $F$, we shall denote this domain as $\mathbb{R}\langle I,F \rangle$ 
and assume that there exists a function $FWL[\cdot]:\mathcal{P}^{n}\rightarrow \mathcal{P}^{n}\langle I,F \rangle$, which applies the FWL effects to a polynomial. $\mathcal{P}^{n}$ is the space of polynomials of $n$-th order and $\mathcal{P}^{n}\langle I,F \rangle$ is is the space of polynomials with coefficients in $\mathbb{R}\langle I,F \rangle$.
%, \red{[explain index n! why do you need to work on a Euclidean domain?]}. 
Thus the perturbed controller model $\hat{C}(z)$ may be computed from the original model $C(z)=\frac{N_{C}(z)}{D_{C}(z)}$ using the following expression:
\begin{equation}
\hat{C}(z)=\frac{FWL[N_{C}(z)]}{FWL[D_{C}(z)]}.
\end{equation}
In the case of a synthesised controller, because the synthesis is performed using FWL, $\hat{C}(z) \equiv C(z)$. 

\red{[what is the relationship between FWL effects over C, and the parametric uncertainty Delta Gp over the plant?]} 
\blue{[IB: There is no relationship. We must separate that content in another section?]}

%\textcolor{blue}{[IB: And I propose to exchange the remaining paragraphs by the previous blue]}
%
%\textcolor{green}{[DC: I changed it to a separate section to differentiate the effects, so we should keep both]}

%------------------------------------
\subsection{On the stability considering effects of implementation issues and quantisation noises}
\label{sec:stability}
%------------------------------------

In order to obtain a sound synthesis of the digital controller, the effect of FWL implementation in controller and quantisation noises in closed loop system have to be considered. Considering that the quantizer $Q1$ is the source of a white noise $\nu_{1}$ and $Q2$ is the source of a white noise $\nu_{2}$, the following equation is written for the system in Figure~\ref{fig:sampledsystem}, considering the parametric uncertainties $\Delta G(z)$ and the FWL effects on controller ($\hat{C}(z)$):
\begin{equation}
\hat{Y}(z)=\hat{C}(z)\hat{G}(z)[R(z)+\nu_{1}(z)]+\nu_{2}(z)\hat{G}(z)-\hat{Y}(z)\hat{C}(z)\hat{G}(z),
\end{equation}
that can be rewritten as follows:
\begin{equation}
\label{eq:outputfunctions}
\hat{Y}(z)=H_{1}[R(z)+\nu_{1}(z)]+H_{2}(z)\nu_{2}(z),
\end{equation}
where
\begin{equation}
H_{1}=\frac{\hat{C}(z)\hat{G}(z)}{1+\hat{C}(z)\hat{G}(z)},
\end{equation}
and
\begin{equation}
H_{2}=\frac{\hat{G}(z)}{1+\hat{C}(z)\hat{G}(z)},
\end{equation}

A discrete-time linear system is said to be Bounded-Input and Bounded-Output (BIBO) stable if and only if every pole of its transfer function lies inside the unit circle. \textcolor{red}{Analyzing Eq.~\eqref{eq:outputfunctions} and based on assumption~\ref{assumption:cont_and_plant}, the following lemma states necessary conditions for BIBO stability of closed-loop system in Figure~\ref{fig:sampledsystem}, since the the exogenous signals $R(z)$, $\nu_{1}$, and $\nu_{2}$ are bounded.}

\begin{myassumption}
\label{whitenoise}
%
The quantisation noises $\nu_{1}$ (from the $Q1$) and $\nu_{2}$ (from the
$Q2$) are bounded uncorrelated white noises.
% 
\end{myassumption}

\begin{mylemma}
\label{lemma:variance}
In particular, Widrow \cite{widrow1956} models the quantisation noise as a gaussian
model in which the second moment (variance) of the probability density
function (PDF) of the quantisation noise is given by
%
\begin{equation}
\label{eq:variancelemma}
\sigma_{Q}^{2}=\frac{q^{2}}{12},
\end{equation}
where $q$ is the step size of quantizer. (Proof is on \cite{widrow1956})
\end{mylemma}

\begin{mylemma}
\label{lemma:boundednoise}
The power spectral density of the quantisation noise (supposed white) $S_{\nu}(z)$ is bounded and may be computed through the z-transform of autocorrelation function of $\nu(k)$, thus:
\begin{equation}
S_{\nu}(z)= \sigma_{Q}^{2}=\frac{q^{2}}{12}.
\end{equation}
\end{mylemma}

\begin{proof}
Considering $\nu(k)$ a random process, where $\nu(k)$ is independent from $\nu(k+i)$ for every  integer $k\neq 0$. The autocorrelation function of $\nu(k)$, {\it i.e.} $R_{\nu\nu}(\tau)$ may be computed as follows:
\begin{equation}
R_{\nu\nu}(\tau)=E[\nu(t+\tau)\nu(t)]=\sigma_{Q}^{2}\cdot \delta(\tau),
\end{equation}
where $\delta(\tau)$ is the Dirac delta function at delay time $\tau$.

By definition~\cite{poularikas2000transforms}, the power spectral density of  $\nu(k)$ is the z-transform of $R_{\nu\nu}(\tau)$, thus
\begin{equation}
S_{\nu}(z)=  \sum\limits_{k=-\infty}^{\infty}{R_{\nu\nu}(k)z^{-k}} = \sigma_{Q}^{2},
\end{equation}
considering the Lemma~\ref{lemma:variance}:
\begin{equation}
S_{\nu}(z)=  \frac{q^{2}}{12}.
\end{equation}
\end{proof}

Finally, the quantisation noise may be considered a energy-bounded signal (Lemma~\ref{lemma:boundednoise}) and thus $\hat{Y}(z)$ will be bounded and the closed-loop system stable if the conditions in Lemma~\ref{lemma:eq_int_stab} are followed.


\begin{mylemma}{\cite{Bessa16,fadali}}
\label{lemma:eq_int_stab} 
A feedback hybrid control system as shown in Fig.~\ref{fig:sampledsystem}, with a FWL implementation of the digital controller $\hat{C}(z) = \frac{FWL[N_{C}(z)]}{FWL[D_{C}(z)]}$ and uncertain discrete model of the plant $\hat{G}(z)=G(z)+\Delta G_{P}(z)+\Delta G_{Q}(z)=\frac{\hat{N}_{G}(z)}{\hat{D}_{G}(z)}$, is BIBO-stable if and only if: 
\begin{itemize}
\item  the roots of characteristic polynomial $S(z)$ are inside the open unit circle, where $S(z)$ is:
\begin{equation}
\label{eq:internal_stab_lemma}
S(z)=FWL[N_{C}(z)]\hat{N}_{G}(z)+FWL[D_{C}(z)]\hat{D}_{G}(z);
\end{equation}
\item the direct loop product $\frac{FWL[N_{C}(z)]}{FWL[D_{C}(z)]}\cdot \frac{\hat{N}_{G}(z)}{\hat{D}_{G}(z)}$ has no pole-zero cancellation on or outside the unit circle.
\end{itemize}
\end{mylemma}

The Lemma~\ref{lemma:eq_int_stab} provides the necessary conditions for synthesis of digital controllers able to stabilize closed loop system, considering plant parametric uncertainties ({\it i.e.}, $\Delta G_{P}(z)$), quantisation noises ($\nu_{1}$ and $\nu_{2}$) and FWL effects in digital controllers. Based on it, the model for plant uncertainty due quantisation noise ({\it i.e.}, $\Delta G_{Q}(z)$) may be disregarded if the conditions on Lemma~\ref{lemma:eq_int_stab} are attended and if the quantisation noise is bounded.  The quantisation noise is indeed bounded, since the following assumption~\ref{whitenoise} and the Lemmas~\ref{lemma:variance} and~\ref{lemma:boundednoise} are true.

%\red{[first: lemmae precede theorems. ]}

% Let $\tilde C(z)$ and $\tilde G(z)$ be the transfer functions represented
% using Fixed-Point bit vectors with integer size $I_b$ and fractional
% size $F_b$, whose domain is $\mathbb{R}\langle I_b,F_b \rangle \supseteq \mathbb{R}\langle I,F \rangle$.
% %
% \begin{align}
% \small
% \label{digital_controller_plant_tf}
% \tilde C(z)&=\frac{\tilde \beta_{0}+\tilde \beta_{1}z^{-1}+...+\tilde \beta_{M_C}z^{-M_C}}{\tilde \alpha_{0}+\tilde \alpha_{1}z^{-1}+...+\tilde \alpha_{N_C}z^{-N_C}}, \\
% %\label{plant_tf}
% \tilde G(z)&=\frac{\tilde b_{0}+\tilde b_{1}z^{-1}+...+\tilde b_{M_G}z^{-M_G}}{\tilde a_{0}+\tilde a_{1}z^{-1}+...+\tilde a_{N_G}z^{-N_G}}.
% \end{align}
 
% Since the controller is synthesized in the $\mathbb{R}\langle I,F \rangle$
% domain,
% %
%  $$\forall i \leq N_C, j \leq M_C\ \  \tilde \beta_{i} \equiv \beta_{i} \wedge \tilde \alpha_{j} \equiv \alpha_{j} \Leftrightarrow \tilde C(z) \equiv C(z)$$

% Two approaches have been taken to synthesise a stable controller based on this model.
% The first uses interval arithmetic, representing the coefficients $[{c}_i-\Delta_p{c}_i-\Delta_b{c}_i\ ,\ {c}_i+\Delta_p{c}_i-\Delta_b{c}_i+(2^{-F_b})]$  

% \cdsay{Dario, what coefficients are these?}

% and rounding operations outwards during the process. This results in a tighter calculation of the error at the cost of performance.

%, thus supporting this assumption.

%------------------------------------
%\subsection{Using Fixed Point Arithmetic for verification}
%\label{fixedpoint_verification}
%------------------------------------

%------------------------------------
\subsection{Synthesis Process using DSVerifier}
\label{verification-flow}
%------------------------------------

%\red{[The following description can be made shorter, crisper?]}

The full synthesis process is illustrated in Fig.~\ref{DSVerifier_process};
a detailed description of DSVerifier tool can be found in~\cite{IsmailBCFF15}.
Steps $1$ to $5$ are performed by the user/synthesiser and
Steps A to D are automatically performed by DSVerifier.
%, which accepts the
%digital controller transfer functions together with the plant model.  For
%any digital controller, implementation details should be provided ({\it
%e.g.}, number of bits, realization, and sample time).

\begin{figure*}[t]
\centering
\includegraphics[width=\textwidth]{figures/verification-flow.png}
\vspace{1ex}
\caption{DSVerifier Verification Flow.}
\label{DSVerifier_process}
\end{figure*}

%In Step $1$, the user provides inputs $G(z)$ and $\Delta{G}(z)$
%%$\%$ ({\it i.e.}, $\Delta{G}(z)$ as a percentage of $G(z)$)
%, which contain the plant model and the
%interval, respectively.  In Step $2$, a digital controller must be designed
%with any preferred method, where $C(z)$ is obtained.  The controller
%numerical representation and realization form are chosen in Steps $3$ and
%$4$, respectively.  In Step $5$, the user finally configures the
%verification parameters ({\it e.g.}, verification time, properties, and BMC
%tool).  After that, DSVerifier verification engine performs an (automatic)
%verification of the desired property $\phi$ ({\it i.e.}, stability).  The
%user steps described in Steps $1$--$5$ result in an ANSI-C code that should
%be used as an input for DSVerifier.

Given a model $(\hat{C}(z),\hat{G}(z), \mathbb{R}\langle I,F \rangle)$,
provided in an ANSI-C code input file (Steps 1-5), DSVerifier constructs a
non-deterministic model to represent the plant family $\mathfrak{G}(z)$
(Step A), and a transfer function $f$ represented by Eq.~\ref{FWL_tf} (step B) to
calculate the implementation $f(\hat{C}(z)) \rightarrow \tilde C(z)$ of the
controller (step C).  Finally DSVerifier builds an intermediate ANSI-C code
for the digital system implementation, which is used as input for the
model-checker (Step D).

This intermediate ANSI-C code model $(\tilde C(z),\mathfrak{G}(z),\phi)$
containing a specification $\phi$ for the verification properties ({\it
i.e.}, robust stability) is provided to CBMC's~\cite{ClarkeKL04} integrated
CEGIS synthesis module, where $\tilde C(z)$ is marked as input variable to
synthesise.  If any property violation is found, then
a counterexample is reported, which contains system inputs or
parametric deviations $\Delta{G}$ that lead the system to a failure.  
This information allows the CEGIS module to refine its search for a stable
controller, which we explain in detail in section~\ref{synthesiser-general}.
A successful verification result is reported if the system is safe with
respect to $\phi$.  In particular, the stability verification is complete
and sound, since it does not depend on system inputs and outputs.  In the
case of stability, the specification $\phi$ consists in a number of
assumptions on the polynomial coefficients, following Jury's Criteria, as
well as the restrictions set in the representation of these coefficients by
the function $f$ (cf.~Eq.~\eqref{FWL_tf}).

%In Step A, DSVerifier constructs a non-deterministic model to represent the
%plant family $\mathfrak{G}$ using $g_0$ and $\Delta{g}\%$, which are
%provided in Step $1$.  DSVerifier then formulates $\mathit{FWL}[\cdot]$ in
%Step B using implementation details provided from Steps $2$ and $3$, and
%then computes $\mathit{FWL}[c_0]$ in Step C.  Thus, DSVerifier builds an
%intermediate ANSI-C code for the digital system implementation, which is
%used as input for the model-checker, as pointed in Step D.

%This intermediate ANSI-C code model has three main modules: digital
%controller code to be embedded into the microprocessor; plant model code,
%which simulates the plant model dynamics considering uncertainties; and
%``assert'' and ``assume'' statements, which control the verification flow. 
%For the digital controller code, transfer functions coefficients are
%quantized and deterministic, and all operations use fixed-point arithmetic. 
%\textcolor{red}{In the plant model code, transfer function coefficients are
%not quantized, but represented with maximum precision based on float
%data-type variables}; they are treated as non-deterministic variables to
%support model uncertainties.  The directive ``assume'' bounds
%non-deterministic variables, {\it i.e.}, inputs and plant uncertain
%coefficients.
%
%The translation of ANSI-C code into SAT/SMT formulae
%is done by a back-end model-checking tool ({\it e.g.},
%CBMC~\cite{ClarkeKL04} or ESBMC~\cite{CordeiroFM12}).  Here, DSVerifier
%symbolically checks a given property $\phi$ with respect to closed-loop
%systems, which are composed by $f(c_i)$ and every $G$ in $\mathfrak{G}$. 
%If any property violation is found, then DSVerifier reports a
%counterexample, which contains system inputs or parametric deviations
%$\Delta{G}$ that lead the system to a failure.  A successful verification
%result is reported if the system is safe with respect to $\phi$.  In
%particular, the stability verification is complete and sound, since it does
%not depend on system outputs and inputs.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Running Example} \label{sec:running-ex}

In order to exploit the present approach full potential, a dynamical plant that can
present physical components must be considered.  However, a discrete plant
model can also demonstrate some benefits of the present approach, which
considers FWL effects in the digital controller implementation.  In
particular, a classical cruise control example is extracted from the
literature~\cite{Astrom08}, where the discrete plant model (with time step
of $0.2$s) is represented by the following z-expression:
%
\begin{equation}
\label{Eq:running-example-plant}
G\left(z\right) := \frac{0.0264}{z-0.9998}.
\end{equation}

Using an optimisation tool, the work in~\cite{DBLP:conf/hybrid/WangGRJF16}
has designed a high-performance controller, which is characterised by the
following z-domain transfer function:
%
\begin{equation}
\label{Eq:running-example-controller}
C\left(z\right) := \frac{2.72z^2 - 4.153z + 1.896}{z^2 - 1.844z + 0.8496}.
\end{equation}
%
The authors claim that this controller $C(z)$ stabilizes the closed-loop
system for the discrete plant model $G(z)$.  However, if implementation
aspects are considered during verification ({\it e.g.}, fixed-point
arithmetic and word-length), then this closed-loop system becomes unstable.
%
Indeed, the actual implementation of $C(z)$ using \param{4}{16}
implementation format ({\it i.e.}, $4$ bits for the integer part and $16$
bits for the fractional part) can be represented by the following
expression:
%
\begin{equation}
\label{Eq:running-example-controller-quantized}
C_{q}\left(z\right) {:=} \frac{2.719986z^2{-}4.153000z
{+}1.895996}{z^2{-}1.843994z+0.849594},
\end{equation} 
%
which makes the system unstable in closed-loop using fixed-point arithmetic
and the typical series loop configuration, where $C_{q}\left(z\right)$ and
$G\left(z\right)$ are in the forward path.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Modelling Errors} 

%In this section, we show how to embed discretisation errors on the plant model, as follows: 
%%$\hat{G}(z)$ is split into two terms:
%%
%\begin{equation}
%\label{eq:uncertainplant}
%%\hat{G}(z)=G(z)+\Delta{G(z)},
%\tilde G(z) = \hat G(z) + \Delta G_P(z) = G(z,T) + \Delta G_Q(z) + \Delta G_P(z),   
%\end{equation}
%where $G(z,T)$ is the time discretisation of the nominal physical plant $G(s)$, 
%$\Delta{G_{Q}(z)}$ represents the quantisation uncertainty model, 
%and $\Delta{G_{P}(z)}$ describes the parametric uncertainty model. 

%\noindent where $G(z)$ is the discretized nominal plant model and
%$\Delta{G(z)}$ is the additive uncertainty, which is related to parametric
%uncertainties~\cite{Bessa16}.  

%\section{An Uncertainty Model for the quantisation Error} 
%\label{sec:uncertainty-model-quantisation-error}
%
%%Here, an uncertainty model to accommodate the
%%quantisation noise effects on $\hat{G}(z)$ is proposed.  
%%As a result, Eq.~\eqref{eq:uncertainplant} is rewritten as
%%
%%\begin{equation}
%%\label{eq:uncertainFWLplant}
%%\hat{G}(z)=G(z)+\Delta{G_{Q}(z)}+\Delta{G_{P}(z)},
%%\end{equation}
%
%A model for $\Delta{G_{Q}(z)}$ that can represent the quantisation
%noise effect in the plant output, and consequently the closed-loop system
%output, is proposed.  
%%\red{[eliminate next:] 
%%For convenience, the parametric uncertainties will be described here.}
%
%Consider the closed-loop sampled system in Figure~\ref{fig:sampledsystem},
%where $C(z)$ is the digital controller model, whose control output signal is
%quantized ($Q2$) and interpolated via a ZOH using digital-to-analog
%converter (DAC).  The quantisation occurs because the DAC resolution may be
%different from the fixed point representation of the controller.  $G(s)$ is
%the continuous-time model of the plant, from which output samples are taken
%and quantized ($Q1$) by means of an analog-to-digital converter (ADC)
%synchronized with the DAC.  Each quantizer ($Q1$ and $Q2$) will present some
%contribution for the total quantisation noise.
%    
%\begin{figure*}[ht]
%\centering
%
%\tikzset{add/.style n args={4}{
%    minimum width=6mm,
%    path picture={
%        \draw[circle] 
%            (path picture bounding box.south east) -- (path picture bounding box.north west)
%            (path picture bounding box.south west) -- (path picture bounding box.north east);
%        \node[draw=none] at ($(path picture bounding box.south)+(0,0.13)$)     {\small #1};
%        \node[draw=none] at ($(path picture bounding box.west)+(0.13,0)$)      {\small #2};
%        \node[draw=none] at ($(path picture bounding box.north)+(0,-0.13)$)    {\small #3};
%        \node[draw=none] at ($(path picture bounding box.east)+(-0.13,0)$)     {\small #4};
%        }
%    }
% }
%
%\resizebox{.8\textwidth}{!}{
% \begin{tikzpicture}[scale=0.6,-,>=stealth',shorten >=.2pt,auto,
%     semithick, initial text=, ampersand replacement=\&,]
%
%  \matrix[nodes={draw, fill=none, shape=rectangle, minimum height=.2cm, minimum width=.2cm, align=center}, row sep=.6cm, column sep=.3cm] {
%    \node[draw=none] (r) {$\tilde R(z)$};
%%   \& \coordinate (aux0);
%   \& \node[circle,add={-}{+}{}{}] (circle) {};
%   \node[draw=none] (ez) at ([xshift=1cm,yshift=.15cm]circle)  {$\tilde e(z)$};
%   \& \node[rectangle,draw,
%	minimum width=1cm,
%	minimum height=1cm,
%        label=\textbf{Controller}] (cz) {{\sc C(z)}};
%   \node[draw=none] (ud) at ([xshift=1cm,yshift=.15cm]cz)  {$\tilde U(z)$};
%     
%   \& complexnode/.pic={ 
%      \node[rectangle,draw,
%	minimum width=3cm,
%	minimum height=1.6cm,
%	label=\textbf{DAC},] (dac) {};
%     \node[circle,add={}{+}{+}{},fill=yellow!20] (q2) at ([xshift=-.65cm]dac.center) {};
%     \node[draw=none] (q2t)  at ([xshift=-.65cm,yshift=-.65cm]dac.center) {{\sc Q2}};
%     \node[draw=none] (v2)  at ([xshift=-.65cm,yshift=1.5cm]dac.center) {$\nu_2(z)$};
%     \node[fill=yellow!20] (zoh) at ([xshift=.65cm]dac.center) {{\sc ZOH}};}
%   \& \node[rectangle,draw,
%	minimum width=1cm,
%	minimum height=1cm,
%        label=\textbf{Plant}] (gs) {{\sc G(s)}};
%   \node[draw=none] (ud) at ([xshift=-1cm,yshift=.15cm]gs)  {$U(s)$};
%   \node[draw=none] (y) at ([xshift=1cm,yshift=.15cm]gs)  {$Y(s)$};
%   \& complexnode/.pic={ 
%     \node[rectangle,draw,
%	minimum width=4cm,
%	minimum height=1.6cm,
%	label=\textbf{ADC},] (adc) {};
%   \draw[] ([xshift=-1cm]adc.center) -- ++(0.5,0.2cm);
%   \coordinate (switch1) at ([xshift=-1cm]adc.center);
%   \coordinate (switch2) at ([xshift=-0.4cm]adc.center);
%   \node[circle,add={}{+}{+}{},fill=yellow!20] (q1) at ([xshift=1cm]adc.center) {};} 
%     \node[draw=none] (q2t)  at ([xshift=1cm,yshift=-.65cm]adc.center) {{\sc Q1}};
%   \node[draw=none] (v1)  at ([xshift=1cm,yshift=1.5cm]adc.center) {$\nu_1(z)$};
%   \& \coordinate (aux1);
%   \& \node[draw=none] (yz) {$\tilde Y(z)$};\\
%   \& \coordinate (aux3); 
%   \&
%   \&
%   \& 
%   \& 
%   \& \coordinate (aux2);\\
%  };
%
%
%  \path[->] (v1) edge (q1.north);
%  \path[->] (v2) edge (q2.north);
%  \path[->] (r) edge (circle.west);
%  \path[->] (aux1) edge (yz);
%  \path  
%   (circle.east) edge (cz)
%   (cz.east) edge (q2.west)
%   (q2.east) edge (zoh.west)
%   (zoh.east) edge (gs.west)
%   (switch2) edge (q1.west)
%   (q1.east) edge (aux1.west)
%   (gs.east) edge (switch1.west)
%   (aux1.south) edge (aux2.north)
%   (aux2.west) edge (aux3.east); 
%  \path[->]  (aux3.north) edge (circle.south);
% \end{tikzpicture}
%}
% \caption{Sampled System. \label{fig:sampledsystem}}
%\end{figure*}
%
%%% \begin{figure}[ht]
%%% \centering
%%% \includegraphics[width=\columnwidth]{figures/hsystembd.pdf}
%%% \caption{Sampled system.}
%%% \label{fig:sampledsystem}
%%% \end{figure}
%
%
%\begin{figure}[ht]
%\centering
%
%\tikzset{add/.style n args={4}{
%    minimum width=6mm,
%    path picture={
%        \draw[circle] 
%            (path picture bounding box.south east) -- (path picture bounding box.north west)
%            (path picture bounding box.south west) -- (path picture bounding box.north east);
%        \node[draw=none] at ($(path picture bounding box.south)+(0,0.13)$)     {\small #1};
%        \node[draw=none] at ($(path picture bounding box.west)+(0.13,0)$)      {\small #2};
%        \node[draw=none] at ($(path picture bounding box.north)+(0,-0.13)$)    {\small #3};
%        \node[draw=none] at ($(path picture bounding box.east)+(-0.13,0)$)     {\small #4};
%        }
%    }
% }
%
%\resizebox{.5\textwidth}{!}{
% \begin{tikzpicture}[scale=0.3,-,>=stealth',shorten >=.2pt,auto,
%     semithick, initial text=, ampersand replacement=\&,]
%
%  \matrix[nodes={draw, fill=none, shape=rectangle, minimum height=.2cm, minimum width=.2cm, align=center}, row sep=.6cm, column sep=.3cm] {
%    \node[draw=none] (r) {$R(z)$};
%%   \& \coordinate (aux0);
%   \& \node[circle,add={-}{+}{}{}] (circle) {};
%   \node[draw=none] (ez) at ([xshift=1cm,yshift=.15cm]circle)  {$e(z)$};
%   \& \node[rectangle,draw,
%	minimum width=1cm,
%	minimum height=1cm,
%        label=\textbf{Controller}] (cz) {{\sc C(z)}};
%   \node[draw=none] (ud) at ([xshift=1cm,yshift=.15cm]cz)  {$U(z)$};
%   \& \node[rectangle,draw,
%	minimum width=1cm,
%	minimum height=1cm,
%        label=\textbf{Plant}] (gs) {{\sc G(z)}};
%   \node[draw=none] (y) at ([xshift=1cm,yshift=.15cm]gs)  {$Y(z)$};
%
%   \& \node[circle,add={}{+}{+}{}] (circle2) {};
%%   \node[draw=none] (tyz) at ([xshift=-1cm,yshift=.15cm]circle2)  {$Y(z)$};
%   \node[draw=none] (nu) at ([yshift=1cm]circle2)  {$\nu(z)$};
%   \& \coordinate (aux1);
%   \& \node[draw=none] (yz) {$\tilde Y(z)$};\\
%   \& \coordinate (aux3); 
%   \&
%   \& 
%   \& 
%   \& \coordinate (aux2);\\
%  };
%
%
%%  \path[->] (v1) edge (q1.north);
%%  \path[->] (v2) edge (q2.north);
%  \path[->] (r) edge (circle.west);
%  \path[->] (nu) edge (circle2.north);
%  \path[->] (aux1) edge (yz);
%  \path  
%   (circle.east) edge (cz)
%   (cz.east) edge (gs.west)
%   (gs.east) edge (circle2.west)
%   (circle2.east) edge (aux1.west)
%   (aux1.south) edge (aux2.north)
%   (aux2.west) edge (aux3.east); 
%  \path[->]  (aux3.north) edge (circle.south);
% \end{tikzpicture}
%}
% \caption{Sampled System. \label{fig:sampledsystem}}
%\end{figure}
%
%%
%%
%
%\begin{figure}[ht]
%\centering
%
%\tikzset{add/.style n args={4}{
%    minimum width=6mm,
%    path picture={
%        \draw[circle] 
%            (path picture bounding box.south east) -- (path picture bounding box.north west)
%            (path picture bounding box.south west) -- (path picture bounding box.north east);
%        \node[draw=none] at ($(path picture bounding box.south)+(0,0.13)$)     {\small #1};
%        \node[draw=none] at ($(path picture bounding box.west)+(0.13,0)$)      {\small #2};
%        \node[draw=none] at ($(path picture bounding box.north)+(0,-0.13)$)    {\small #3};
%        \node[draw=none] at ($(path picture bounding box.east)+(-0.13,0)$)     {\small #4};
%        }
%    }
% }
%
%\resizebox{.5\textwidth}{!}{
% \begin{tikzpicture}[scale=0.3,-,>=stealth',shorten >=.2pt,auto,
%     semithick, initial text=, ampersand replacement=\&,]
%
%  \matrix[nodes={draw, fill=none, shape=rectangle, minimum height=.2cm, minimum width=.2cm, align=center}, row sep=.6cm, column sep=.3cm] {
%    \node[draw=none] (r) {$R(z)$};
%%   \& \coordinate (aux0);
%   \& \node[circle,add={-}{+}{}{}] (circle) {};
%   \node[draw=none] (ez) at ([xshift=1cm,yshift=.15cm]circle)  {$e(z)$};
%   \& \coordinate (aux4);
%   \& \node[rectangle,draw,
%	minimum width=1cm,
%	minimum height=1cm,
%        label=\textbf{Controller}] (cz) {{\sc C(z)}};
%   \node[draw=none] (ud) at ([xshift=1cm,yshift=.15cm]cz)  {$U(z)$};
%   \& \node[rectangle,draw,
%	minimum width=1cm,
%	minimum height=1cm,
%        label=\textbf{Plant}] (gs) {{\sc G(z)}};
%   \node[draw=none] (y) at ([xshift=1cm,yshift=.15cm]gs)  {$Y(z)$};
%   \& \node[circle,add={+}{+}{}{}] (circle2) {};
%%   \node[draw=none] (tyz) at ([xshift=-1cm,yshift=.15cm]circle2)  {$Y(z)$};
%%   \node[draw=none] (nu) at ([yshift=1cm]circle2)  {$\nu(z)$};
%   \& \coordinate (aux1);
%   \& \node[draw=none] (yz) {$\tilde Y(z)$};\\
%   \& 
%   \& \coordinate (aux5); 
%   \& \node[rectangle,draw,
%	minimum width=1cm,
%	minimum height=1cm] (deltag) {{\sc $\Delta G(z)$}};
%   \&
%   \& \coordinate (aux6);\\
%   \& \coordinate (aux3); 
%   \&
%   \& 
%   \& 
%   \&
%   \& \coordinate (aux2);\\
%  };
%
%
%%  \path[->] (v1) edge (q1.north);
%%  \path[->] (v2) edge (q2.north);
%  \path[->] (r) edge (circle.west);
%%  \path[->] (nu) edge (circle2.north);
%  \path[->] (aux1) edge (yz);
%  \path  
%   (aux4.north) edge (aux5.south)
%   (aux5.east) edge (deltag.west)
%   (deltag.east) edge (aux6.west)
%   (aux6.south) edge (circle2.south)
%   (circle.east) edge (cz)
%   (cz.east) edge (gs.west)
%   (gs.east) edge (circle2.west)
%   (circle2.east) edge (aux1.west)
%   (aux1.south) edge (aux2.north)
%   (aux2.west) edge (aux3.east); 
%  \path[->]  (aux3.north) edge (circle.south);
% \end{tikzpicture}
%}
% \caption{Sampled System. \label{fig:sampledsystem}}
%\end{figure}




%\begin{myprop}
%Considering the quantisation noise $\nu(k)$ as an output error in the
%discrete plant model, 
%%{\it i.e.}, it does not affect the plant dynamics, but its output samples, 
%$\Delta{G_{Q}(z)}$ can be obtained from
%%
%\begin{equation}
%\label{eq:quantisation_tf}
%\Delta{G_{Q}(z)}=\frac{\nu(z)}{U(z)},
%\end{equation}
%where $\nu(z)$ is the z-transform of the random process $\nu(k)$,
%which can be calculated through the power spectral density of
%$\nu(k)$~\cite{poularikas2000transforms}.  
%Thus, the $\Delta{G_{Q}(z)}$ can expressed as
%%
%\begin{equation}
%\label{eq:deltag_var}
%\Delta{G_{Q}(z)}=\frac{\sigma_{Q}^{2}}{U(z)},
%\end{equation}
%where $\sigma_{Q}^{2}$ is the variance of the quantisation noise and
%$U(z)$ is the z-transform of control signal ({\it i.e.}, the z-transform of
%the signal from the digital controller), which is provided to the plant by
%means of ZOH.
%\end{myprop}
%
%%
%\begin{proof}
%%
%Suppose that the plant discrete model in Figure~\ref{fig:sampledsystem} can
%be represented by the following pulse transfer function (without
%quantisation noise effect):
%%
%\begin{equation}
%\label{eq:tfwithout}
%G(z)=\frac{Y(z)}{U(z)}=\frac{B(z)}{A(z)}=\frac{b_{0}+b_{1}z^{-1}+b_{2}z^{-2}+\cdots+b_{M}z^{-M}}{1+a_{1}z^{-1}+a_{2}z^{-2}+\cdots+a_{N}z^{-N}},
%\end{equation}
%%
%\noindent where $Y(z)$ is the z-transform of the plant output signal without
%noise $y(k)$, $U(z)$ is the z-transform of the control signal, which is
%provided to the plant, $A(z)$ and $B(z)$ are the plant pulse transfer
%function numerator and denominator, respectively.
%
%Considering the quantisation noise $\nu(k)$ as an output error in the
%discrete plant model, an additive noise in the plant output $y(k)$ resulting
%in the noisy output $\hat{y}(k)$ can be represented as
%%
%\begin{equation}
%\hat{y}(k)=y(k)+\nu(k).
%\end{equation}
%
%Note that the model in Eq.~\eqref{eq:tfwithout} is equivalent to the
%following difference equation:
%%
%\begin{equation}
%\begin{split}
%y(k)=-a_{1}y(k-1)-a_{2}y(k-2)-\cdots - a_{N}y(k-N)\\
%+b_{0}u(k)+b_{1}u(k-1)+b_{2}u(k-2)+\cdots+b_{M}u(k-M),
%\end{split}
%\end{equation}
%
%\noindent and consequently $\hat{y}(k)$ can be represented by the following
%difference equation:
%%
%\begin{equation}
%\label{eq:differencewithnoise}
%\begin{split}
%\hat{y}(k)=-a_{1}y(k-1)-a_{2}y(k-2)-\cdots - a_{N}y(k-N)\\
%+b_{0}u(k)+b_{1}u(k-1)+b_{2}u(k-2)+\cdots+b_{M}u(k-M)+\nu(k).
%\end{split}
%\end{equation}
%
%The z-transform of Eq.~\eqref{eq:differencewithnoise} is
%%
%\begin{equation}
%\begin{split}
%\hat{Y}(z)=(-a_{1}z^{-1}-a_{2}z^{-2}-\cdots-a_{N}z^{-N})Y(z)\\
%+(b_{0}+b_{1}z^{-1}+b_{2}z^{-2}+\cdots+b_{M}z^{-M})U(z)+\nu(z),
%\end{split}
%\end{equation}
%dividing both sides by $U(z)$, it is equivalent to:
%\begin{equation}
%\frac{\hat{Y}(z)}{U(z)}=\hat{G}(z)=[1-A(z)]G(z)+U(z)B(z)+\frac{\nu(z)}{U(z)}.
%\end{equation}
%
%Considering $\hat{G}(z)=G(z)+\Delta{G_{Q}(z)}$ and Eq.~\eqref{eq:tfwithout},
%the intended expression can be obtained as
%%
%\begin{equation}
%\Delta{G_{Q}(z)}=\frac{\nu(z)}{U(z)} 
%\end{equation}
%\end{proof}

%Eq.~\eqref{eq:deltag_var} indicates that the modelling of the quantisation noise
%effect on the plant transfer function demands an estimation of the variance
%of quantisation noise $\sigma_{Q}^{2}$.  To obtain such estimation, the
%methodology presented by~\cite{widrow2008quantisation}
%is used.  The authors provide an algorithm for computing the mean square of
%the output noise due to $Q1$ and $Q2$.  Considering that each quantizer
%contribution can be represented by a white noise with zero mean
%(Assumption~\ref{whitenoise}), the mean square can be considered as the
%variance of noise ($\sigma_{Q}^{2}$), which can be calculated as
%%
%\begin{equation}
%\sigma_{Q}^{2}=\frac{\lambda_{1}^{2}\cdot \sum {h_{Q1}^{2}} \cdot q_{1}+\lambda_{2}^{2}\cdot \sum {h_{Q2}^{2}} \cdot q_{2}}{12},
%\end{equation}
%%
%\noindent where $\lambda_{1}$ and $\lambda_{2}$ are the scale factors, {\it i.e.} constant gains usually employed before the ADC and after the DAC in order to avoid the overload of converters  %\red{[define scale factors]} 
%for the quantisation $Q1$ and $Q2$, respectively; $q_{1}$ and $q_{2}$ are the quantisation step for $Q1$ and $Q2$, respectively, and $\sum {h_{Q1}^{2}}$ and $\sum
%{h_{Q2}^{2}}$ are the squares sums of the impulse response obtained by means
%of a transfer function from $Q1$ and $Q2$ to the plant output, respectively.
%
%The transfer functions $H_{Q1}(z)$ and $H_{Q2}(z)$, from which the squares
%sums of the impulse response are needed, can be obtained through the
%analysis of the system in Figure~\ref{fig:sampledsystem}. 

%\red{[The following text needs to be completed. (Notice typos, reference to wrong signal $R$, and to wrong TF $C,G$.]}
%
%Considering that
%the quantizer $Q1$ is the source of a white noise with zero mean $\nu_{1}$
%and $Q2$ is the source of a white noise with zero mean $\nu_{2}$, the
%following equation can be written for the system in
%Figure~\ref{fig:sampledsystem}
%%
%\begin{equation}
%\resizebox{0.48\textwidth}{!}{
%$\tilde{Y}(z)=\tilde R(z)C(z)G(z)-\tilde{Y}(z)C(z)G(z)+\nu_{1}(z)+\nu_{2}(z)G(z),$
%}
%\end{equation}
%
%\noindent which can be rewritten as
%%
%\begin{equation}
%\label{eq:outputfunctions}
%\tilde{Y}(z)=C(z)G(z)H(z)R(z)+H(z)\nu_{1}(z)+G(z)H(z)\nu_{2}(z)
%\end{equation}
%$$H(z)=\frac{1}{1+C(z)G(z)}$$
%
%Note that $H(z)$ cancels the poles of both $G(z)$ and $C(z)$, thus we need only verify the stability of $H(z)$
%to validate the stability of the whole system.
%These equations are sufficient for computing $\sigma_{Q}^{2}$.  However,
%there is still a gap for a complete model for $\Delta{G_{Q}(z)}$ in
%Eq.~\eqref{eq:deltag_var}, {\it i.e.}, the z-transform of control action
%$U(z)$.  This indicates that the quantisation noise effect on a discrete
%plant model mainly depends on three main factors:
%%
%\begin{itemize}
%%
%\item \textbf{Sample time:} the sample time effect is reflected over pulse transfer function that covers the effects of DAC ant its interpolator (ZOH) \red{[clarify/revise based on the comments made above.]};
%%
%\item \textbf{ADC and DAC step:} \red{[again, do we need both?]} these are the main component of quantisation noise power, but an $8$-bits converter already reduces the effect of quantisation noises in the output for negligible values.
%%
%\item \textbf{Signal-to-noise ratio (SNR): } the dependence on the value of $U(z)$ \red{[notice that now we have reduced the problem to depend on the effect of the reference signal transform R(z) - pls revise.]} shows the importance of the SNR for handling quantisation noise; for a high SNR of the digital controller, the quantisation effect is negligible. This happens during the transient of the system, when high control actions are employed. However, it can be relevant during the steady state. A digital controller with integral action might be sufficient for eliminating such influence at steady state.
%%
%\end{itemize}
%
%An alternative expression for $\Delta{G_{Q}(z)}$ can be obtained from
%Eq.~\eqref{eq:deltag_var}, transforming it into a function of the reference
%$R(z)$.  Once $U(z)$ is the control signal obtained via digital controller
%$C(z)$ and error signal, {\it i.e.},
%%
%\begin{equation}
%U(z)=C(z)\cdot[R(z)-Y(z)],
%\end{equation} 
%
%\noindent where $Y(z)$ is the first term of Eq.~\eqref{eq:outputfunctions}, thus:
%\begin{equation}
%\label{eq:controlsignal}
%\resizebox{0.48\textwidth}{!}{
%$U(z)=C(z)\cdot \left[R(z)-\frac{C(z)G(z)}{1+C(z)G(z)}R(z)\right]=\frac{C(z)}{1+C(z)G(z)}R(z).$
%}
%\end{equation} 
%
%Substituting Eq.~\eqref{eq:controlsignal} in Eq.~\eqref{eq:deltag_var}, a
%model for $\Delta{G_{Q}(z)}$ depending on $R(z)$ can be obtained:
%%
%\begin{equation}
%\Delta{G_{Q}(z)}=\sigma^{2}_{Q}\cdot \frac{1+C(z)G(z)}{C(z)} \cdot \frac{1}{R(z)},
%\end{equation}
%
%\noindent where $R(z)$ can be considered as a step signal (for stabilization
%purpose) with height equal to $r$, which can be rewritten as
%%
%\begin{equation}
%\Delta{G_{Q}(z)}=\frac{\sigma^{2}_{Q}}{r}\cdot \frac{1+C(z)G(z)}{C(z)} \cdot \frac{z-1}{z}.
%\end{equation}
%
%A more precise description of $\Delta{G_{Q}(z)}$ can be obtained
%considering FWL \red{[clarify what you mean with FWL, introduce FWL function explicitly and precisely]} effects on digital controller coefficients, as described in
%Bessa {\it et al.}~\cite{Bessa16}, {\it i.e.}, using $FWL[C(z)]$ instead of
%the nominal $C(z)$:
%%
%\begin{equation}
%\label{eq:deltaG_final}
%\Delta{G_{Q}(z)}=\frac{\sigma^{2}_{Q}}{r}\cdot \frac{1+FWL[C(z)]G(z)}{FWL[C(z)]} \cdot \frac{z-1}{z}.
%\end{equation}
%
%Finally, Eq.~\eqref{eq:deltaG_final} is a suitable frequency domain model
%for quantisation noise effects on closed-loop systems.  This model depends
%on the plant pulse transfer function ($G(z)$), which is described by
%Eq.~\eqref{eq:pulsetf}, the height of step reference signal $r$, and the
%digital controller model.

%\subsection{Modelling Error on Parameters Representation} 
%\label{sec:}

%\red{[TO BE COMPLETED.]}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Automated Program Synthesis \\ for Digital Controllers}

% We use CounterExample-Guided Inductive Synthesis (CEGIS), as
% illustrated in Fig~\ref{fig:CEGIS}.

In order to synthesise closed-loop digital control systems, we use a
program synthesis engine.  Nowadays, such engines are used
increasingly often in program
verification~\cite{DBLP:conf/lpar/DavidKL15,DBLP:conf/cav/0001A14}.
Our program synthesiser makes use of Counter-Example Guided Inductive
Synthesis (CEGIS) \cite{sketch}.  We start by presenting its general
architecture followed by describing the parts specific to closed-loop
control systems.

%specialised it for stream refactoring.  
% adding JST for stream refactoring

\subsection{General architecture of the program synthesiser}
\label{synthesiser-general}
%
%% \red{[I would recommend to clarify the domain of definition of $\sigma$, particularly over the set where $x$ ranges over. 
%% (Be cognisant that control audience might be unfamiliar with the cegis architecture.) ]}
% 
The input specification provided to the program synthesiser is of the
form $\exists \vec{P} . \forall \vec{x}. \sigma(\vec{x}, \vec{P})$ where $\vec{P}$ ranges over functions,
$\vec{x}$ ranges over ground terms and $\sigma$ is a quantifier-free
formula.  We interpret the ground terms over some finite domain
$\mathcal{D}$.

The design of our synthesiser is given in Fig.~\ref{fig:CEGIS} and
consists of two phases, {\sc Synthesise} and {\sc Verify}, which
interact via a finite set of test vectors {\sc inputs} that is updated
incrementally.  Given the aforementioned specification $\sigma$, the
{\sc synth} procedure tries to find an existential witness $\vec{P}$
satisfying the specification $\sigma(\vec{x}, \vec{P})$ for all
$\vec{x}$ in {\sc inputs} (as opposed to all $\vec{x} \in \mathcal{D}$).
%
If {\sc synthesise} succeeds in finding an witness $\vec{P}$, this
witness is a candidate solution to the full synthesis formula. 
We pass this candidate solution to {\sc verify}, which 
checks whether it is a full solution ({\it i.e.}, $\vec{P}$
satisfies the specification $\sigma(\vec{x}, \vec{P})$ for all
$\vec{x}\in\mathcal{D}$).
%determines whether
%it does satisfy the specification on all inputs by checking
%satisfiability of the following verification formula:
%
%$\exists \vec{x} . \lnot \sigma(\vec{x}, \vec{P})$
%If this formula is unsatisfiable, 
%% the candidate solution is in fact a 
%% full solution.
If this is the case, then the algorithm terminates.
Otherwise, additional information is provided to the {\sc synthesise}
phase in the form of a new counterexample that is added to the {\sc inputs} set
and the loop iterates again (note that, for now, we ignore the 
second feedback signal ``Increase Precision'' provided by the {\sc Verify}
phase in Fig.~\ref{fig:CEGIS} as it is specific to control synthesis and will 
be described in the next section).

%% the witness $\vec{x}$ denote an input on which the
%% candidate solution fails to meet the specification.  Thus, $\vec{x}$ is
%% added to the {\sc inputs} set, and the loop iterates again.  

It is
worth noting that each iteration of the loop adds a new input to the
finite set $\text{\sc inputs}$ being used for synthesis.  Given that
the full set of inputs $\mathcal{D}$
%\blue{[which by now should have a name, as suggested to be introduced above]} 
is finite, this means that the refinement loop
can only iterate a finite number of times.

\subsection{Synthesis elements specific to control systems}
\label{synthesis-elements}

\paragraph{Property specification}
Next, we describe the specific property that we pass to the program
synthesiser as the specification $\sigma$.  There are two different
algorithms in DSVerifier that can be used for stability
verification~\cite{daes20161,Bessa16}, one based on
Schur's decomposition and another one based on Jury's
criteria~\cite{astrom1997computer}.  Here, we choose Jury's
method~\cite{astrom1997computer}, due to its efficiency.

We use this method to check the stability in the $z$-domain for the
characteristic polynomial $S(z)$ defined
in~\eqref{eq:internal_stab_lemma}.

% of the matrix $\left( \begin{array}{c} Y \\ U \end{array}\right)$, where $Y(z)$ is the closed-loop system output and U(z) is the controller output. 
%% \red{[unclear: what matrix? We need to clarify the relationship
%% between the char. poly. $S(z)$ and the later quantities $\Delta
%% N_{G}(z), \Delta D_{G}(z)$ and corresponding controller's
%% structure.]}.
%
We consider the following form for $S(z)$:
%
$$
S(z) = a_0z^N+a_1z^{N-1}+\cdots+a_{N-1}z+a_N=0, a_0\neq0
$$
%
%\cdsay{is this for the matrix $\left( \begin{array}{c} Y \\ U \end{array}\right)$?}

% Assuming that $\hat{G}(z) = \frac{\hat{N_G}(z)}{\hat{D_G}(z)}$
% and $\hat{C}(z) = \frac{\hat{N_C}(z)}{\hat{D_C}(z)}$, then:
% $$S(z) = FWL[N_C(z)] \times \hat{N_G}(z) + FWL[D_C(z)] \times \hat{D_G}(z)$$

Next, the following Jury matrix
$M = [m_{ij}]_{(2N−2)\times N}$ is built from $S(z)$ coefficients:
%
$$
M=\left( 
\begin{array}{c}
V^{(0)}\\
V^{(1)}\\
\vdots\\
V^{(N-2)}
\end{array}
\right), 
$$
%
where $V^{(k)} = [v^{(k)}_{ij} ]_{2\times N}$ such that:
%
$$
v_{ij}^{(0)}=\left\{
\begin{array}{ll}
a_{j-1}, & \texttt{if}~i=1\\
v_{(1)(N-j+1)}^{0},&\texttt{if}~i=2
\end{array}
\right.
$$
%
$$
v_{ij}^{(k)}=\left\{
\begin{array}{ll}
0,&\texttt{if}~j>n-k\\
v_{1j}^{(k-1)}-v_{2j}^{(k-1)} . \frac{v_{11}^{(k-1)}}{v_{21}^{(k-1)}}, & \texttt{if}~j\leq n-k ~\texttt{and}~i=1\\
v_{(1)(N-j+1)}^{k},& \texttt{if}~j\leq n-k ~\texttt{and}~i=2\\
\end{array}
\right.
$$
%
where $k \in \mathbb{Z}$, such that $0 < k < N - 2$. 
$S(z)$ is the
characteristic polynomial of a stable system if and only if the following four conditions hold:
\begin{itemize}
\item $R_1: S(1) > 0$;
\item $R_2: (−1)^N S(−1) > 0$;
\item $R_3: |a_0| < a_N$;
\item $R_4: m_{11} > 0 \wedge m_{31}>0 \wedge m_{51}>0 \wedge \cdots \wedge m_{(2N{-}3)(1)}>0$.
\end{itemize}

The stability property is then encoded by creating a
constraint of the form:
$$
\phi_{stability} \equiv (R_1 \wedge R_2 \wedge R_3 \wedge R_4).
$$
%\cdsay{figure out what is existentially quantified for the final $\sigma$.} 
%% \red{[Yes, intuitively all clear, however for the sake of clarity I would like to see the explicit mapping between the above formula and the previously used specification 
%% $\sigma(x, P)$, with clear elucidation of the relationship between the domain of $z$ and that of $x$.]}

% \red{[clear elucidation of the mapping between this and the domains used 
% in the general description of the synthesiser]}

\paragraph{Use of fixed-point computation in the program synthesis engine}
The program synthesis engine uses fixed-point arithmetic.
Namely, we use the domain $\mathbb{R}\param{I}{F}$
for the controller's coefficients and the domain 
$\mathbb{R}\param{I_b}{F_b}$ for the plant's coefficients.
Note that $I$ and $F$, as well as $I_b$ and $F_b$, 
denote the integer and fractional size, respectively, with
$\mathbb{R}\langle I_b,F_b \rangle \supseteq \mathbb{R}\langle I,F \rangle$.
%the coefficients for $C(z)$ 
%$N_c$ and $D_c$ 
%in the domain $\mathbb{R}\param{I}{F}$, 
%and $\mathbb{R}^{m_C}\param{I}{F}$, respectively, 
%where $n_C$ and $m_C$ denote the order of the corresponding polynomials
%where $I$ and $F$ denote the integer and fractional size, respectively.
%Regarding the plant, its coefficients are this is synthesised over the 
%domain $\mathbb{R}^{n_G+m_G}\param{I_b}{F_b}$, where $n_G$ and $m_G$ 
%denote the order of the polynomials representing the 
%numerator and denominator of the plant's transfer function, respectively. 
%Again, $I_b$ and $F_b$ denote the integer and fractional size, respectively, with
%$\mathbb{R}\langle I_b,F_b \rangle \supseteq \mathbb{R}\langle I,F \rangle$.

Given the use of fixed-point arithmetic, 
we need to examine the effect of discretization during these operations.
Let $\tilde C(z)$ and $\tilde G(z)$ be the transfer functions represented
using fixed-point bit vectors.%  with integer size $I_b$ and fractional
% size $F_b$, whose domain is $\mathbb{R}\langle I_b,F_b \rangle \supseteq \mathbb{R}\langle I,F \rangle$.
%
\begin{align}
\small
\label{digital_controller_plant_tf}
\tilde C(z)&=\frac{\tilde \beta_{0}+\tilde \beta_{1}z^{-1}+...+\tilde \beta_{M_C}z^{-M_C}}{\tilde \alpha_{0}+\tilde \alpha_{1}z^{-1}+...+\tilde \alpha_{N_C}z^{-N_C}}, \\
%\label{plant_tf}
\tilde G(z)&=\frac{\tilde b_{0}+\tilde b_{1}z^{-1}+...+\tilde b_{M_G}z^{-M_G}}{\tilde a_{0}+\tilde a_{1}z^{-1}+...+\tilde a_{N_G}z^{-N_G}}.
\end{align}
 
Since the controller is synthesized in the $\mathbb{R}\langle I,F \rangle$
domain,
%
 $$\forall i \leq N_C, j \leq M_C\ \  \tilde \beta_{i} \equiv \beta_{i} \wedge \tilde \alpha_{j} \equiv \alpha_{j} \Leftrightarrow \tilde C(z) \equiv C(z)$$
%
However, given a real plant $\hat{G}(z)$, and a discretizing function
\begin{align}
\small
\label{FWL_tf}
&f_b (x \in \mathbb{R}) \rightarrow \tilde x \in \mathbb{R}\langle I_b,F_b \rangle \triangleq \tilde x = x-(x\mod\tilde x) \\
&FWL_b[P \in \mathcal{P}] = \tilde P \in \mathcal{P}^{n}\langle I_b,F_b \rangle : c_i \in P \wedge \tilde c_i \in \tilde P=f_b(c_i)  \nonumber
\end{align}
we calculate $\tilde G(z)=FWL_b(\hat{G}(z))$
\begin{align}
% \label{digital_controller_tf}
% \tilde C(z)&=\frac{(\hat{\beta}_{0}+\Delta_q \hat{\beta}_{0}) +...+(\hat{\beta}_{M_C}+\Delta_q \hat{\beta}_{M_C})z^{-M_C}}{(\hat{\alpha}_{0}+\Delta_q \hat{\alpha}_{0})+...+(\hat{\alpha}_{N_C}+\Delta_q \hat{\alpha}_{N_C})z^{-N_G}} \nonumber \\
% &= C(z) =\hat{C}(z) + \Delta{C}_b(z)\\
\label{digital_plant_tf}
\tilde G(z)&=\frac{(\hat{b}_{0}+\Delta_b \hat{b}_{0}) +...+(\hat{b}_{M_G}+\Delta_b \hat{b}_{M_G})z^{-M_G}}{(\hat{a}_{0}+\Delta_b \hat{a}_{0})+...+(\hat{a}_{N_G}+\Delta_b \hat{a}_{N_G})z^{-N_G}} \nonumber \\
&=\hat{G}(z)+\Delta{G}_b(z)=G(z)+\Delta{G}_P(z)+\Delta{G}_b(z).
\end{align}
where $\Delta_b\hat{c}_i=\hat{c}_i\mod \tilde{c}_i$
and $\Delta{G}_b(z)$ represents the plant uncertainty caused by
the rounding off effect.  We may encompass all the uncertainty as
$\Delta{G}(z)=\Delta{G}_P(z)+\Delta{G}_b(z)$.  % Since this value is
% nondeterministic, the set of possible polynomial coefficients of $\tilde G(z)$ is
% denoted by $\mathfrak{G}(z)$.

\paragraph{Our synthesis problem}
The synthesis problem we are trying to solve is the following:
find a digital controller $C(z)$ %denoted by  $N_c$ and $D_c$ 
that makes the closed-loop system stable 
for all possible uncertainties 
%$\Delta{\vec{p}}$ (\ref{eq:uncertainty}).
$\tilde G(z)$ (\ref{digital_plant_tf}).
%, where we precisely describe 
%$(\Delta N_G, \Delta D_G)$. 
% Note that, similar to the rest of the paper, we use the notation 
% $\tilda{N_G}(z) = N_G(z) + \Delta N_G(z)$ and 
% $\hat{N_C}(z) = N_C(z) + \Delta N_C(z)$.
When mapping back to the notation used for describing the general architecture 
of the program synthesiser, the controller $C(z)$ denotes $P$ and 
$\tilde G(z)$ represents $x$. 

As mentioned above, we compute the coefficients for $C(z)$ 
%$N_c$ and $D_c$ 
in the domain $\mathbb{R}\param{I}{F}$, 
%and $\mathbb{R}^{m_C}\param{I}{F}$, respectively, 
%where $n_C$ and $m_C$ denote the order of the corresponding polynomials
and those for $\tilde G(z)$ in the domain
$\mathbb{R}\langle I_b,F_b \rangle$.

\paragraph{The {\sc Synthesise} and {\sc Verify} phases}
The {\sc synthesise} phase uses BMC to 
compute a solution ($N_c$,$D_C$). % An important remark is that this 
% controller is synthesised in the $\mathbb{R}\langle I,F \rangle$
% domain.

There are two approaches for the {\sc verify} phase based on the
described model.  The first uses interval arithmetic, representing the
coefficients
$[{c}_i-\Delta_p{c}_i-\Delta_b{c}_i\ ,\
{c}_i+\Delta_p{c}_i-\Delta_b{c}_i+(2^{-F_b})]$ 
and rounding operations outwards during the process. 
%\cdsay{dario, what coefficients are these?}
% This results in a
% tighter calculation of the error at the cost of
% performance.
Synthesised controllers using this verifier will always
be correct and only generate counterexamples when the precision of the
engine is insuficient.  Given the high computational cost of this
approach, we also designed a second approach, which we describe below.
In our implementation described in Sec.~\ref{sec:experiments}, we 
try both approaches and provide the time for the fastest. 
% show that the increase in speed of the second approach 
% over the first one is in most cases of several orders of magnitude.

In Fig.~\ref{fig:CEGIS}, we illustrate the second approach, which 
uses a two-stage verification. 
In the first stage, denoted by {\sc Uncertainty} in Fig.~\ref{fig:CEGIS}, 
assuming a certain precision \param{I_b}{F_b} for the uncertainty,
\cdsay{how about the controller?}
we check whether the system is unstable for the current candidate solution,
{\it i.e.}, if $\neg \phi_{stability}$ is satisfiable for $S(z)$.
If this is the case, then we obtain a counterexample 
$\Delta \vec{p}$, 
%denoted by values for each coefficients of $\Delta N_{G}(z)$ and $\Delta D_{G}(z)$, 
%\red{[see my comment above - these quantities pop up too abruptly.]},
which makes the closed-loop system unstable. 
This uncertainty is added to 
the set {\sc inputs} such that, in the subsequent {\sc synthesise} phase, 
we obtain a candidate solution consisting 
of a controller $D_C$ and $N_C$, which makes the closed-loop 
system stable for all the uncertainties accumulated in {\sc inputs}.

If the {\sc Uncertainty} verification stage concludes that
the system is stable for the current candidate solution,
then we pass this solution to the second verification stage, {\sc Precision}, 
which checks the propagation of the error in the fixed-point 
calculations using a Fixed-point Arithmetic Verifier based on 
interval arithmetic. 
%
% To achieve this, we use a nondeterministic plant selected from $\mathfrak{G}(z)$ where the expected error of the bit vector calculations is assumed to be within the expected bounds and verified after synthesis using the interval version of the program. 
%
% The first verification phase produces a counterexample if some instance of $\mathfrak{G}(z)$ does not verify the properties and the CEGIS loop iteratively looks for a new controller that verifies the supplied counterexamples. The second phase verifies the propagation of the error in the fixed point calculations.
% If the second phase fails verification, we increase the precision of the analyser and feed the CEGIS loop again to find a sound solution. 
% vouches for the use of CEGIS in most of our benchmarks.
% \cdsay{end of integration}

If the {\sc precision} verification returns $false$, then we 
increase the precision of \param{I_b}{F_b} and re-start the {\sc synthesise} phase
with an empty {\sc inputs} set.
Otherwise, we found a full solution for our synthesis problem
and we are done.

\subsection{Program synthesis for the running example}
We will illustrate our synthesis approach on the running example 
in Sec.~\ref{sec:running-ex}.
We start with the candidate solution with all coefficients zero 
given below at $I_b=16,F_b=24$.
Note that the digital controller is designed with typical control system
techniques \cite{Kuo:2002:ACS:579453,Ogata:1987:DCS:26170}.
%\red{[Be more explicit, write out spurious candidate solution with zero coefficients. KISS - you don't want to lose the control audience here.]}.

%$$
%\begin{array}{ll}
%N_C(z) {=} 0z^2{+}0z{+}0\\
%D_C(z) {=} 0z^2{+}0z{+}0\\
%\end{array}
%$$
$$
C(z)=\frac{0z^2{+}0z{+}0}{0z^2{+}0z{+}0}
$$

In the first {\sc verify} stage, the {\sc uncertainty} 
check finds the following counterexample:

$$
\tilde G(z) = \frac{0.026506}{1.000610z+1.002838}
$$


%$$
%\begin{array}{ll}
%\Delta N_G(z) = 0.026506\\
%\Delta D_G(z) = 1.000610z+1.002838
%\end{array}
%$$

We add this counterexample to {\sc inputs} and initiate the {\sc synthesise} phase, where we get the following candidate solution: 
%\red{[ How is the order of the candidate solution chosen here?]}
$$
C(z)=\frac{12.402664z^2{-}11.439667z{+}0.596756}{4.003906z^2{-}0.287949z{+}0.015625}
$$

This time the {\sc uncertainty} check doesn't find any more counterexamples 
and we pass the current candidate solution to the {\sc precision} verification stage.
% In the second {\sc verify} phase, we check whether the current candidate
% solution above is the final solution. It is not and the verifier signals
% that it is due to lack of precision.
We obtain the result $false$, meaning that the current precision is insuficient.
Consequently, we increase our precision to $I_b=20,F_b=28$.
%
Since the previous counterexamples were attained at lower precision, we 
remove them from the counterexample set. Back in the {\sc synthesise}
phase, we re-start the process with a candidate solution with all coefficients 0.
Next, the {\sc uncertainty} verification stage provides the first counterexample at higher
precision:
%
%$$
%\begin{array}{ll}
%\Delta N_G(z) {=} 0.026314\\
%\Delta D_G(z) {=} 0.999024z{-}1.004785
%\end{array}
%$$
$$
\tilde G(z) = \frac{0.026314}{0.999024z{-}1.004785}
$$

%\blue{[Nice, now I'm in the groove. Next unfolds well.] }
In the next {\sc synthesise} phase, we get a new candidate solution that holds for
the new, higher precision counterexample:

$$
C(z)=\frac{11.035202z^2{+}5.846100z{+}4.901855}{1.097901z^2{+}0.063110z{+}0.128357}
$$
%
%$$
%\begin{array}{ll}
%N_C(z) {=} \\
%D_C(z) {=} \\
%\end{array}
%$$

This candidate solution is validated as the final solution by both stages 
{\sc uncertainty} and {\sc precision} in the
{\sc verify} phase. %, which fails to find a new counterexample (i.e. returns UNSAT).

% \blue{
% For the same cruise control system, the synthesis may be done considering that the plant model have parametric uncertainties ($\Delta G_{P}(z)$). Thus, the synthesised controller must to stabilize for any parametric variation $\Delta p$ inside of a given region. Specially, in this example, was assumed that each coefficient of $G(z)$ may vary $\pm 0.5\%$.
% }

% \blue{Initially, the controller denominator and numerator  ($D_{C}(z)$ and $N_{C}(z)$) are started with zero coefficients, as in previous example. Thus,  in the first {\sc verify} phase a counterexample is presented, that is added to {\sc inputs}, whis is usede in the first  {\sc synthesise} phase. The resulting controller is:
% }
% $$
% {
% \blue{
% C(z)=\frac{0.77516z^2{+}-0.71497z{+}0.03729}{0.25024z^2{-}0.01799z{+}0.00097}
% }}
% $$

% \blue{In the second {\sc verify} phase, the controller failed to stabilize the system for all the range of uncertainties, another counterexample was provided, and the following candidate controller is presented in another {\sc synthesise} phase:}
% $$
% {
% \blue{
% C(z)=\frac{0.68970z^2{+}0.36538z{+}0.30637}{0.06862z^2{+}0.00394z{+}0.00802}
% }}
% $$

% \blue{
% This candidate solution is validated as the final solution by the next 
% {\sc verify} phase.
% }

\begin{figure*}
\centering
\resizebox{.7\textwidth}{!}{
 \begin{tikzpicture}[scale=0.3,->,>=stealth',shorten >=.2pt,auto, semithick, initial text=, ampersand replacement=\&,]
  \matrix[nodes={draw, fill=none, shape=rectangle, minimum height=.2cm, minimum width=.2cm, align=center
},
          row sep=1cm, column sep=1.5cm] {
   \coordinate (aux1);
   \& \coordinate (aux2);
   \&;\\
   \node[fill=yellow!20] (synth) {{\sc Synthesise}};
   \&
   complexnode/.pic={ 
     \node[rectangle,draw,dashed,
	minimum width=7cm,
	minimum height=.8cm,
	label={\sc Verify},] (verif) {};
   \node[fill=yellow!20] (verif1) at ([xshift=-2cm]verif.center) {{\sc ~Uncertainty~~~~}};
   \node[fill=yellow!20] (verif2) at ([xshift=2cm]verif.center) {{\sc ~~~~~Precision~~~}};
   } 
   \& \node[ellipse, fill=yellow!20] (done) {{\sc Done}};\\
   %% \node[fill=yellow!20] (verif) {{\sc ~~~~~~Uncertainty~~~~~~}};
   %% \&
   %% \node[fill=yellow!20] (verif2) {{\sc ~~~~~~Precision~~~~~~~}};\\
   \& \\
   \& \\
   \node (gp) {Closed-loop System Search};
   \&
   complexnode/.pic={ 
     \coordinate (aux);
   \node (bmc) at ([xshift=-2cm]aux.center) {BMC-based Verifier};
   \node (fp)  at ([xshift=2cm]aux.center) {Fixed-point \\Arithmetic Verifier};
   }   
    \\
  };

   \path
    ([yshift=2em]synth.east) edge node {Candidate solution} ([yshift=2em]verif1.west)
    ([yshift=-2em]verif1.west) edge node {Counterexample} ([yshift=-2em]synth.east)
    ([xshift=5em]verif1.south) edge node[align=center] {Candidate\\ $P$} ([xshift=5em]bmc.north)
    ([xshift=5em]verif2.south) edge node[align=center] {Candidate\\ $P$} ([xshift=5em]fp.north)
    ([xshift=-5em]bmc.north) edge node[align=center]  {UNSAT/\\model} ([xshift=-5em]verif1.south)
    ([xshift=-5em]fp.north) edge node[align=center]  {True/\\False} ([xshift=-5em]verif2.south)
    (verif2) edge node {} (done)
    ([xshift=5em]synth.south) edge node[align=center] {Inputs} ([xshift=5em]gp.north)
    ([xshift=-5em]gp.north) edge node[align=center] {UNSAT/\\candidate} ([xshift=-5em]synth.south)
    (aux1) edge (synth.north);
   \path[-]
   (verif2.north) edge node[align=center] {} ([xshift=6.7cm]aux2)
   ([xshift=6.7cm]aux2) edge node[align=center] {Increase Precision} (aux1);

 \end{tikzpicture}
}
 \caption{Counterexample-Guided Inductive Synthesis of Closed-loop System (CEGIS paradigm). 
\label{fig:CEGIS}}
\end{figure*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Experimental Evaluation} \label{sec:experiments}

This section is split into three parts. Section~\ref{experimental-setup}
discusses the experimental setup and the employed benchmarks, while
Section~\ref{experimental-objectives} describes the experimental objectives. 
Section~\ref{experimental-results} describes the experimental results
related to the application of CEGIS to the standard closed-loop control
system benchmarks described in Section~\ref{experimental-setup}.

%---------------------------------
\subsection{Description of Benchmarks}
\label{experimental-setup}
%---------------------------------

The first set of benchmarks considers the discrete plant of a cruise 
control model for the car accounting for rolling friction, aerodynamic drag, 
and gravitational disturbance force~\cite{Astrom08} as follows
%
\begin{equation}
\label{cruise-control-c1}
G_1(z)=\frac{0.0264}{z-0.998}. \nonumber
\end{equation} 

%Two proportional-integral (PI) controllers are designed by Wang {\it et al.} 
%for the cruise control plant $G(z)$~\cite{DBLP:conf/hybrid/WangGRJF16}, 
%which has the following mathematical model
%
%\begin{equation}
%\label{cruise-control-g1}
%C_{1}(z)=\frac{1.51z-1.3586}{z-1}, \nonumber
%\end{equation} 
%
%\begin{equation}
%\label{cruise-control-g2}
%C_{2}(z)=\frac{2.72z^2 - 4.153z + 1.896}{1.0z^2 - 1.844z + 0.8496}. \nonumber
%\end{equation} 

The second set of benchmarks considers a simple spring-mass 
damper~\cite{DBLP:conf/hybrid/WangGRJF16}, where the discrete 
plant dynamics is represented by the following z-expression
%
%where both discrete 
%plant dynamics and controller are represented by the following 
%z-expression, resp.
%
\begin{equation}
\label{spring-mass-damper-g}
G_2(z)=\frac{5\times{10^{-5}}z + 5\times{10^{-5}}}{z^2 - 2z + 1.0001}. \nonumber
\end{equation} 
%
%\begin{equation}
%\label{spring-mass-damper-c}
%C_3(z)=\frac{1.28\times{10^{3}}z^2 - 1.354240\times{10^{3}}z + 0.074879\times{10^{3}}}{z^2 - 1.4990z + 0.4995}. \nonumber
%\end{equation} 

A third set of benchmarks that consists of a physical plant for satellite
applications is considered~\cite{Franklin15}, in order to evaluate the
present approach full capabilities.  In particular, satellites often require
attitude (pose) control for proper orientation of antennas and sensors
w.r.t.  earth.  The satellite attitude control is typically used for
three-axis attitude tracking, but here only one axis at a time is
considered.  The motion equation for the one-axis system, despising
disturbance torques, is given by
%
\begin{equation}
\label{eq:satelliteode}
I\cdot \ddot{\theta} = \tau_{C},
\end{equation}

\noindent where $I$ is the inertia moment of satellite about its mass center, $\tau_{C}$ is the control 
torque applied by thusters, and $\theta$ is the controlled attitude angle. 
Normalizing Eq.~\eqref{eq:satelliteode} by defining the control signal $u=\frac{\tau_{C}}{I}$ and 
taking Laplace transform, the following $s$-domain transfer function $G(s)$ is obtained
%
\begin{equation}
\label{eq:satellitetf}
G_{3}(s)=\frac{\theta(s)}{u(s)}=\frac{1}{s^2},
\end{equation}

\noindent using the ZOH discretisation defined in Eq.~\eqref{eq:pulsetf}, 
the following $z$-domain model is obtained
%
\begin{equation}
G_{3}(z)= \frac{T^{2}}{2} \frac{z+1}{(z+1)^{2}}.
\end{equation}

%The discrete controllers $C_{4}$ and $C_{5}$ for the satellite plant $G_{3}$, discretized with sample time $1s$ and $2s$ respectively, 
%are represented by the following z-expression:
%
%\begin{equation}
%\label{satellite-b2}
%C_{4}(z)=\frac{2.88z^2 - 4.896z + 2.074}{1.0z^2 - 0.42z - 0.3465 - 0.03915}. \nonumber
%\end{equation} 
%
%\begin{equation}
%\label{satellite-c2}
%C_{5}(z)=\frac{0.43z^2 - 0.2408z - 0.1316}{1.0z^2 + 1.5z + 0.97 + 0.183}. \nonumber
%\end{equation} 

The fourth (and last) set of benchmarks considers the following description for the plant 
$G_{4}(s)$, which is typically used for evaluating stability margins~\cite{bhattacharyya97,keel_Bhattacharyya_examples}
%
\begin{equation}
\label{exampleA}
G_{4}(s)=\frac{s-1}{s^{2}-s-2}
\end{equation}
%
\noindent where $G_{4}(z)$ is obtained using the ZOH discretisation defined 
in Eq.~\eqref{eq:pulsetf} with $3$ different sample times ($0.1$, $0.05$, and $0.03$ 
seconds).

All experiments were conducted on a 12-core 2.40\,GHz Intel Xeon E5-2440 with 96\,GB
of RAM, and Linux OS.  All times given are wall clock time in seconds as measured
by the UNIX date command.

%---------------------------------
\subsection{Objectives}
\label{experimental-objectives}
%---------------------------------

Using the closed-loop control system benchmarks described in Section~\ref{experimental-setup}, 
the experimental evaluation of the present approach aims to answer two research questions:
%
\begin{enumerate}
	\item RQ1 \textbf{(sanity check)} which results does our CEGIS approach to FWL controller synthesis 
	obtain upon synthesizing/verifying benchmarks that compose the specified suite?
  \item RQ2 \textbf{(performance)} does the CEGIS approach provide a feasible solution in reasonable time
	considering robust stability of FWL digital controllers?	
\end{enumerate}

%---------------------------------
\subsection{Results}
\label{experimental-results}
%---------------------------------

We outline the runtimes required to synthesise a stable controller for each
benchmark in Table~\ref{tab:results}. For the majority of our benchmarks the conjecture explained
in section~\ref{synthesis-elements}  holds and the inductive back-end is able to find a stable
solution in less than one minute.  This is possible if the inductive solutions need to be refined
with few counterexamples and fixed-point precision increases. However, two benchmarks in our set
did not meet these criteria (marked with $^*$ in Table~\ref{tab:results}) \textcolor{red}{Pascal: Why they did not meet the criteria?}. 
In these cases, the interval arithmetic back-end is able to complement the inductive approach
and synthesise a solution instead, albeit with significantly larger runtimes \textcolor{red}{Pascal: Why is it slower?}.

\begin{table}[H]
\centering
\begin{tabular}{c | l r r | r l}
Plant & Benchmark                  & $I$ & $F$ & Time    & \\\cline{1-5}
$G_1$ & CruiseControl02            &   4 &  16 & 17\,s   & \\
$G_1$ & CruiseControl02$^\dagger$  &   4 &  16 & 46\,s   & \\
$G_2$ & SpringMassDamper           &  15 &  16 & 28\,s   & \\
$G_2$ & SpringMassDamper$^\dagger$ &  15 &  16 & \xmark  & \\
$G_3$ & SatelliteB2                &   3 &   7 & 7\,s    & \\
$G_3$ & SatelliteB2$^\dagger$      &   3 &   7 & 6601\,s & \tbmark\\
$G_3$ & SatelliteC2                &   3 &   5 & 2\,s    & \\
$G_3$ & SatelliteC2$^\dagger$      &   3 &   5 & 76\,s   & \tbmark\\
$G_4$ & a\_PL1\_SCH2\_IMPL1        &  16 &   4 & 2704\,s & \\
$G_4$ & a\_PL1\_SCH2\_IMPL2        &  16 &   8 & 538\,s  & \\
$G_4$ & a\_PL1\_SCH2\_IMPL3        &  16 &  12 & 12\,s   & \\
$G_4$ & a\_PL1\_SCH3\_IMPL1        &  16 &   4 & 318\,s  & \\
$G_4$ & a\_PL1\_SCH3\_IMPL2        &  16 &   8 & 967\,s  & \\
$G_4$ & a\_PL1\_SCH3\_IMPL3        &  16 &  12 & 9798\,s & \\
$G_4$ & a\_PL1\_SCH4\_IMPL1        &  16 &   4 & 6304\,s & \\
\end{tabular}

\vspace{0.5em}
\scriptsize{* = solved with interval back-end, $\dagger$ = with uncertainty}
\vspace{0.5em}

\caption{Experimental results. \label{tab:results}}
\end{table}
%---------------------------------

We conclude from these results that the inductive back-end is able to synthesise 
stable controllers in the $12$ out of $15$ benchmarks, and can be complemented using 
the interval arithmetic back-end for $2$ additional benchmarks, where the inductive 
conjectures fail. Both back-ends together enabled controller synthesis for $14$ 
out of $15$ benchmarks within reasonable time frames. \textcolor{red}{Why do we fail to synthesise 1 controller?} 
\pksay{TODO: Upload full experiments environment including README and result log files to anonymous Google Drive and
provide link here.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related Work}

\paragraph{Robust synthesis of Linear Systems} 

The problem of parametric control synthesis based on stability measures for
continous Linear Time Invariant (LTI) Single Input-Single Output (SISO)
systems has been researched for several decades.  On a theoretical level it
is a solved problem~\cite{wonham1967pole} for which researches continuously
seek better results based on a number of properties in addition to
stability.  A vast range of pole placement techniques such as Moore's
algorithm for eigenstructure assignment~\cite{klein1977eigenvalue} or the
more recent Linear Quadratic Regulator (LQR)~\cite{bemporad2002explicit}
have been used in several studies with increasing degrees of succes to
ensure stability.  The latter approach highlights the importance of
conserving energy during the control process, which results in lower running
costs.  Since real systems are subject to tolerance and noise as well as the
need for economy, more recent studies focus on the problems of achieving
robust stability with minimum
gain~\cite{schmid2014unified,konigorski2012pole}.  However, when extending
the problem to digital controller synthesis, many of these techniques lack
the ability to produce sound or stable results because they disregard the
effects of quantisation and rounding.  Recent papers on
implementations/synthesis of LTI digital
controllers~\cite{das2013lqr,ghosh2013fpga} focus on time discretization,
failing to account for these error-inducing effects and can therefore result
in digitally unstable systems that have been proven to be robustly stable in
a continuous space.  This situation demands the inclusion of formal methods
to verify the effects of space discretization on the implementation of the
controller.

\paragraph{Formal Verification of Linear Digital Controllers} 

Researchers in formal verification of control systems have studied various
effects of discretising the dynamics, including delayed
response~\cite{Duggirala2015}, and Finite Word Length (FWL) constraints with
the goal to either verify ({\it e.g.}, \cite{daes20161}) or optimise ({\it
e.g.},~\cite{oudjida2014design}) implementations.  There are in fact two
different problems arising from FWL effects.  The first corresponds to the
error in the dynamics caused by the inability of the hardware to represent
the exact dynamics of the system whilst the second relates to rounding
errors during computation.  In \cite{fialho1994stability} a stability
measure based on the error of the digital dynamics ensures that the FWL
errors do not make the digital system unstable.  A more recent
approach~\cite{DBLP:journals/automatica/WuLCC09} uses $\mu$ calculus to
directly model the digital controller so that the selected parameters are
stable by design.  Most studies following this verification research field
focus on finding a correct implementation of a known desired controller,
looking for optimal parameter representations using FWL, but ignoring the
effects of rounding errors due to issues of mathematical tractability.  The
analyses in~\cite{DBLP:conf/hybrid/WangGRJF16,DBLP:conf/hybrid/RouxJG15}
rely on an invariant computation on the discrete system dynamics using
Semi-Definite Pogramming (SDP).  Whilst the former uses BIBO properties to
determine stability, the latter uses Lyapunov-based quadratic invariants. 
In both cases, the SDP solver uses floating-point arithmetic and soundness
is checked by upper bounding the error.  An alternative approach is taken by
\cite{park2016scalable}, where the verification of existing code is
performed against a known model by extracting an LTI model of the code
through symbolic execution.  In order to account for rounding errors, an
upper bound is introduced in the verification phase.  If the error of the
implementation is lower than this tolerance level, then the verification is
successful.

\paragraph{Robust Synthesis of FWL Digital Controllers}

Given the current knowledge in control system's synthesis, there is no other
existing study on the automatic synthesis of fixed-point digital controllers
considering FWL effects.  Parameter synthesis tools such
as~\cite{cimatti2013parameter} use bounded model checking and fixed-point
computations to find parameters based on user defined specifications, but
they often operate in the continuous domain and are ill-suited for robust
analysis since they have no direct means of evaluating robustness.  Other
tools such as~\cite{economakos2016automated} are directly aimed at robust
stability problems, but they fail to explore the effects of FWL in their
implementation.  In order to provide a correct by design digital controller,
\cite{alur2016compositional} requires a user-defined finite state
abstraction to synthesise a digital controller based on high level
specifications.  Whilst this approach directly overcomes the challenges
presented by the FWL problem, it still requires error-prone user
intervention.  A different solution that looks at the other end of the scale
is an approach that synthesises word lengths for known problems as developed
in \cite{jha2013swati}; however, this provides neither an optimal word
synthesis nor a comprehensive solution for the problem.  It is from this
vacuum that we seek to explore a CEGIS approach to FWL controller synthesis.

\paragraph{CEGIS}

In recent years the development of program synthesis has found many ways to
obtain correct by design programs from high-level specifications.  One such
approach~\cite{itzhaky2010simple} looks to inductively synthesise invariants
to generate the desired programs.  Since these digital programs are already
constrained by designed to factors such as FWL, these approaches are ideal
for the synthesis of parametric controllers. 
In~\cite{DBLP:conf/cdc/RavanbakhshS15}, the authors use CEGIS for the
synthesis of switching controllers for stabilizing continuous-time plants
with polynomial dynamics.  The work extends to its application on affine
systems, finding its major challenge in the hardness of solving linear
arithmetic on present SMT solvers.  Since this approach uses switching
states instead of linear dynamics in the digital controller, it entirely
circumvents the FWL problem.  It is also not suitable for the kind of
control we seek to synthesise.  What is needed in this regard is the
combination of a synthesis engine with a control verification tool that
addresses the challenges presented here in the form of FWL effects and
stability measures for LTI SISO controllers.  We take the former
from~\cite{DBLP:conf/lpar/DavidKL15} and the latter from~\cite{daes20161}
whilst enhancing the procedure by evaluating the quantaization effects of
the Hardware interfaces (ADC/DAC) to obtain an accurate discrete time FWL
representation of the continuous dynamics.
 
%In \cite{DBLP:journals/corr/PakmehrWJVF13}, Pakmehr et al.  design a control software verification framework for gas turbine engines.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusions}

In this study, we have investigated a CEGIS-based approach that uses inductive synthesis 
in conjunction with a robust closed-loop stability verification algorithm to find a parametric 
solution for a digital controller given a continuous (or discrete) plant specification.
In particular, we have exploited the automatic synthesis of correct-by-construction 
digital controllers along with a model of their physical environment.
We have also modeled a digital equivalent of the physical plant by evaluating the 
effects of the quantisers (A/D and D/A converters) as time discretisation elements 
with quantisation noise. Experimental results show that the inductive back-end of our
CEGIS-based approach is able to synthesise stable controllers in most benchmarks and can be 
complemented using the interval arithmetic back-end, where the inductive conjectures fail. 
Both back-ends enabled controller synthesis for all benchmarks within reasonable time frames.
Further studies include the extension of this CEGIS-based approach for different classes of systems
({\it e.g.}, state-space) and also consider performance requirements while synthesising 
the digital controller.


\bibliographystyle{abbrv}
\bibliography{paper}  

%APPENDICES are optional
%\balancecolumns
%\appendix
%Appendix A
\end{document}
