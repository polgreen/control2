Novelty (R1,R2,R3)

As far as we know, the present synthesis approach that addresses FWL
uncertainties in digital controllers has not been described or
evaluated in the literature.  This work is the first one to address
FWL uncertainties based on CEGIS for synthesizing correct-by-design
linear stabilizing digital controllers with fixed-point arithmetic for
linear continuous-time plants.

Assumptions (R2)

The parametric errors have the same order as that of the
plant. Modeling errors do not depend on sampling, holding, and
quantization errors, since they already appear in previous continuous
time models and are only propagated in the discrete version. The
reciprocal is true if the quantization noise is considered exogenous
signals as proposed to Figures 1 and 2. Although the parametric
uncertainties and the sampling/holding process present nonlinearities,
our linear approximation is enough to represent most of those effects,
which is typically employed in the control systems literature.

FWL characteristics (R1,R2)

The FWL implementation is a function of the number of integer bits $I$
and fractional bits $F$; $I$ strongly affects the representation range
and is set to avoid overflows, while $F$ affects the precision and the
truncation process after the operations. These variables are chosen
depending on hardware features. In general purpose processors and
DSP's, $I$ is minimized to avoid overflows and $F$ is employed for the
remaining bit representation. Other flexible hardware structures
(e.g., FPGAs) allow the design of $F$ and $I$, which affects directly
the number of logical gates. Note that in section 3.3 we explain that
there are two fixed-point domains in our control synthesis
problem. Whilst the first domain $\mathbb{R}<I,F>$, is the actual
controller domain, whereas $\mathbb{R}<I_p,F_p>$ is the bitvector
domain of the synthesiser, which is used to try and synthesise a real
plant. In this section we explain the latter is started at a lower
resolution for speed and the resolution increased when the rounding
errors in the synthesis algorithm do not allow for correct
synthesis. This is a tool optimization and does not relate to the
problem statement. The reason for the 8-bit steps is because the tool
uses byte alignment.

Experimental evaluation (R1,R2,R3)

We have evaluated our approach using standard benchmarks taken mostly
from the classical control literature [3,15,21,22,35]. Note that the
used benchmarks are typically from existing work on control system
verification. Larger benchmarks would strengthen our claims; however,
related work on controller verification typically considers even
smaller benchmarks (cf. 3.5 and 4.1). We only state the winning
back-end in the results table, annotating where the one-stage engine
was faster. The two order of magnitudes were measured empirically,
since the one-stage engine times out on the majority of
benchmarks. Additionally, we did include an upper bound for both the
bit width and execution time. Given an arbitrarily high precision and
given unlimited execution time, the engine will always succeed.

