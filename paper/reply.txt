Novelty (R1,R2,R3)

As far as we know, the present synthesis approach that addresses FWL
uncertainties in digital controllers has not been described or
evaluated in the literature.  Moreover, this work is the first use of
CEGIS that handles the effects of quantizers and FWL.  Note that doing
this efficiently required adjusting the traditional CEGIS refinement
loop to use a two-stage verification engine, where the first stage
performs fast, but potentially unsound fixed-point operations and the
second stage restores soundness by validating the operations performed
by the first stage by using interval arithmetic.  This architecture 
enabled us to obtain candidate solutions fast, which is key to our 
performance.

Assumptions (R2)

The parametric errors have the same order as that of the
plant. Modeling errors do not depend on sampling, holding, and
quantization errors, since they already appear in previous 
continuous-time models and are only propagated in the discrete-time version. 
The reciprocal is true if the quantization noise is considered exogenous
signals as proposed to Figures 1 and 2. Although the parametric
uncertainties and the sampling/holding process present nonlinearities,
our linear approximation is enough to represent most of those effects,
which is typically employed in the control systems literature.

FWL characteristics (R1,R2)

The FWL implementation is a function of the number of integer bits $I$
and fractional bits $F$; $I$ strongly affects the representation range
and is set to avoid overflows, while $F$ affects the precision and the
truncation process after the arithmetic operations. These variables are chosen
depending on hardware features. In general purpose processors and
DSP's, $I$ is minimized to avoid overflows and $F$ is employed for the
remaining bit representation. Other flexible hardware structures
(e.g., FPGAs) allow the design of $F$ and $I$, which affects directly
the number of logical gates. Note that in section 3.3 we explain that
there are two fixed-point domains in our control synthesis
problem. Whilst the first domain $\mathbb{R}<I,F>$, is the actual
controller domain, whereas $\mathbb{R}<I_p,F_p>$ is the bitvector
domain of the synthesiser, which is used to try and synthesise a real
plant. In this section we explain the latter is started at a lower
resolution for speed and the resolution increased when the rounding
errors in the synthesis algorithm do not allow for correct
synthesis. This is a tool optimization and does not relate to the
problem statement. The reason for the 8-bit steps is because the tool
uses byte alignment.

Experimental evaluation (R1,R2,R3)

We have evaluated our approach using standard benchmarks taken mostly
from the classical control literature [3,15,21,22,35]. Note that the
used benchmarks are typically from existing work on control system
verification. Larger benchmarks would strengthen our claims; however,
related work on controller verification typically considers even
smaller benchmarks (cf. 3.5 and 4.1). We only state the winning
back-end in the experimental results table, annotating where the one-stage engine
was faster. The two order of magnitudes were measured empirically,
since the one-stage engine times out on the majority of
benchmarks. Additionally, we did include an upper bound for both the
bit width and execution time. Note that given an arbitrarily high precision and
given unlimited execution time, the engine will always succeed.

Preliminaries (R1)

Since our stability analysis is based on polynomial coefficients
and not over signals, in Equation (8) $\Delta_{q} G$ is a model that incorporates 
the effects of $\nu$ in $\vec{\hat{G}}$, in order to investigate the system's 
stability consequences.

The $\Delta_{b}$ of a coefficient $c$ (represented by $\Delta_{b}c$) models 
the error in the fixed-point representation of $c$, which is the division remainder 
between the correct value of coefficient $c$ and its respective FWL format $\tilde{c}$, 
i.e., $\Delta_{b}c=c~ \texttt{mod}~\tilde{c}$.

